subroutine help_version(l_version)
implicit none
! @(#)help_version(3f): prints version information
logical,intent(in)             :: l_version
character(len=:),allocatable   :: help_text(:)
integer                        :: i
if(l_version)then
help_text=[ CHARACTER(LEN=128) :: &
'@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>',&
'@(#)PROGRAM:        intrinsics(1)>',&
'@(#)DESCRIPTION:    output source for man(1) pages of Fortran intrinsics>',&
'@(#)VERSION:        2.0, 20170305>',&
'@(#)AUTHOR:         John S. Urban>',&
'@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>',&
'@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>',&
'@(#)LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.>',&
'@(#)                There is NO WARRANTY, to the extent permitted by law.>',&
'@(#)COMPILED:       Mon, Dec 28th, 2020 8:38:15 PM>',&
'']
   WRITE(*,'(a)')(trim(help_text(i)(5:len_trim(help_text(i),kind=kind(1))-1)),i=1,size(help_text))
   stop ! if -version was specified, stop
endif
end subroutine help_version
!-----------------------------------------------------------------------------------------------------------------------------------
subroutine help_usage(l_help)
implicit none
! @(#)help_usage(3f): prints help information
logical,intent(in)             :: l_help
character(len=:),allocatable :: help_text(:)
integer                        :: i
if(l_help)then
help_text=[ CHARACTER(LEN=128) :: &
'NAME                                                                            ',&
'    intrinsics(1f) - [FUNIX] output text versions of Fortran intrinsic man(1) pages',&
'    (LICENSE:PD)                                                                ',&
'                                                                                ',&
'SYNOPSIS                                                                        ',&
'    intrinsics [ --help| --version]                                             ',&
'                                                                                ',&
'DESCRIPTION                                                                     ',&
'    This program outputs all the source of the man(1) pages of the Fortran intrinsics procedures.',&
'                                                                                ',&
'OPTIONS                                                                         ',&
'    --help     display this help and exit                                       ',&
'    --version  output version information and exit                              ',&
'                                                                                ',&
'EXAMPLES                                                                        ',&
'    Sample commands                                                             ',&
'                                                                                ',&
'       intrinsics >x;vi x                                                       ',&
'                                                                                ',&
'']
   WRITE(*,'(a)')(trim(help_text(i)),i=1,size(help_text))
   stop ! if -help was specified, stop
endif
end subroutine help_usage
!-----------------------------------------------------------------------------------------------------------------------------------
!>
!!##NAME
!!     intrinsics(1f) - [FUNIX] output text versions of Fortran intrinsic man(1) pages
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!     intrinsics [ --help| --version]
!!
!!##DESCRIPTION
!!     This program outputs all the source of the man(1) pages of the Fortran intrinsics procedures.
!!
!!##OPTIONS
!!     --help     display this help and exit
!!     --version  output version information and exit
!!
!!##EXAMPLES
!!
!!     Sample commands
!!
!!        intrinsics >x;vi x
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
program intrinsics_man_pages
use ISO_FORTRAN_ENV, only : io => OUTPUT_UNIT
use M_kracken,only : kracken, lget                                   ! add command-line parser module
implicit none
                                                               ! define command arguments, default values and crack command line
   call kracken('intrinsics','-help .false. -version .false.')
   call help_usage(lget('intrinsics_help'))                    ! if -help option is present, display help text and exit
   call help_version(lget('intrinsics_version'))               ! if -version option is present, display version text and exit
!-----------------------------------------------------------------------------------------------------------------------------------
write(io,'(a)')'NAME'
write(io,'(a)')'   intrinsics(7f) - [FORTRAN] intrinsic man(1) pages'
write(io,'(a)')'   (LICENSE:PD)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Got tired of not having the Fortran intrinsics available as man(1) pages,'
write(io,'(a)')'   especially when looking at code in the vim(1) editor and wanting to use the'
write(io,'(a)')'   "K" command to evoke the man(1) page.'
write(io,'(a)')''
write(io,'(a)')'   So, as a start I took the closest thing I knew, which was descriptions on the'
write(io,'(a)')'   Fortran Wiki, and am slowly turning them into man(1) pages and sometimes'
write(io,'(a)')'   altering them.'
write(io,'(a)')''
write(io,'(a)')'   *Note*: In many cases the descriptions of these intrinsics were originally'
write(io,'(a)')'   taken from the [[GFortran|GNU Fortran]] manual to make descriptions'
write(io,'(a)')'   on the Fortran Wiki by Jason Blevins (which were then used to start this'
write(io,'(a)')'   collection). Like the Fortran Wiki itself, the [[GFortran|GNU Fortran]]'
write(io,'(a)')'   manual is licensed under the [[GNU Free Documentation License]].'
write(io,'(a)')''
write(io,'(a)')'   These are at the state of "good enough considering the alternative is nothing",'
write(io,'(a)')'   but are still actively being completed.'
write(io,'(a)')''
write(io,'(a)')'CONTENTS'
write(io,'(a)')''
write(io,'(a)')'Inquiry intrinsic functions'
write(io,'(a)')''
write(io,'(a)')'The result of an inquiry function depends on the properties of its'
write(io,'(a)')'principal argument, not on the value of the argument. The value of the'
write(io,'(a)')'argument does not have to be defined.'
write(io,'(a)')''
write(io,'(a)')'   * [[allocated]]--Status of an allocatable entity'
write(io,'(a)')'   * [[associated]]--Status of a pointer or pointer/target pair'
write(io,'(a)')'   * [[bit_size]]--Bit size inquiry function'
write(io,'(a)')'   * [[command_argument_count]]--Get number of command line arguments'
write(io,'(a)')'   * [[digits]]--Significant digits function'
write(io,'(a)')'   * [[epsilon]]--Epsilon function'
write(io,'(a)')'   * [[extends_type_of]]--Type extension inquiry'
write(io,'(a)')'   * [[huge]]--Largest number of a kind'
write(io,'(a)')'   * [[is_contiguous]]--True if and only if an object is contiguous'
write(io,'(a)')'   * [[kind]]--Kind of an entity'
write(io,'(a)')'   * [[lbound]]--Lower dimension bounds of an array'
write(io,'(a)')'   * [[len]]--Length of a character entity'
write(io,'(a)')'   * [[maxexponent]]--Maximum exponent of a real kind'
write(io,'(a)')'   * [[minexponent]]--Minimum exponent of a real kind'
write(io,'(a)')'   * [[new_line]]--New line character'
write(io,'(a)')'   * [[precision]]--Decimal precision of a real kind'
write(io,'(a)')'   * [[present]]--Determine whether an optional dummy argument is specified'
write(io,'(a)')'   * [[radix]]--Base of a model number'
write(io,'(a)')'   * [[range]]--Decimal exponent range of a real kind'
write(io,'(a)')'   * [[same_type_as]]--Query dynamic types for equality'
write(io,'(a)')'   * [[shape]]--Determine the shape of an array'
write(io,'(a)')'   * [[size]]--Determine the size of an array'
write(io,'(a)')'   * [[tiny]]--Smallest positive number of a real kind'
write(io,'(a)')'   * [[ubound]]--Upper dimension bounds of an array'
write(io,'(a)')''
write(io,'(a)')'Math functions'
write(io,'(a)')''
write(io,'(a)')'   * [[abs]]--Absolute value'
write(io,'(a)')'   * [[acos]]--Arccosine function'
write(io,'(a)')'   * [[acosh]]--Inverse hyperbolic cosine function'
write(io,'(a)')'   * [[asin]]--Arcsine function'
write(io,'(a)')'   * [[asinh]]--Inverse hyperbolic sine function'
write(io,'(a)')'   * [[atan]]--Arctangent function'
write(io,'(a)')'   * [[atan2]]--Arctangent function'
write(io,'(a)')'   * [[atanh]]--Inverse hyperbolic tangent function'
write(io,'(a)')'   * [[bessel_j0]]--Bessel function of the first kind of order 0'
write(io,'(a)')'   * [[bessel_j1]]--Bessel function of the first kind of order 1'
write(io,'(a)')'   * [[bessel_jn]]--Bessel function of the first kind'
write(io,'(a)')'   * [[bessel_y0]]--Bessel function of the second kind of order 0'
write(io,'(a)')'   * [[bessel_y1]]--Bessel function of the second kind of order 1'
write(io,'(a)')'   * [[bessel_yn]]--Bessel function of the second kind'
write(io,'(a)')'   * [[cos]]--Cosine function'
write(io,'(a)')'   * [[cosh]]--Hyperbolic cosine function'
write(io,'(a)')'   * [[erf]]--Error function'
write(io,'(a)')'   * [[erfc]]--Complementary error function'
write(io,'(a)')'   * [[erfc_scaled]]--Error function'
write(io,'(a)')'   * [[gamma]]--Gamma function'
write(io,'(a)')'   * [[hypot]]--Euclidean distance function'
write(io,'(a)')'   * [[log]]--Logarithm function'
write(io,'(a)')'   * [[log10]]--Base 10 logarithm function'
write(io,'(a)')'   * [[log_gamma]]--Logarithm of the Gamma function'
write(io,'(a)')'   * [[sin]]--Sine function'
write(io,'(a)')'   * [[sinh]]--Hyperbolic sine function'
write(io,'(a)')'   * [[sqrt]]--Square-root function'
write(io,'(a)')'   * [[tan]]--Tangent function'
write(io,'(a)')'   * [[tanh]]--Hyperbolic tangent function'
write(io,'(a)')''
write(io,'(a)')'   * [[aimag]]--Imaginary part of complex number'
write(io,'(a)')'   * [[aint]]--Truncate to a whole number'
write(io,'(a)')'   * [[anint]]--Nearest whole number'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'   * [[achar]]--Character in ASCII collating sequence'
write(io,'(a)')'   * [[adjustl]]--Left adjust a string'
write(io,'(a)')'   * [[adjustr]]--Right adjust a string'
write(io,'(a)')'   * [[all]]--All values in MASK along DIM are true'
write(io,'(a)')'   * [[any]]--Any value in MASK along DIM is true'
write(io,'(a)')'   * [[atomic_add]]--Atomic ADD operation'
write(io,'(a)')'   * [[atomic_and]]--Atomic bitwise AND operation'
write(io,'(a)')'   * [[atomic_cas]]--Atomic compare and swap'
write(io,'(a)')'   * [[atomic_define]]--Setting a variable atomically'
write(io,'(a)')'   * [[atomic_fetch_add]]--Atomic ADD operation with prior fetch'
write(io,'(a)')'   * [[atomic_fetch_and]]--Atomic bitwise AND operation with prior fetch'
write(io,'(a)')'   * [[atomic_fetch_or]]--Atomic bitwise OR operation with prior fetch'
write(io,'(a)')'   * [[atomic_fetch_xor]]--Atomic bitwise XOR operation with prior fetch'
write(io,'(a)')'   * [[atomic_or]]--Atomic bitwise OR operation'
write(io,'(a)')'   * [[atomic_ref]]--Obtaining the value of a variable atomically'
write(io,'(a)')'   * [[atomic_xor]]--Atomic bitwise OR operation'
write(io,'(a)')'   * [[bge]]--Bitwise greater than or equal to'
write(io,'(a)')'   * [[bgt]]--Bitwise greater than'
write(io,'(a)')'   * [[ble]]--Bitwise less than or equal to'
write(io,'(a)')'   * [[blt]]--Bitwise less than'
write(io,'(a)')'   * [[btest]]--Bit test function'
write(io,'(a)')'   * [[c_associated]]--Status of a C pointer'
write(io,'(a)')'   * [[c_funloc]]--Obtain the C address of a procedure'
write(io,'(a)')'   * [[c_f_procpointer]]--Convert C into Fortran procedure pointer'
write(io,'(a)')'   * [[c_f_pointer]]--Convert C into Fortran pointer'
write(io,'(a)')'   * [[c_loc]]--Obtain the C address of an object'
write(io,'(a)')'   * [[c_sizeof]]--Size in bytes of an expression'
write(io,'(a)')'   * [[ceiling]]--Integer ceiling function'
write(io,'(a)')'   * [[char]]--Character conversion function'
write(io,'(a)')'   * [[cmplx]]--Complex conversion function'
write(io,'(a)')'   * [[co_broadcast]]--Copy a value to all images the current set of images'
write(io,'(a)')'   * [[co_max]]--Maximal value on the current set of images'
write(io,'(a)')'   * [[co_min]]--Minimal value on the current set of images'
write(io,'(a)')'   * [[co_reduce]]--Reduction of values on the current set of images'
write(io,'(a)')'   * [[co_sum]]--Sum of values on the current set of images'
write(io,'(a)')'   * [[compiler_options]]--Options passed to the compiler'
write(io,'(a)')'   * [[compiler_version]]--Compiler version string'
write(io,'(a)')'   * [[conjg]]--Complex conjugate function'
write(io,'(a)')'   * [[count]]--Count function'
write(io,'(a)')'   * [[cpu_time]]--CPU elapsed time in seconds'
write(io,'(a)')'   * [[cshift]]--Circular shift elements of an array'
write(io,'(a)')'   * [[date_and_time]]--Date and time subroutine'
write(io,'(a)')'   * [[dble]]--Double conversion function'
write(io,'(a)')'   * [[dim]]--Positive difference'
write(io,'(a)')'   * [[dot_product]]--Dot product function'
write(io,'(a)')'   * [[dprod]]--Double product function'
write(io,'(a)')'   * [[dshiftl]]--Combined left shift'
write(io,'(a)')'   * [[dshiftr]]--Combined right shift'
write(io,'(a)')'   * [[eoshift]]--End-off shift elements of an array'
write(io,'(a)')'   * [[event_query]]--Query whether a coarray event has occurred'
write(io,'(a)')'   * [[execute_command_line]]--Execute a shell command'
write(io,'(a)')'   * [[exp]]--Exponential function'
write(io,'(a)')'   * [[exponent]]--Exponent function'
write(io,'(a)')'   * [[float]]--Convert integer to default real'
write(io,'(a)')'   * [[floor]]--Integer floor function'
write(io,'(a)')'   * [[fraction]]--Fractional part of the model representation'
write(io,'(a)')'   * [[get_command]]--Get the entire command line'
write(io,'(a)')'   * [[get_command_argument]]--Get command line arguments'
write(io,'(a)')'   * [[get_environment_variable]]--Get an environmental variable'
write(io,'(a)')'   * [[iachar]]--Code in ASCII collating sequence'
write(io,'(a)')'   * [[iall]]--Bitwise and of array elements'
write(io,'(a)')'   * [[iand]]--Bitwise logical and'
write(io,'(a)')'   * [[iany]]--Bitwise or of array elements'
write(io,'(a)')'   * [[ibclr]]--Clear bit'
write(io,'(a)')'   * [[ibits]]--Bit extraction'
write(io,'(a)')'   * [[ibset]]--Set bit'
write(io,'(a)')'   * [[ichar]]--Character-to-integer conversion function'
write(io,'(a)')'   * [[ieor]]--Bitwise logical exclusive or'
write(io,'(a)')'   * [[image_index]]--Cosubscript to image index conversion'
write(io,'(a)')'   * [[index]]--Position of a substring within a string'
write(io,'(a)')'   * [[int]]--Convert to integer type'
write(io,'(a)')'   * [[ior]]--Bitwise logical inclusive or'
write(io,'(a)')'   * [[iparity]]--Bitwise exclusive or of array elements'
write(io,'(a)')'   * [[is_iostat_end]]--Test for end-of-file value'
write(io,'(a)')'   * [[is_iostat_eor]]--Test for end-of-record value'
write(io,'(a)')'   * [[ishft]]--Shift bits'
write(io,'(a)')'   * [[ishftc]]--Shift bits circularly'
write(io,'(a)')'   * [[co_lbound]]--Lower codimension bounds of an array'
write(io,'(a)')'   * [[leadz]]--Number of leading zero bits of an integer'
write(io,'(a)')'   * [[len_trim]]--Length of a character entity without trailing blank characters'
write(io,'(a)')'   * [[lge]]--Lexical greater than or equal'
write(io,'(a)')'   * [[lgt]]--Lexical greater than'
write(io,'(a)')'   * [[lle]]--Lexical less than or equal'
write(io,'(a)')'   * [[llt]]--Lexical less than'
write(io,'(a)')'   * [[logical]]--Convert to logical type'
write(io,'(a)')'   * [[maskl]]--Left justified mask'
write(io,'(a)')'   * [[maskr]]--Right justified mask'
write(io,'(a)')'   * [[matmul]]--matrix multiplication'
write(io,'(a)')'   * [[max]]--Maximum value of an argument list'
write(io,'(a)')'   * [[maxloc]]--Location of the maximum value within an array'
write(io,'(a)')'   * [[maxval]]--Maximum value of an array'
write(io,'(a)')'   * [[merge]]--Merge variables'
write(io,'(a)')'   * [[merge_bits]]--Merge of bits under mask'
write(io,'(a)')'   * [[min]]--Minimum value of an argument list'
write(io,'(a)')'   * [[minloc]]--Location of the minimum value within an array'
write(io,'(a)')'   * [[minval]]--Minimum value of an array'
write(io,'(a)')'   * [[mod]]--Remainder function'
write(io,'(a)')'   * [[modulo]]--Modulo function'
write(io,'(a)')'   * [[move_alloc]]--Move allocation from one object to another'
write(io,'(a)')'   * [[mvbits]]--Move bits from one integer to another'
write(io,'(a)')'   * [[nearest]]--Nearest representable number'
write(io,'(a)')'   * [[nint]]--Nearest whole number'
write(io,'(a)')'   * [[not]]--Logical negation'
write(io,'(a)')'   * [[norm2]]--Euclidean vector norm'
write(io,'(a)')'   * [[null]]--Function that returns an disassociated pointer'
write(io,'(a)')'   * [[num_images]]--Number of images'
write(io,'(a)')'   * [[pack]]--Pack an array into an array of rank one'
write(io,'(a)')'   * [[parity]]--Reduction with exclusive or'
write(io,'(a)')'   * [[popcnt]]--Number of bits set'
write(io,'(a)')'   * [[poppar]]--Parity of the number of bits set'
write(io,'(a)')'   * [[product]]--Product of array elements'
write(io,'(a)')'   * [[random_number]]--Pseudo-random number'
write(io,'(a)')'   * [[random_seed]]--Initialize a pseudo-random number sequence'
write(io,'(a)')'   * [[rank]]--Rank of a data object'
write(io,'(a)')'   * [[real]]--Convert to real type'
write(io,'(a)')'   * [[repeat]]--Repeated string concatenation'
write(io,'(a)')'   * [[reshape]]--Function to reshape an array'
write(io,'(a)')'   * [[rrspacing]]--Reciprocal of the relative spacing'
write(io,'(a)')'   * [[scale]]--Scale a real value'
write(io,'(a)')'   * [[scan]]--Scan a string for the presence of a set of characters'
write(io,'(a)')'   * [[selected_char_kind]]--Choose character kind'
write(io,'(a)')'   * [[selected_int_kind]]--Choose integer kind'
write(io,'(a)')'   * [[selected_real_kind]]--Choose real kind'
write(io,'(a)')'   * [[set_exponent]]--Set the exponent of the model'
write(io,'(a)')'   * [[shifta]]--Right shift with fill'
write(io,'(a)')'   * [[shiftl]]--Left shift'
write(io,'(a)')'   * [[shiftr]]--Right shift'
write(io,'(a)')'   * [[sign]]--Sign copying function'
write(io,'(a)')'   * [[sngl]]--Convert double precision real to default real'
write(io,'(a)')'   * [[spacing]]--Smallest distance between two numbers of a given type'
write(io,'(a)')'   * [[spread]]--Add a dimension to an array'
write(io,'(a)')'   * [[storage_size]]--Storage size in bits'
write(io,'(a)')'   * [[sum]]--Sum of array elements'
write(io,'(a)')'   * [[system_clock]]--Time function'
write(io,'(a)')'   * [[this_image]]--Cosubscript index of this image'
write(io,'(a)')'   * [[trailz]]--Number of trailing zero bits of an integer'
write(io,'(a)')'   * [[transfer]]--Transfer bit patterns'
write(io,'(a)')'   * [[transpose]]--Transpose an array of rank two'
write(io,'(a)')'   * [[trim]]--Remove trailing blank characters of a string'
write(io,'(a)')'   * [[co_ubound]]--Upper codimension bounds of an array'
write(io,'(a)')'   * [[unpack]]--Store the elements of a vector in an array of higher rank'
write(io,'(a)')'   * [[verify]]--Scan a string for the absence of a set of characters'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   INTRINSICS_PROJECT(7f) - [FORTRAN] intrinsic man(1) pages'
write(io,'(a)')'   (LICENSE:PD)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   This is a project to provide a standard set of man(1) pages for Fortran'
write(io,'(a)')'   and the Fortran intrinsics, ultimately with a working example program'
write(io,'(a)')'   for each intrinsic.'
write(io,'(a)')''
write(io,'(a)')'   The manpage source is maintained as a single flat-text file'
write(io,'(a)')'   (intrinsics.ff) which is run thru ufpp(1) and filters like txt2man(1)'
write(io,'(a)')'   to create the program intrinsics(1f). That program generates all'
write(io,'(a)')'   the text as plain text as well as being used as the source for the'
write(io,'(a)')'   man(1) pages. The program intrinsics(1f) is very useful for scanning'
write(io,'(a)')'   for keywords.'
write(io,'(a)')''
write(io,'(a)')'   Note that the vim(1) editor will call up a man(1) page for a word if'
write(io,'(a)')'   the letter "K" is pressed over the word.'
write(io,'(a)')''
write(io,'(a)')'   Integration with the editor is a powerful tool when inspecting code'
write(io,'(a)')'   that uses unfamiliar procedures and to verify correct usage when'
write(io,'(a)')'   creating code.'
write(io,'(a)')''
write(io,'(a)')'   *Note*: In many cases the descriptions of these intrinsics were'
write(io,'(a)')'   originally taken from the [[GFortran|GNU Fortran]] manual to make'
write(io,'(a)')'   descriptions on the Fortran Wiki by Jason Blevins (which were then'
write(io,'(a)')'   used to start this collection). Like the Fortran Wiki itself, the'
write(io,'(a)')'   [[GFortran|GNU Fortran]] manual is licensed under the [[GNU Free'
write(io,'(a)')'   Documentation License]].'
write(io,'(a)')''
write(io,'(a)')'   These documents are at the state of "good enough considering the'
write(io,'(a)')'   alternative is nothing", but are still actively being completed.'
write(io,'(a)')''
write(io,'(a)')'INTRINSICS SECTION'
write(io,'(a)')''
write(io,'(a)')'  XXXXX  XX  XXX XXXXXXX XXXXXX   XXXXX  XX  XXX  XXXXX   XXXXX    XXXX   XXXXX'
write(io,'(a)')'    X     X   X  X  X  X  X    X    X     X   X  X     X    X     X    X X     X'
write(io,'(a)')'    X     XX  X     X     X    X    X     XX  X  X          X    X       X'
write(io,'(a)')'    X     XX  X     X     X    X    X     XX  X  X          X    X       X'
write(io,'(a)')'    X     X X X     X     XXXXX     X     X X X   XXXXX     X    X        XXXXX'
write(io,'(a)')'    X     X  XX     X     X  X      X     X  XX        X    X    X             X'
write(io,'(a)')'    X     X  XX     X     X  X      X     X  XX        X    X    X             X'
write(io,'(a)')'    X     X   X     X     X   X     X     X   X  X     X    X     X    X X     X'
write(io,'(a)')'  XXXXX  XXX  X    XXX   XXX  XX  XXXXX  XXX  X   XXXXX   XXXXX    XXXX   XXXXX'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     FORMAT(3f) - [FORTRAN:INTRINSIC:I/O] Format statement'
write(io,'(a)')'     (LICENSE:PD)'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')' Format Statements'
write(io,'(a)')''
write(io,'(a)')'    fmt = "(F10.3,A,ES14.7)"        format string'
write(io,'(a)')'    101 format(f10.3,a,es14.7))     format statement'
write(io,'(a)')'    Iw Iw.m                         integer form'
write(io,'(a)')'    Bw.m Ow.m Zw.m                  binary, octal, hex integer form'
write(io,'(a)')'    Fw.d                            decimal form real format'
write(io,'(a)')'    Ew.d                            exponential form (0.12E-11)'
write(io,'(a)')'    Ew.dEe                          specified exponent length'
write(io,'(a)')'    ESw.d ESw.dEe                   scientific form (1.2E-10)'
write(io,'(a)')'    ENw.d ENw.dEe                   engineer. form (123.4E-12)'
write(io,'(a)')'    Gw.d                            generalized form'
write(io,'(a)')'    Gw.dEe                          generalized exponent form'
write(io,'(a)')'    Lw                              logical format (T, F)'
write(io,'(a)')'    A Aw                            characters format'
write(io,'(a)')'    nX                              horizontal positioning (skip)'
write(io,'(a)')'    Tc TLc TRc                      move (absolute, left, right)'
write(io,'(a)')'    r/                              vert. positioning (skip lines)'
write(io,'(a)')'    r(...)                          grouping / repetition'
write(io,'(a)')'    :                               format scanning control'
write(io,'(a)')'    S SP SS                         sign control'
write(io,'(a)')'    BN BZ                           blank control (blanks as zeros)'
write(io,'(a)')''
write(io,'(a)')' w full length, m minimum digits, d dec. places, e exponent'
write(io,'(a)')' length, n positions to skip, c positions to move, r repetitions'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'NAME'
write(io,'(a)')'   needs(3f) - rough notes on what is missing from standard Fortran'
write(io,'(a)')'   (LICENSE:PD)'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'A list of what Fortran needs and where to find some of it'
write(io,'(a)')''
write(io,'(a)')'o unsigned integers              - see BITS'
write(io,'(a)')'o POSIX PXF routines or some version of POSIX functions, especially for file system navigation'
write(io,'(a)')'o Stacks, dictionaries and other well-known abstract data types and operations'
write(io,'(a)')'o regular expressions'
write(io,'(a)')'o a standard getopts routine'
write(io,'(a)')'o A standard graphics interface'
write(io,'(a)')'o cumulative round-off error for floating point operations'
write(io,'(a)')'o physical units for variables'
write(io,'(a)')'o arbitrary precision math       - see MPFUN90 and ARPREC'
write(io,'(a)')'o GUI'
write(io,'(a)')'o access to popular C libraries SQLITE3, UUID, HASH FUNCTIONS'
write(io,'(a)')'o socket access'
write(io,'(a)')'o block comments that can easily be exported as documentation, like with ufpp(1) processor'
write(io,'(a)')'o allocate on read -- see readline(3f)'
write(io,'(a)')'o read stream from stdin, write stream to stdout to make filters. Need stream I/O for stdin and stdout so programs &
   &can be used in'
write(io,'(a)')'pipes with binary data.'
write(io,'(a)')'o merge(a,b,c) should be able to take strings of different lengths for a and b'
write(io,'(a)')''
write(io,'(a)')'  TOOLS'
write(io,'(a)')''
write(io,'(a)')'  Test-driven development tools'
write(io,'(a)')'  Automatic Documentation tools'
write(io,'(a)')'  Automatic dependency build tools CMake,'
write(io,'(a)')''
write(io,'(a)')'  FORTRAN HAS'
write(io,'(a)')''
write(io,'(a)')'  MPI, OpenMP, Coarrays'
write(io,'(a)')'     Can this be used for event-driven programming - the flow of control is defined via data instead of code?'
write(io,'(a)')'     A standard thread library and more examples of parallel code'
write(io,'(a)')''
write(io,'(a)')'  netlib repository'
write(io,'(a)')''
write(io,'(a)')'  good vector math syntax'
write(io,'(a)')''
write(io,'(a)')'  COMPLEX'
write(io,'(a)')''
write(io,'(a)')'     should allow NAME%real and NAME%cmplx for complex variables instead of just REAL(NAME) and AIMAG(NAME)'
write(io,'(a)')'NAME'
write(io,'(a)')'   free_source_form(7f) - [FORTRAN] syntax of free source form statements, comments, and continuation lines'
write(io,'(a)')'   (LICENSE:PD)'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'   [label] statement [! comment]'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'  There are two source forms: free and fixed. Fixed-format is generally'
write(io,'(a)')'  considered deprecated but is commonly encountered in older codes,'
write(io,'(a)')'  as all FORTRAN pre-Fortran90 was fixed-form. All new code should be'
write(io,'(a)')'  generated as free-format without some overwhelming reason, such as'
write(io,'(a)')'  the need to use fixed-form INCLUDE files, or where it is required to'
write(io,'(a)')'  be compatible with very old compilers.'
write(io,'(a)')''
write(io,'(a)')'  Free form and fixed form may not be mixed in the same program unit.'
write(io,'(a)')'  The means for specifying the source form of a program unit are'
write(io,'(a)')'  processor dependent. Most commonly, if the file ends if .F or .f it'
write(io,'(a)')'  is assumed to be fixed-form; a suffix of .f90 or .F90 indicates the'
write(io,'(a)')'  file is free-format.'
write(io,'(a)')''
write(io,'(a)')'  In free source form there are no restrictions on where a statement (or'
write(io,'(a)')'  portion of a statement) may appear within a line. A line may contain'
write(io,'(a)')'  zero characters. If a line consists entirely of characters of default'
write(io,'(a)')'  kind, it may contain at most 132 characters. If a line contains any'
write(io,'(a)')'  character that is not of default kind, the maximum number of characters'
write(io,'(a)')'  allowed on the line is processor dependent.'
write(io,'(a)')''
write(io,'(a)')'  BLANK CHARACTERS IN FREE FORM'
write(io,'(a)')''
write(io,'(a)')'  In free source form blank characters shall not appear within'
write(io,'(a)')'  lexical tokens other than in a character context or in a format'
write(io,'(a)')'  specification. Blanks may be inserted freely between tokens to improve'
write(io,'(a)')'  readability; for example, blanks may occur between the tokens that form'
write(io,'(a)')'  a complex literal constant. A sequence of blank characters outside of'
write(io,'(a)')'  a character context is equivalent to a single blank character.'
write(io,'(a)')''
write(io,'(a)')'  A blank shall be used to separate names, constants, or labels from'
write(io,'(a)')'  adjacent keywords, names, constants, or labels. For example, the'
write(io,'(a)')'  blanks after REAL, READ, 30, and DO are required in the following:'
write(io,'(a)')''
write(io,'(a)')'    >   REAL X'
write(io,'(a)')'    >   READ 10'
write(io,'(a)')'    >   30 DO K=1,3'
write(io,'(a)')''
write(io,'(a)')'  One or more blanks shall be used to separate adjacent keywords except'
write(io,'(a)')'  in the following cases, where blanks are optional:'
write(io,'(a)')''
write(io,'(a)')'  Adjacent keywords where separating blanks are optional'
write(io,'(a)')''
write(io,'(a)')'    >   ALL STOP           >   END IF'
write(io,'(a)')'    >   BLOCK DATA         >   END MODULE'
write(io,'(a)')'    >   DOUBLE PRECISION   >   END INTERFACE'
write(io,'(a)')'    >   ELSEIF             >   END PROCEDURE'
write(io,'(a)')'    >   ELSE WHERE         >   END PROGRAM'
write(io,'(a)')'    >   END ASSOCIATE      >   END SELECT'
write(io,'(a)')'    >   END BLOCK          >   END SUBMODULE'
write(io,'(a)')'    >   END BLOCK DATA     >   END SUBROUTINE'
write(io,'(a)')'    >   END CRITICAL       >   END TYPE'
write(io,'(a)')'    >   END DO             >   END WHERE'
write(io,'(a)')'    >   END ENUM           >   GO TO'
write(io,'(a)')'    >   END FILE           >   IN OUT'
write(io,'(a)')'    >   END FORALL         >   SELECT CASE'
write(io,'(a)')'    >   END FUNCTION       >   SELECT TYPE'
write(io,'(a)')''
write(io,'(a)')'  FREE FORM COMMENTARY'
write(io,'(a)')''
write(io,'(a)')'  The character "!" initiates a comment except where it appears within'
write(io,'(a)')'  a character context. The comment'
write(io,'(a)')'  extends to the end of the line. If the first nonblank character on'
write(io,'(a)')'  a line is an "!", the line is a comment line. Lines containing only'
write(io,'(a)')'  blanks or containing no characters are also comment lines. Comments may'
write(io,'(a)')'  appear anywhere in a program unit and may precede the first statement'
write(io,'(a)')'  of a program unit or may follow the last statement of a program'
write(io,'(a)')'  unit. Comments have no effect on the interpretation of the program unit.'
write(io,'(a)')''
write(io,'(a)')'       NOTE 3.6'
write(io,'(a)')'       This part of ISO/IEC 1539 does not restrict the number of'
write(io,'(a)')'       consecutive comment lines.'
write(io,'(a)')''
write(io,'(a)')'  FREE FORM STATEMENT CONTINUATION'
write(io,'(a)')''
write(io,'(a)')'  The character "&" is used to indicate that the current statement is'
write(io,'(a)')'  continued on the next line that is not a'
write(io,'(a)')'  comment line. Comment lines cannot be continued; an "&" in a comment'
write(io,'(a)')'  has no effect. Comments may occur within a continued statement. When'
write(io,'(a)')'  used for continuation, the "&" is not part of the statement. No line'
write(io,'(a)')'  shall contain a single "&" as the only nonblank character or as the'
write(io,'(a)')'  only nonblank character before an "!" that initiates a comment.'
write(io,'(a)')''
write(io,'(a)')'  If a noncharacter context is to be continued, an "&" shall be the last'
write(io,'(a)')'  nonblank character on the line, or the last'
write(io,'(a)')'  nonblank character before an "!". There shall be a later line that is'
write(io,'(a)')'  not a comment; the statement is continued on the next such line. If'
write(io,'(a)')'  the first nonblank character on that line is an "&", the statement'
write(io,'(a)')'  continues at the next character position following that "&"; otherwise,'
write(io,'(a)')'  it continues with the first character position of that line.'
write(io,'(a)')''
write(io,'(a)')'  If a lexical token is split across the end of a line, the first nonblank'
write(io,'(a)')'  character on the first following noncomment'
write(io,'(a)')'  line shall be an "&" immediately followed by the successive characters'
write(io,'(a)')'  of the split token.'
write(io,'(a)')''
write(io,'(a)')'  If a character context is to be continued, an "&" shall be the last'
write(io,'(a)')'  nonblank character on the line and shall not be'
write(io,'(a)')'  followed by commentary. There shall be a later line that is not a'
write(io,'(a)')'  comment; an "&" shall be the first nonblank character on the next such'
write(io,'(a)')'  line and the statement continues with the next character following that'
write(io,'(a)')'  "&".'
write(io,'(a)')''
write(io,'(a)')'  FREE FORM STATEMENT TERMINATION'
write(io,'(a)')''
write(io,'(a)')'  If a statement is not continued, a comment or the end of the line'
write(io,'(a)')'  terminates the statement.'
write(io,'(a)')''
write(io,'(a)')'  A statement may alternatively be terminated by a ";" character that'
write(io,'(a)')'  appears other than in a character context'
write(io,'(a)')'  or in a comment. The ";" is not part of the statement. After a ";"'
write(io,'(a)')'  terminator, another statement may appear on the same line, or begin'
write(io,'(a)')'  on that line and be continued. A sequence consisting only of zero'
write(io,'(a)')'  or more blanks and one or more ";" terminators, in any order, is'
write(io,'(a)')'  equivalent to a single ";" terminator.'
write(io,'(a)')''
write(io,'(a)')'  FREE FORM STATEMENTS'
write(io,'(a)')''
write(io,'(a)')'  A label may precede any statement not forming part of another statement'
write(io,'(a)')'  (Note that no Fortran statement begins with a digit).'
write(io,'(a)')''
write(io,'(a)')'  It is strongly suggested that numeric labels only be used on CONTINUE'
write(io,'(a)')'  statements and for labeling FORMAT statements.'
write(io,'(a)')''
write(io,'(a)')'  A statement shall not have more than 255 continuation lines.'
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_free_source_form'
write(io,'(a)')'   use,intrinsic :: iso_fortran_env, only : ERROR_UNIT, &'
write(io,'(a)')'                                            INPUT_UNIT, &'
write(io,'(a)')'                                            OUTPUT_UNIT ! access computing environment'
write(io,'(a)')'   use iso_fortran_env, only : int8, int32, int64'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   integer,parameter  :: dp=kind(0.0d0)'
write(io,'(a)')'   real(kind=dp),save :: x(10)=0.0_dp'
write(io,'(a)')'   character(len=255) :: filename'
write(io,'(a)')'   logical            :: lval'
write(io,'(a)')'   integer            :: ier'
write(io,'(a)')'   integer            :: i_myloop'
write(io,'(a)')'   integer            :: i, j, k'
write(io,'(a)')'   character(len=*),parameter    :: VERSION=''1.0'''
write(io,'(a)')'   character(len=:), allocatable :: mystring'
write(io,'(a)')'      call usage()'
write(io,'(a)')'      filename=''my file'''
write(io,'(a)')'      print *, "filename=", trim(filename)'
write(io,'(a)')'   !-----------------------------------------------------------------------'
write(io,'(a)')'      MYLOOP: do I_MYLOOP=1,10  ! DO loop'
write(io,'(a)')'         cycle MYLOOP           ! start next pass of loop'
write(io,'(a)')'         exit  MYLOOP           ! go to next statement after corresponding ENDDO'
write(io,'(a)')'      enddo MYLOOP'
write(io,'(a)')'   !-----------------------------------------------------------------------'
write(io,'(a)')'      block'
write(io,'(a)')'         character(len=1) :: c'
write(io,'(a)')'         mystring=trim(filename)'
write(io,'(a)')'         do i=1,len(mystring)'
write(io,'(a)')'            c=mystring(i:i)'
write(io,'(a)')'            select case (c)'
write(io,'(a)')'             CASE (''a'' : ''j'');            WRITE(*,*)c, '' :One of the first ten letters'''
write(io,'(a)')'             CASE (''l'' : ''p'', ''u'' : ''y''); WRITE(*,*)c, '' :One of l, m, n, o, p, u, v, w, x, y'''
write(io,'(a)')'             CASE (''z'', ''q'' : ''t'');       WRITE(*,*)c, '' :One of z, q, r, s, t'''
write(io,'(a)')'             CASE default'
write(io,'(a)')'               WRITE(ERROR_UNIT,*)c, '' :Other characters, which may not be letters'''
write(io,'(a)')'            end select'
write(io,'(a)')'         enddo'
write(io,'(a)')'         write(*,*)signum([10,20,0,-100])'
write(io,'(a)')'         ! mine(3f) is a function that does I/O. Do not use in an I/O statement'
write(io,'(a)')'         x=mine(100.40)'
write(io,'(a)')'      endblock'
write(io,'(a)')'   !-----------------------------------------------------------------------'
write(io,'(a)')'   contains'
write(io,'(a)')'   ! An integer signum function:'
write(io,'(a)')'   elemental integer function signum (n)'
write(io,'(a)')'   integer,intent(in) :: n'
write(io,'(a)')'     select case (n)'
write(io,'(a)')'      case (:-1); signum =    1'
write(io,'(a)')'      case (0);   signum = 0'
write(io,'(a)')'      case (1:);  signum = 1'
write(io,'(a)')'     end select'
write(io,'(a)')'   end function signum'
write(io,'(a)')'   !-------------------------------------------------------------------------------'
write(io,'(a)')'   function mine(xx) result(yy) ! note when RESULT used, function name has no type'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   real :: xx'
write(io,'(a)')'   real :: yy'
write(io,'(a)')'     write(*,*)''VALUE='',xx'
write(io,'(a)')'     yy=xx'
write(io,'(a)')'   end function mine'
write(io,'(a)')'   !-------------------------------------------------------------------------------'
write(io,'(a)')'   subroutine usage()'
write(io,'(a)')'   character(len=80),allocatable :: help_text(:)'
write(io,'(a)')'   integer                       :: i'
write(io,'(a)')'     help_text=[ &'
write(io,'(a)')'     &''12345678901234567890123456789012345678901234567890123456789012345678901234567890'',&'
write(io,'(a)')'     &''This is example help text for the example program                               '',&'
write(io,'(a)')'     &''                                                                                '',&'
write(io,'(a)')'     &''                                                                                '',&'
write(io,'(a)')'     &''                                                                                '']'
write(io,'(a)')'     WRITE(*,''(a)'')(help_text(i),i=1,size(help_text))'
write(io,'(a)')'   end subroutine usage'
write(io,'(a)')'   !-------------------------------------------------------------------------------'
write(io,'(a)')'   end program demo_free_source_form'
write(io,'(a)')'   !-------------------------------------------------------------------------------'
write(io,'(a)')'NAME'
write(io,'(a)')'  DEALLOCATE(7f) - [FORTRAN:STATEMENT] causes allocated variables and targets to be deallocated'
write(io,'(a)')'  (LICENSE:PD)'
write(io,'(a)')''
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'  DEALLOCATE(allocate-object-list [,STAT=stat-variable][,ERRMSG=errmsg-variable] )'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'  The DEALLOCATE statement causes allocatable variables to be deallocated;'
write(io,'(a)')'  it causes pointer targets to be deallocated and the pointers to be'
write(io,'(a)')'  disassociated.'
write(io,'(a)')''
write(io,'(a)')'  An allocate-object shall not depend on the value, bounds, allocation'
write(io,'(a)')'  status, or association status of another allocate-object in the same'
write(io,'(a)')'  DEALLOCATE statement; it also shall not depend on the value of the'
write(io,'(a)')'  stat-variable or errmsg-variable in the same DEALLOCATE statement.'
write(io,'(a)')''
write(io,'(a)')'  The status of objects that were not successfully allocated or'
write(io,'(a)')'  deallocated can be individually checked with the intrinsic functions'
write(io,'(a)')'  ALLOCATED or ASSOCIATED.'
write(io,'(a)')''
write(io,'(a)')'OPTIONS'
write(io,'(a)')''
write(io,'(a)')'    allocated-object-list    Each allocate-object is a nonprocedure'
write(io,'(a)')'                             pointer or an allocatable variable.'
write(io,'(a)')''
write(io,'(a)')'    STAT=stat-variable       If the STAT= specifier appears, successful'
write(io,'(a)')'                             execution of the ALLOCATE or DEALLOCATE'
write(io,'(a)')'                             statement causes the stat-variable'
write(io,'(a)')'                             to become defined with a value of zero.'
write(io,'(a)')''
write(io,'(a)')'                             If an error condition occurs during'
write(io,'(a)')'                             execution of a DEALLOCATE statement that'
write(io,'(a)')'                             does not contain the STAT= specifier, error'
write(io,'(a)')'                             termination is initiated.'
write(io,'(a)')''
write(io,'(a)')'    ERRMSG=errmsg-variable   If an error condition occurs during execution'
write(io,'(a)')'                             of an ALLOCATE or DEALLOCATE statement, the'
write(io,'(a)')'                             processor assigns an explanatory message to'
write(io,'(a)')'                             errmsg-variable. If no such condition occurs,'
write(io,'(a)')'                             the processor does not change the value of'
write(io,'(a)')'                             the errmsg-variable.'
write(io,'(a)')''
write(io,'(a)')'   No dealloc-opt shall appear more than once in a given DEALLOCATE statement'
write(io,'(a)')''
write(io,'(a)')'   The errmsg-variable and stat-variable cannot be allocated or'
write(io,'(a)')'   deallocated elsewhere in the statement or otherwise depend of any'
write(io,'(a)')'   allocatable object in the statement.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'   An example of a DEALLOCATE statement is:'
write(io,'(a)')''
write(io,'(a)')'         DEALLOCATE (X, B)'
write(io,'(a)')''
write(io,'(a)')'DEALLOCATION OF ALLOCATABLE VARIABLES'
write(io,'(a)')''
write(io,'(a)')'   Deallocating an unallocated allocatable variable causes an error'
write(io,'(a)')'   condition in the DEALLOCATE statement. Deallocating an allocatable'
write(io,'(a)')'   variable with the TARGET attribute causes the pointer association'
write(io,'(a)')'   status of any pointer associated with it to become undefined.'
write(io,'(a)')''
write(io,'(a)')'   When the execution of a procedure is terminated by execution of a'
write(io,'(a)')'   RETURN or END statement, an unsaved allocatable local variable of'
write(io,'(a)')'   the procedure retains its allocation and definition status if it'
write(io,'(a)')'   is a function result variable or a subobject thereof; otherwise,'
write(io,'(a)')'   it is deallocated.'
write(io,'(a)')''
write(io,'(a)')'   When a BLOCK construct terminates, an unsaved allocatable local'
write(io,'(a)')'   variable of the construct is deallocated.'
write(io,'(a)')''
write(io,'(a)')'   If an executable construct references a function whose result is either'
write(io,'(a)')'   allocatable or a structure with a subobject that is allocatable,'
write(io,'(a)')'   and the function reference is executed, an allocatable result and'
write(io,'(a)')'   any subobject that is an allocated allocatable entity in the result'
write(io,'(a)')'   returned by the function is deallocated after execution of the'
write(io,'(a)')'   innermost executable construct containing the reference.'
write(io,'(a)')''
write(io,'(a)')'   If a function whose result is either allocatable or a structure with'
write(io,'(a)')'   an allocatable subobject is referenced in the specification part'
write(io,'(a)')'   of a scoping unit or BLOCK construct, and the function reference'
write(io,'(a)')'   is executed, an allocatable result and any subobject that is an'
write(io,'(a)')'   allocated allocatable entity in the result returned by the function'
write(io,'(a)')'   is deallocated before execution of the executable constructs of the'
write(io,'(a)')'   scoping unit or block.'
write(io,'(a)')''
write(io,'(a)')'   When a procedure is invoked, any allocated allocatable object that'
write(io,'(a)')'   is an actual argument corresponding to an INTENT (OUT) allocatable'
write(io,'(a)')'   dummy argument is deallocated; any allocated allocatable object that'
write(io,'(a)')'   is a subobject of an actual argument corresponding to an INTENT (OUT)'
write(io,'(a)')'   dummy argument is deallocated.'
write(io,'(a)')''
write(io,'(a)')'   When an intrinsic assignment statement (7.2.1.3) is executed,'
write(io,'(a)')'   any noncoarray allocated allocatable subobject of the variable is'
write(io,'(a)')'   deallocated before the assignment takes place.'
write(io,'(a)')''
write(io,'(a)')'   When a variable of derived type is deallocated, any allocated'
write(io,'(a)')'   allocatable subobject is deallocated.'
write(io,'(a)')''
write(io,'(a)')'   If an allocatable component is a subobject of a finalizable object,'
write(io,'(a)')'   that object is finalized before the component is automatically'
write(io,'(a)')'   deallocated.'
write(io,'(a)')''
write(io,'(a)')'   The effect of automatic deallocation is the same as that of a'
write(io,'(a)')'   DEALLOCATE statement without a dealloc-opt-list.'
write(io,'(a)')''
write(io,'(a)')'   There is implicit synchronization of all images in association with'
write(io,'(a)')'   each DEALLOCATE statement that deallocates one or more coarrays. On'
write(io,'(a)')'   each image, execution of the segment (8.5.1) following the statement'
write(io,'(a)')'   is delayed until all other images have executed the same statement'
write(io,'(a)')'   the same number of times. If the coarray is a dummy argument, its'
write(io,'(a)')'   ultimate argument (12.5.2.3) shall be the same coarray on every image.'
write(io,'(a)')''
write(io,'(a)')'   There is also an implicit synchronization of all images in association'
write(io,'(a)')'   with the deallocation of a coarray or coarray subcomponent caused by'
write(io,'(a)')'   the execution of a RETURN or END statement or the termination of a'
write(io,'(a)')'   BLOCK construct.'
write(io,'(a)')''
write(io,'(a)')'    In the following example:'
write(io,'(a)')''
write(io,'(a)')'       > SUBROUTINE PROCESS'
write(io,'(a)')'       >   REAL, ALLOCATABLE :: TEMP(:)'
write(io,'(a)')'       >'
write(io,'(a)')'       >   REAL, ALLOCATABLE, SAVE :: X(:)'
write(io,'(a)')'       >   ...'
write(io,'(a)')'       > END SUBROUTINE PROCESS'
write(io,'(a)')''
write(io,'(a)')'    on return from subroutine PROCESS, the allocation status of X is'
write(io,'(a)')'    preserved because X has the SAVE attribute. TEMP does not have the'
write(io,'(a)')'    SAVE attribute, so it will be deallocated if it was allocated. On'
write(io,'(a)')'    the next invocation of PROCESS, TEMP will have an allocation status'
write(io,'(a)')'    of unallocated.'
write(io,'(a)')''
write(io,'(a)')'DEALLOCATION OF POINTER TARGETS'
write(io,'(a)')''
write(io,'(a)')'   If a pointer appears in a DEALLOCATE statement, its association status'
write(io,'(a)')'   shall be defined. Deallocating a pointer'
write(io,'(a)')'    that is disassociated or whose target was not created by an ALLOCATE'
write(io,'(a)')'    statement causes an error condition in the DEALLOCATE statement. If a'
write(io,'(a)')'    pointer is associated with an allocatable entity, the pointer shall'
write(io,'(a)')'    not be deallocated.'
write(io,'(a)')''
write(io,'(a)')'   If a pointer appears in a DEALLOCATE statement, it shall be associated'
write(io,'(a)')'   with the whole of an object that was'
write(io,'(a)')'    created by allocation. Deallocating a pointer target causes the'
write(io,'(a)')'    pointer association status of any other pointer that is associated'
write(io,'(a)')'    with the target or a portion of the target to become undefined.'
write(io,'(a)')''
write(io,'(a)')'   If an ALLOCATE or DEALLOCATE statement with a coarray'
write(io,'(a)')'   allocate-object is executed when one or more images has initiated'
write(io,'(a)')'   termination of execution, the stat-variable becomes defined with the'
write(io,'(a)')'   processor-dependent positive integer value of the constant STAT STOPPED'
write(io,'(a)')'   IMAGE from the intrinsic module ISO_FORTRAN_ENV (13.8.2). If any other'
write(io,'(a)')'   error condition occurs during execution of the ALLOCATE or DEALLOCATE'
write(io,'(a)')'   statement, the stat-variable becomes defined with a processor-dependent'
write(io,'(a)')'   positive integer value different from STAT STOPPED IMAGE. In either'
write(io,'(a)')'   case, each allocate-object has a processor-dependent status:'
write(io,'(a)')''
write(io,'(a)')'       * each allocate-object that was successfully allocated shall have'
write(io,'(a)')'         an allocation status of allocated or a pointer association'
write(io,'(a)')'         status of associated;'
write(io,'(a)')'       * each allocate-object that was successfully deallocated shall'
write(io,'(a)')'         have an allocation status of unallocated or a pointer association'
write(io,'(a)')'         status of disassociated;'
write(io,'(a)')'       * each allocate-object that was not successfully allocated or'
write(io,'(a)')'         deallocated shall retain its previous allocation status or'
write(io,'(a)')'         pointer association status.'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'    pointers(7f) - [FORTRAN] Pointers and targets methods'
write(io,'(a)')'    (LICENSE:PD)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   In Fortran, the concept of pointers differs from that in C-like'
write(io,'(a)')'   languages. A Fortran 90 pointer does not merely store the memory address'
write(io,'(a)')'   of a target variable; it also contains additional descriptive information'
write(io,'(a)')'   such as the target''s rank, the upper and lower bounds of each dimension,'
write(io,'(a)')'   and even strides through memory. This allows a Fortran 90 pointer to'
write(io,'(a)')'   point at submatrices.'
write(io,'(a)')''
write(io,'(a)')'   Fortran 90 pointers are "associated" with well-defined "target"'
write(io,'(a)')'   variables, via either the pointer assignment operator (=>) or an'
write(io,'(a)')'   ALLOCATE statement. When appearing in expressions, pointers are always'
write(io,'(a)')'   dereferenced; no "pointer arithmetic" is possible.'
write(io,'(a)')'EXAMPLES'
write(io,'(a)')''
write(io,'(a)')'  The following example illustrates the concept:'
write(io,'(a)')''
write(io,'(a)')'   module SomeModule'
write(io,'(a)')'      implicit none'
write(io,'(a)')'    contains'
write(io,'(a)')'       elemental function A(x) result(res)'
write(io,'(a)')'           integer :: res'
write(io,'(a)')'           integer, intent(IN) :: x'
write(io,'(a)')'           res = x + 1'
write(io,'(a)')'       end function'
write(io,'(a)')'   end module SomeModule'
write(io,'(a)')''
write(io,'(a)')'   program demo_pointers'
write(io,'(a)')'      use SomeModule, DoSomething => A'
write(io,'(a)')'      implicit none'
write(io,'(a)')''
write(io,'(a)')'      !Declare variables'
write(io,'(a)')'      integer, parameter :: m = 3, n = 3'
write(io,'(a)')'      integer, pointer :: p(:)=>null(), q(:,:)=>null()'
write(io,'(a)')'      integer, allocatable, target :: A(:,:)'
write(io,'(a)')'      integer :: istat = 0, i, j'
write(io,'(a)')'      character(80) :: fmt'
write(io,'(a)')''
write(io,'(a)')'   !  Write format string for matrices'
write(io,'(a)')'   !  (/ A / A, " = [", 3( "[",3(i2, 1x), "]" / 5x), "]" )'
write(io,'(a)')'      write (fmt, ''("(/ A / A, "" = ["", ", i0, "( ""["",", i0, "(i2, 1x), ""]"" / 5x), ""]"" )")'') m, n'
write(io,'(a)')''
write(io,'(a)')'      allocate(A(m, n), q(m, n), stat = istat)'
write(io,'(a)')'      if (istat /= 0) stop ''Error during allocation of A and q'''
write(io,'(a)')''
write(io,'(a)')'   !  Matrix A is:'
write(io,'(a)')'   !  A = [[ 1  4  7 ]'
write(io,'(a)')'   !       [ 2  5  8 ]'
write(io,'(a)')'   !       [ 3  6  9 ]'
write(io,'(a)')'   !       ]'
write(io,'(a)')'      A = reshape([(i, i = 1, size(A))], shape(A))'
write(io,'(a)')'      q = A'
write(io,'(a)')''
write(io,'(a)')'      write(*, fmt) "Matrix A is:", "A", ((A(i, j), j = 1, size(A, 2)), i = 1, size(A, 1))'
write(io,'(a)')''
write(io,'(a)')'   !  p will be associated with the first column of A'
write(io,'(a)')'      p => A(:, 1)'
write(io,'(a)')''
write(io,'(a)')'   !  This operation on p has a direct effect on matrix A'
write(io,'(a)')'      p = p ** 2'
write(io,'(a)')''
write(io,'(a)')'   !  This will end the association between p and the first column of A'
write(io,'(a)')'      nullify(p)'
write(io,'(a)')''
write(io,'(a)')'   !  Matrix A becomes:'
write(io,'(a)')'   !  A = [[ 1  4  7 ]'
write(io,'(a)')'   !       [ 4  5  8 ]'
write(io,'(a)')'   !       [ 9  6  9 ]'
write(io,'(a)')'   !       ]'
write(io,'(a)')'      write(*, fmt) "Matrix A becomes:", "A", ((A(i, j), j = 1, size(A, 2)), i = 1, size(A, 1))'
write(io,'(a)')''
write(io,'(a)')'   !  Perform some array operation'
write(io,'(a)')'      q = q + A'
write(io,'(a)')''
write(io,'(a)')'   !  Matrix q becomes:'
write(io,'(a)')'   !  q = [[ 2  8 14 ]'
write(io,'(a)')'   !       [ 6 10 16 ]'
write(io,'(a)')'   !       [12 12 18 ]'
write(io,'(a)')'   !       ]'
write(io,'(a)')'      write(*, fmt) "Matrix q becomes:", "q", ((q(i, j), j = 1, size(A, 2)), i = 1, size(A, 1))'
write(io,'(a)')''
write(io,'(a)')'   !  Use p as an ordinary array'
write(io,'(a)')'      allocate (p(1:m*n), stat = istat)'
write(io,'(a)')'      if (istat /= 0) stop ''Error during allocation of p'''
write(io,'(a)')''
write(io,'(a)')'   !  Perform some array operation'
write(io,'(a)')'      p = reshape(DoSomething(A + A ** 2), shape(p))'
write(io,'(a)')''
write(io,'(a)')'   !  Array operation:'
write(io,'(a)')'   !      p(1) = 3'
write(io,'(a)')'   !      p(2) = 21'
write(io,'(a)')'   !      p(3) = 91'
write(io,'(a)')'   !      p(4) = 21'
write(io,'(a)')'   !      p(5) = 31'
write(io,'(a)')'   !      p(6) = 43'
write(io,'(a)')'   !      p(7) = 57'
write(io,'(a)')'   !      p(8) = 73'
write(io,'(a)')'   !      p(9) = 91'
write(io,'(a)')'      write(*, ''("Array operation:" / (4x,"p(",i0,") = ",i0))'') (i, p(i), i = 1, size(p))'
write(io,'(a)')''
write(io,'(a)')'      deallocate(A, p, q, stat = istat)'
write(io,'(a)')'      if (istat /= 0) stop ''Error during deallocation'''
write(io,'(a)')''
write(io,'(a)')'   end program demo_pointers'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   return(7f) - [FORTRAN:STATEMENT] completes execution of the instance of the subprogram in which it appears'
write(io,'(a)')'   (LICENSE:PD)'
write(io,'(a)')''
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'   RETURN [scalar-int-expr]'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   Execution of the RETURN statement completes execution of the instance'
write(io,'(a)')'   of the subprogram in which it appears.'
write(io,'(a)')''
write(io,'(a)')'   The return-stmt shall be in the scoping unit of a function or'
write(io,'(a)')'   subroutine subprogram.'
write(io,'(a)')''
write(io,'(a)')'   Execution of an end-function-stmt, end-mp-subprogram-stmt, or'
write(io,'(a)')'   end-subroutine-stmt is equivalent to execution of a RETURN statement'
write(io,'(a)')'   with no expression.'
write(io,'(a)')''
write(io,'(a)')'OPTIONS'
write(io,'(a)')'   scalar-int-expr  If the expression appears and has a value n between'
write(io,'(a)')'                    1 and the number of asterisks in the dummy argument'
write(io,'(a)')'                    list, the CALL statement that invoked the subroutine'
write(io,'(a)')'                    transfers control to the statement identified by'
write(io,'(a)')'                    the nth alternate return specifier in the actual'
write(io,'(a)')'                    argument list of the referenced procedure. If the'
write(io,'(a)')'                    expression is omitted or has a value outside the'
write(io,'(a)')'                    required range, there is no transfer of control to'
write(io,'(a)')'                    an alternate return.'
write(io,'(a)')''
write(io,'(a)')'                    The scalar-int-expr is allowed only in the scoping'
write(io,'(a)')'                    unit of a subroutine subprogram.'
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  Sample program'
write(io,'(a)')''
write(io,'(a)')'   program demo_return'
write(io,'(a)')'      call tryreturn(1)'
write(io,'(a)')'      call tryreturn(10)'
write(io,'(a)')'   contains'
write(io,'(a)')'      subroutine tryreturn(i)'
write(io,'(a)')'         integer,intent(in) :: i'
write(io,'(a)')'         select case(i)'
write(io,'(a)')'          case(1)'
write(io,'(a)')'            write(*,*)''*one*'''
write(io,'(a)')'            return'
write(io,'(a)')'          case(2)'
write(io,'(a)')'            write(*,*)''*two*'''
write(io,'(a)')'            return'
write(io,'(a)')'          case default'
write(io,'(a)')'            write(*,*)''*default*'''
write(io,'(a)')'            return'
write(io,'(a)')'         end select'
write(io,'(a)')'         write(*,*)''*cannot get here*'''
write(io,'(a)')'         return'
write(io,'(a)')'      end subroutine tryreturn'
write(io,'(a)')'   end program demo_return'
write(io,'(a)')''
write(io,'(a)')'  Results:'
write(io,'(a)')''
write(io,'(a)')'    *one*'
write(io,'(a)')'    *default*'
write(io,'(a)')''
write(io,'(a)')'  Sample program using alternate returns. Alternate returns are'
write(io,'(a)')'  an obsolescent feature.'
write(io,'(a)')''
write(io,'(a)')'   program alt_return'
write(io,'(a)')'   implicit none'
write(io,'(a)')'      call one(2,*10,*20,*30)'
write(io,'(a)')'      write(*,*)''did not select alternate return'''
write(io,'(a)')'      goto 999'
write(io,'(a)')'   10 continue'
write(io,'(a)')'      write(*,*)''picked first alternate return'''
write(io,'(a)')'      goto 999'
write(io,'(a)')'   20 continue'
write(io,'(a)')'      write(*,*)''picked second alternate return'''
write(io,'(a)')'      goto 999'
write(io,'(a)')'   30 continue'
write(io,'(a)')'      write(*,*)''picked third alternate return'''
write(io,'(a)')'      goto 999'
write(io,'(a)')'   999 continue'
write(io,'(a)')'   end program alt_return'
write(io,'(a)')'   subroutine one(ipick,*,*,*)'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   integer :: ipick'
write(io,'(a)')'      select case(ipick)'
write(io,'(a)')'       case(1)'
write(io,'(a)')'         write(*,*)''first alternate return selected'''
write(io,'(a)')'         return 1'
write(io,'(a)')'       case(2)'
write(io,'(a)')'         write(*,*)''second alternate return selected'''
write(io,'(a)')'         return 2'
write(io,'(a)')'       case(3)'
write(io,'(a)')'         write(*,*)''third alternate return selected'''
write(io,'(a)')'         return 3'
write(io,'(a)')'      end select'
write(io,'(a)')'      write(*,*)''no alternate return selected'''
write(io,'(a)')'   end subroutine one'
write(io,'(a)')''
write(io,'(a)')'  Results:'
write(io,'(a)')''
write(io,'(a)')'    second alternate return selected'
write(io,'(a)')'    picked second alternate return'
write(io,'(a)')'NAME'
write(io,'(a)')'     select_type(7f) - [FORTRAN:EXECUTION_CONTROL] select_type'
write(io,'(a)')'     (LICENSE:PD)'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'     select_type(VARIABLE)'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'Sample program'
write(io,'(a)')''
write(io,'(a)')'   program select_type'
write(io,'(a)')''
write(io,'(a)')'   type :: point'
write(io,'(a)')'      real :: x, y'
write(io,'(a)')'   end type point'
write(io,'(a)')''
write(io,'(a)')'   type, extends(point) :: point_3d'
write(io,'(a)')'      real :: z'
write(io,'(a)')'   end type point_3d'
write(io,'(a)')''
write(io,'(a)')'   type, extends(point) :: color_point'
write(io,'(a)')'      integer :: color'
write(io,'(a)')'   end type color_point'
write(io,'(a)')''
write(io,'(a)')'   type(point), target :: p'
write(io,'(a)')'   type(point_3d), target :: p3'
write(io,'(a)')'   type(color_point), target :: c'
write(io,'(a)')''
write(io,'(a)')'   class(point), pointer :: p_or_c_or_p3'
write(io,'(a)')''
write(io,'(a)')'   do i=1,3'
write(io,'(a)')''
write(io,'(a)')'      select case(i)'
write(io,'(a)')'      case(1);p_or_c_or_p3 => c'
write(io,'(a)')'      case(2);p_or_c_or_p3 => p'
write(io,'(a)')'      case(3);p_or_c_or_p3 => p3'
write(io,'(a)')'      end select'
write(io,'(a)')''
write(io,'(a)')'      select type ( a => p_or_c_or_p3 )'
write(io,'(a)')'         class is ( point )  ! any type of the class without a specific "TYPE IS"'
write(io,'(a)')'              ! "CLASS ( POINT ) :: A" implied here'
write(io,'(a)')'              print *, ''CLASS POINT '',A%X, A%Y ! This block gets executed'
write(io,'(a)')'         type is ( point )'
write(io,'(a)')'                      print *, ''POINT '', A%X, A%Y'
write(io,'(a)')'         type is ( point_3d )'
write(io,'(a)')'              ! "type ( POINT_3D ) :: A" implied here'
write(io,'(a)')'                      print *, ''POINT_3D '',A%X, A%Y, A%Z'
write(io,'(a)')'      end select'
write(io,'(a)')''
write(io,'(a)')'   enddo'
write(io,'(a)')''
write(io,'(a)')'   end program select_type'
write(io,'(a)')'   ! Output'
write(io,'(a)')'   !'
write(io,'(a)')'   !  CLASS POINT    3.54248252E-40   8.40779079E-45'
write(io,'(a)')'   !  POINT    0.00000000       0.00000000'
write(io,'(a)')'   !  POINT_3D    0.00000000       3.53541997E-40   8.40779079E-45'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'EXAMPLES SECTION'
write(io,'(a)')''
write(io,'(a)')' XXXXXXX XXX XXX   XX    XX   XX XXXXXX  XXXXX   XXXXXXX  XXXXX'
write(io,'(a)')'  X    X  X   X     X     X   X   X    X   X      X    X X     X'
write(io,'(a)')'  X        X X      X     XX XX   X    X   X      X      X'
write(io,'(a)')'  X  X     X X     X X    XX XX   X    X   X      X  X   X'
write(io,'(a)')'  XXXX      X      X X    X X X   XXXXX    X      XXXX    XXXXX'
write(io,'(a)')'  X  X     X X    X   X   X X X   X        X      X  X         X'
write(io,'(a)')'  X        X X    XXXXX   X   X   X        X      X            X'
write(io,'(a)')'  X    X  X   X   X   X   X   X   X        X   X  X    X X     X'
write(io,'(a)')' XXXXXXX XXX XXX XXX XXX XXX XXX XXXX    XXXXXXX XXXXXXX  XXXXX'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'Array_Constructors(7f) - [FORTRAN] An array constructor can be used to create and assign values to rank-one arrays &
   &(and array constants)'
write(io,'(a)')'(LICENSE:PD)'
write(io,'(a)')'SYNTAX'
write(io,'(a)')'An array constructor takes the following form:'
write(io,'(a)')''
write(io,'(a)')'   (/ac-value-list/)'
write(io,'(a)')'   [ac-value-list]'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'OPTIONS'
write(io,'(a)')''
write(io,'(a)')'ac-value-list  Is a list of one or more expressions or implied-DO loops. Each ac-value'
write(io,'(a)')'               must have the same type and kind parameters, and be separated by commas.'
write(io,'(a)')''
write(io,'(a)')'implied-do     An implied-DO loop in an array constructor takes the following form:'
write(io,'(a)')''
write(io,'(a)')'                (ac-value-list, do-variable = expr1, expr2 [,expr3])'
write(io,'(a)')''
write(io,'(a)')'do-variable    Is the name of a scalar integer variable. Its scope is that of the implied-DO loop.'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'expr           Is a scalar integer expression. The expr1 and expr2 specify a range of'
write(io,'(a)')'               values for the loop; expr3 specifies the stride. The expr3 must be a'
write(io,'(a)')'               nonzero value; if it is omitted, it is assumed to be 1.'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'Description'
write(io,'(a)')''
write(io,'(a)')'The array constructed has the same type as the ac-value-list expressions.'
write(io,'(a)')''
write(io,'(a)')'If the sequence of values specified by the array constructor is empty'
write(io,'(a)')'(an empty array expression or the implied-DO loop produces no values),'
write(io,'(a)')'the rank-one array has a size of zero.'
write(io,'(a)')''
write(io,'(a)')'An ac-value is interpreted as follows:'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'Form of ac-value     Result'
write(io,'(a)')''
write(io,'(a)')'A scalar expression  Its value is an element of the new array.'
write(io,'(a)')'An array expression  The values of the elements in the expression (in'
write(io,'(a)')'                     array element order) are the corresponding sequence of elements in the'
write(io,'(a)')'                     new array.'
write(io,'(a)')'An implied-DO loop   It is expanded to form a list of array elements'
write(io,'(a)')'                     under control of the DO variable (like a DO construct).'
write(io,'(a)')''
write(io,'(a)')'The following shows the three forms of an ac-value:'
write(io,'(a)')''
write(io,'(a)')'  C1 = (/4,8,7,6/)                  ! A scalar expression'
write(io,'(a)')'  C2 = (/B(I, 1:5), B(I:J, 7:9)/)   ! An array expression'
write(io,'(a)')'  C3 = (/(I, I=1, 4)/)              ! An implied-DO loop'
write(io,'(a)')''
write(io,'(a)')'You can also mix these forms, for example:'
write(io,'(a)')''
write(io,'(a)')'  C4 = (/4, A(1:5), (I, I=1, 4), 7/)'
write(io,'(a)')''
write(io,'(a)')'If every expression in an array constructor is a constant expression,'
write(io,'(a)')'the array constructor is a constant expression.'
write(io,'(a)')''
write(io,'(a)')'If the expressions are of type character, Fortran 95/90 requires each'
write(io,'(a)')'expression to have the same character length.'
write(io,'(a)')''
write(io,'(a)')'However, Intel Fortran allows the character expressions to be of different'
write(io,'(a)')'character lengths. The length of the resultant character array is the'
write(io,'(a)')'maximum of the lengths of the individual character expressions. For'
write(io,'(a)')'example:'
write(io,'(a)')''
write(io,'(a)')'   print *,len ( (/''a'',''ab'',''abc'',''d''/) )'
write(io,'(a)')'   print *,''++''//(/''a'',''ab'',''abc'',''d''/)//''--'''
write(io,'(a)')''
write(io,'(a)')'This causes the following to be displayed:'
write(io,'(a)')''
write(io,'(a)')'           3'
write(io,'(a)')' ++a  --++ab --++abc--++d  --'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'If an implied-DO loop is contained within another implied-DO loop'
write(io,'(a)')'(nested), they cannot have the same DO variable (do-variable).'
write(io,'(a)')''
write(io,'(a)')'To define arrays of more than one dimension, use the RESHAPE intrinsic'
write(io,'(a)')'function.'
write(io,'(a)')''
write(io,'(a)')'The following are alternative forms for array constructors:'
write(io,'(a)')''
write(io,'(a)')'Square brackets (instead of parentheses and slashes) to enclose'
write(io,'(a)')'array constructors; for example, the following two array constructors'
write(io,'(a)')'are equivalent:'
write(io,'(a)')''
write(io,'(a)')'  INTEGER C(4)'
write(io,'(a)')'  C = (/4,8,7,6/)'
write(io,'(a)')'  C = [4,8,7,6]'
write(io,'(a)')''
write(io,'(a)')'EXAMPLES'
write(io,'(a)')''
write(io,'(a)')'The following example shows an array constructor using an implied-DO loop:'
write(io,'(a)')''
write(io,'(a)')'  INTEGER ARRAY_C(10)'
write(io,'(a)')'  ARRAY_C = (/(I, I=30, 48, 2)/)'
write(io,'(a)')''
write(io,'(a)')'The values of ARRAY_C are the even numbers 30 through 48.'
write(io,'(a)')''
write(io,'(a)')'Implied-DO expressions and values can be mixed in the value list of an'
write(io,'(a)')'array constructor. For example:'
write(io,'(a)')''
write(io,'(a)')' INTEGER A(10)'
write(io,'(a)')' A = (/1, 0, (I, I = -1, -6, -1), -7, -8 /)'
write(io,'(a)')' !Mixed values and implied-DO in value list.'
write(io,'(a)')''
write(io,'(a)')'This example sets the elements of A to the values, in order,'
write(io,'(a)')''
write(io,'(a)')'   1, 0, -1, -2, -3, -4, -5, -6, -7, -8.'
write(io,'(a)')''
write(io,'(a)')'The following example shows an array constructor of derived type that'
write(io,'(a)')'uses a structure constructor:'
write(io,'(a)')''
write(io,'(a)')'   TYPE EMPLOYEE'
write(io,'(a)')'     INTEGER ID'
write(io,'(a)')'     CHARACTER(LEN=30) NAME'
write(io,'(a)')'   END TYPE EMPLOYEE'
write(io,'(a)')''
write(io,'(a)')'   TYPE(EMPLOYEE) CC_4T(4)'
write(io,'(a)')'   CC_4T = (/EMPLOYEE(2732,"JONES"), EMPLOYEE(0217,"LEE"),     &'
write(io,'(a)')'             EMPLOYEE(1889,"RYAN"), EMPLOYEE(4339,"EMERSON")/)'
write(io,'(a)')''
write(io,'(a)')'The following example shows how the RESHAPE intrinsic function can be'
write(io,'(a)')'used to create a multidimensional array:'
write(io,'(a)')''
write(io,'(a)')'  E = (/2.3, 4.7, 6.6/)'
write(io,'(a)')'  D = RESHAPE(SOURCE = (/3.5, (/2.0, 1.0/), E/), SHAPE = (/2,3/))'
write(io,'(a)')''
write(io,'(a)')'D is a rank-two array with shape (2,3) containing the following elements:'
write(io,'(a)')''
write(io,'(a)')'   3.5    1.0    4.7'
write(io,'(a)')'   2.0    2.3    6.6'
write(io,'(a)')''
write(io,'(a)')'The following shows another example:'
write(io,'(a)')''
write(io,'(a)')' INTEGER B(2,3), C(8)'
write(io,'(a)')' ! Assign values to a (2,3) array.'
write(io,'(a)')' B = RESHAPE((/1, 2, 3, 4, 5, 6/),(/2,3/))'
write(io,'(a)')' ! Convert B to a vector before assigning values to'
write(io,'(a)')' ! vector C.'
write(io,'(a)')' C = (/ 0, RESHAPE(B,(/6/)), 7 /)'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'Example using general purpose fortran routines'
write(io,'(a)')''
write(io,'(a)')'   program demo_array_constructors ! initializing small arrays'
write(io,'(a)')'   use M_display, only : disp, disp_set'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   integer :: i'
write(io,'(a)')'   integer, parameter :: yy(*) = [  10,20,30  ,  40,50,60  ] ! make some data in a vector, could type this where yy&
   & appears below'
write(io,'(a)')'   ! xx is same thing as yy, just using syntax for filling it that makes it clearer what I want to do with the data'
write(io,'(a)')'   integer, parameter :: xx(*) = [ [10,20,30] , [40,50,60] ] ! make some data in a vector, could type this where xx&
   & appears below'
write(io,'(a)')''
write(io,'(a)')'   integer, dimension(2,3)::aa = reshape(xx,shape(aa),order=[2,1])      ! 2d by rows using reshaped scalar expressi&
   &on'
write(io,'(a)')'   integer, dimension(2,3)::bb = reshape(xx,shape(bb)             )     ! 2d by columns'
write(io,'(a)')'   integer, dimension(2,3)::cc = reshape(xx,shape(cc),order=[1,2])      ! 2d by columns'
write(io,'(a)')'   integer, dimension(2,3)::dd = reshape([(i*10,i=1,size(dd))],shape(dd)) ! an implied do by columns'
write(io,'(a)')''
write(io,'(a)')'   integer, dimension(2,3):: ff, gg, hh'
write(io,'(a)')'   ! CANNOT DO'
write(io,'(a)')'   !integer, dimension(2,3)::ff = [10,20,30,40,50,60 ]                                     ! 2d by columns'
write(io,'(a)')'   ! BUT CAN DO'
write(io,'(a)')'   data ff/10,20,30,40,50,60/  ! fill 2D with simple data statement'
write(io,'(a)')'   ! AND CAN DO'
write(io,'(a)')'   ! multi-dimensional by equivalence'
write(io,'(a)')'   integer                :: ee(2,3)'
write(io,'(a)')'   integer                :: e(size(ee))=xx'
write(io,'(a)')'   equivalence               (e(1),ee(1,1))'
write(io,'(a)')'   ! CANNOT DO'
write(io,'(a)')'   !integer, dimension(2,3)::gg = [10,20,30] , [40,50,60]'
write(io,'(a)')'   !integer, dimension(2,3)::gg = [[10,20,30] , [40,50,60]]'
write(io,'(a)')'   ! BUT CAN DO'
write(io,'(a)')'   data gg(1,:)/ 10, 20, 30 /     ! fill rows with data statements'
write(io,'(a)')'   data gg(2,:)/ 40, 50, 60 /'
write(io,'(a)')''
write(io,'(a)')'   data hh(:,1)/ 10, 40 /         ! fill columns with data statements'
write(io,'(a)')'   data hh(:,2)/ 20, 50 /'
write(io,'(a)')'   data hh(:,3)/ 30, 60 /'
write(io,'(a)')'      call disp_set(style=''left & number'')'
write(io,'(a)')''
write(io,'(a)')'      write(*,*)''SIZE(aa)='',size(aa)'
write(io,'(a)')'      write(*,*)''SHAPE(aa)='',shape(aa)'
write(io,'(a)')'      write(*,*)''xx='',xx'
write(io,'(a)')'      write(*,*)''yy='',yy'
write(io,'(a)')''
write(io,'(a)')'      call disp(''aa='',aa)'
write(io,'(a)')'      call disp(''bb='',bb)'
write(io,'(a)')'      call disp(''cc='',cc)'
write(io,'(a)')'      call disp(''dd='',dd)'
write(io,'(a)')''
write(io,'(a)')'      call disp(''ee='',ee)'
write(io,'(a)')''
write(io,'(a)')'      call disp(''ff='',ff)'
write(io,'(a)')'      call disp(''gg='',gg)'
write(io,'(a)')'      call disp(''hh='',hh)'
write(io,'(a)')''
write(io,'(a)')'      write(*,*)repeat(''='',80)'
write(io,'(a)')'      write(*,*)hh'
write(io,'(a)')'      write(*,*)repeat(''='',80)'
write(io,'(a)')'      call print_buildfmt(hh)'
write(io,'(a)')'      write(*,*)repeat(''='',80)'
write(io,'(a)')'      call print_fixedfmt(hh)'
write(io,'(a)')''
write(io,'(a)')'   contains'
write(io,'(a)')''
write(io,'(a)')'   subroutine print_buildfmt(arr)'
write(io,'(a)')'   use M_strings, only : v2s'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   integer,intent(in) :: arr(:,:)'
write(io,'(a)')'   integer :: i'
write(io,'(a)')'   character(len=:),allocatable :: fmt'
write(io,'(a)')'      fmt=''("> [",''//v2s(size(arr,dim=2))//''(i0:,","),"]")'''
write(io,'(a)')'      write(*,*)''FMT='',fmt'
write(io,'(a)')'      write(*,fmt)(arr(i,:),i=1,size(arr,dim=1))'
write(io,'(a)')'   end subroutine print_buildfmt'
write(io,'(a)')''
write(io,'(a)')'   subroutine print_fixedfmt(arr)'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   integer,intent(in) :: arr(:,:)'
write(io,'(a)')'   integer :: i'
write(io,'(a)')'      do i=1,size(arr,dim=1)'
write(io,'(a)')'         write(*, ''("> [",*(i0:,","))'' ,advance=''no'')arr(i,:)'
write(io,'(a)')'         write(*,''("]")'')'
write(io,'(a)')'      enddo'
write(io,'(a)')'   end subroutine print_fixedfmt'
write(io,'(a)')''
write(io,'(a)')'   end program demo_array_constructors ! initializing small arrays'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'    o DO construct'
write(io,'(a)')''
write(io,'(a)')'    o Derived types'
write(io,'(a)')''
write(io,'(a)')'    o Structure constructors'
write(io,'(a)')''
write(io,'(a)')'    o Array Elements for details on array element order'
write(io,'(a)')''
write(io,'(a)')'    o Array Assignment Statements for details on another way to assign values to arrays'
write(io,'(a)')''
write(io,'(a)')'    o Declaration Statements for Arrays for details on array specifications'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   inquire(7f) - [FORTRAN:FILE_INQUIRE] File inquiry statement'
write(io,'(a)')'   (LICENSE:PD)'
write(io,'(a)')''
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')''
write(io,'(a)')'   INQUIRE([UNIT=file_unit_number]|[FILE=file_name_expr])'
write(io,'(a)')''
write(io,'(a)')'    and  ACCESS = scalar_default_char_variable'
write(io,'(a)')'    or   ACTION = scalar_default_char_variable'
write(io,'(a)')'    or   ASYNCHRONOUS = scalar_default_char_variable'
write(io,'(a)')'    or   DIRECT = scalar_default_char_variable'
write(io,'(a)')''
write(io,'(a)')'    or   BLANK = scalar_default_char_variable'
write(io,'(a)')'    or   DECIMAL = scalar_default_char_variable'
write(io,'(a)')'    or   DELIM = scalar_default_char_variable'
write(io,'(a)')'    or   ENCODING = scalar_default_char_variable'
write(io,'(a)')'    or   PAD = scalar_default_char_variable'
write(io,'(a)')'    or   SIGN = scalar_default_char_variable'
write(io,'(a)')''
write(io,'(a)')'    or   ERR = label'
write(io,'(a)')'    or   IOMSG = iomsg_variable'
write(io,'(a)')'    or   IOSTAT = scalar_int_variable'
write(io,'(a)')''
write(io,'(a)')'    or   EXIST = scalar_logical_variable'
write(io,'(a)')'    or   FORM = scalar_default_char_variable'
write(io,'(a)')'    or   FORMATTED = scalar_default_char_variable'
write(io,'(a)')'    or   ID = scalar_int_expr'
write(io,'(a)')'    or   NAME = scalar_default_char_variable'
write(io,'(a)')'    or   NAMED = scalar_logical_variable'
write(io,'(a)')'    or   NEXTREC = scalar_int_variable'
write(io,'(a)')'    or   NUMBER = scalar_int_variable'
write(io,'(a)')'    or   OPENED = scalar_logical_variable'
write(io,'(a)')'    or   PENDING = scalar_logical_variable'
write(io,'(a)')'    or   POS = scalar_int_variable'
write(io,'(a)')'    or   POSITION = scalar_default_char_variable'
write(io,'(a)')'    or   READ = scalar_default_char_variable'
write(io,'(a)')'    or   READWRITE = scalar_default_char_variable'
write(io,'(a)')'    or   RECL = scalar_int_variable'
write(io,'(a)')'    or   ROUND = scalar_default_char_variable'
write(io,'(a)')'    or   SEQUENTIAL = scalar_default_char_variable'
write(io,'(a)')'    or   SIZE = scalar_int_variable'
write(io,'(a)')'    or   STREAM = scalar_default_char_variable'
write(io,'(a)')'    or   UNFORMATTED = scalar_default_char_variable'
write(io,'(a)')'    or   WRITE = scalar_default_char_variable'
write(io,'(a)')''
write(io,'(a)')'     or'
write(io,'(a)')''
write(io,'(a)')'    INQUIRE(IOLENGTH=scalar_int_variable) output_item_list'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'  The INQUIRE statement may be used to inquire about properties of a particular named file or of the connection'
write(io,'(a)')'  to a particular unit. There are three forms of the INQUIRE statement:'
write(io,'(a)')''
write(io,'(a)')'     o inquire by file, which uses the FILE= specifier'
write(io,'(a)')'     o inquire by unit, which uses the UNIT= specifier'
write(io,'(a)')'     o inquire by output list, which uses only the IOLENGTH= specifier.'
write(io,'(a)')''
write(io,'(a)')'  All specifier value assignments are performed according to the rules for assignment statements.'
write(io,'(a)')''
write(io,'(a)')'  For inquiry by unit, the unit specified need not exist or be connected to a file. If it is connected to a file, t&
   &he'
write(io,'(a)')'  inquiry is being made about the connection and about the file connected.'
write(io,'(a)')''
write(io,'(a)')'  An INQUIRE statement may be executed before, while, or after a file is connected to a unit. All values assigned'
write(io,'(a)')'  by an INQUIRE statement are those that are current at the time the statement is executed.'
write(io,'(a)')''
write(io,'(a)')'  ERROR PROCESSING'
write(io,'(a)')''
write(io,'(a)')'  If an error condition occurs during execution of an INQUIRE statement, all of the inquiry specifier variables'
write(io,'(a)')'  become undefined, except for variables in the IOSTAT= and IOMSG= specifiers (if any).'
write(io,'(a)')''
write(io,'(a)')'  The IOSTAT=, ERR=, and IOMSG= specifiers are described in 9.11.'
write(io,'(a)')''
write(io,'(a)')'OPTIONS'
write(io,'(a)')''
write(io,'(a)')'  Unless constrained, the following inquiry specifiers may be used in either of the inquire by file or inquire by u&
   &nit'
write(io,'(a)')'  forms of the INQUIRE statement.'
write(io,'(a)')''
write(io,'(a)')'   o No specifier shall appear more than once in a given inquire_spec_list.'
write(io,'(a)')''
write(io,'(a)')'   o An inquire_spec_list shall contain one FILE= specifier or one UNIT= specifier, but not both.'
write(io,'(a)')''
write(io,'(a)')'   o In the inquire by unit form of the INQUIRE statement, if the optional characters UNIT= are omitted,'
write(io,'(a)')'     the file_unit-number shall be the first item in the inquire_spec_list.'
write(io,'(a)')''
write(io,'(a)')'   o If an ID= specifier appears in an inquire_spec_list, a PENDING= specifier shall also appear.'
write(io,'(a)')''
write(io,'(a)')'   o The label in the ERR= specifier shall be the statement label of a branch target statement that'
write(io,'(a)')'     appears in the same scoping unit as the INQUIRE statement.'
write(io,'(a)')''
write(io,'(a)')'  If file_unit-number identifies an internal unit, an error condition occurs.'
write(io,'(a)')''
write(io,'(a)')'  When a returned value of a specifier other than the NAME= specifier is of type character, the value returned is'
write(io,'(a)')'  in upper case.'
write(io,'(a)')''
write(io,'(a)')'  The specifier that receives the returned value is a a default scalar variable.'
write(io,'(a)')''
write(io,'(a)')'INPUTS'
write(io,'(a)')''
write(io,'(a)')'   FILE'
write(io,'(a)')''
write(io,'(a)')'   The value of the file_name_expr in the FILE= specifier specifies the name of the file being inquired about. The'
write(io,'(a)')'   named file need not exist or be connected to a unit. The value of the file_name_expr shall be of a form acceptab&
   &le'
write(io,'(a)')'   to the processor as a file name. Any trailing blanks are ignored. The interpretation of case is processor depend&
   &ent.'
write(io,'(a)')''
write(io,'(a)')'   UNIT'
write(io,'(a)')''
write(io,'(a)')'OUTPUTS'
write(io,'(a)')''
write(io,'(a)')'   ACCESS'
write(io,'(a)')''
write(io,'(a)')'     SEQUENTIAL if the connection is for sequential access'
write(io,'(a)')'     DIRECT     if the connection is for direct access'
write(io,'(a)')'     STREAM     if the connection is for stream access.'
write(io,'(a)')'     UNDEFINED  If there is no connection,'
write(io,'(a)')''
write(io,'(a)')'   ACTION'
write(io,'(a)')''
write(io,'(a)')'    READ       the connection is for input only,'
write(io,'(a)')'    WRITE      the connection is for output only'
write(io,'(a)')'    READWRITE  the connection is for both input and output.'
write(io,'(a)')'    UNDEFINED  if there is no connection,'
write(io,'(a)')''
write(io,'(a)')'   ASYNCHRONOUS'
write(io,'(a)')''
write(io,'(a)')'    YES        if the connection allows asynchronous input/output'
write(io,'(a)')'    NO         if the connection does not allow asynchronous input/output.'
write(io,'(a)')'    UNDEFINED  If there is no connection'
write(io,'(a)')''
write(io,'(a)')'  BLANK'
write(io,'(a)')''
write(io,'(a)')'    ZERO       blanks are interpreted as zeros on input'
write(io,'(a)')'    NULL       blanks are interpreted as a null on input'
write(io,'(a)')'    UNDEFINED  no connection or the connection is not for formatted input/output'
write(io,'(a)')''
write(io,'(a)')'  DECIMAL'
write(io,'(a)')''
write(io,'(a)')'    COMMA      treat a comma as the separator between mantissa and decimal'
write(io,'(a)')'    POINT      use a decimal point as the separator'
write(io,'(a)')'    UNDEFINED  no connection or the connection is not for formatted input/output'
write(io,'(a)')''
write(io,'(a)')'  DELIM'
write(io,'(a)')''
write(io,'(a)')'    APOSTROPHE,  the delimiter mode in effect for a connection for formatted input/output.'
write(io,'(a)')'    QUOTE,'
write(io,'(a)')'    NONE'
write(io,'(a)')''
write(io,'(a)')'    UNDEFINED  no connection or the connection is not for formatted input/output'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'  DIRECT'
write(io,'(a)')''
write(io,'(a)')'    YES     if DIRECT is included in the set of allowed access methods for the file'
write(io,'(a)')'    NO      if DIRECT is not included in the set of allowed access methods for the file'
write(io,'(a)')'    UNKNOWN if the processor is unable to determine whether DIRECT is included in the set of'
write(io,'(a)')'              allowed access methods for the file.'
write(io,'(a)')''
write(io,'(a)')'  ENCODING'
write(io,'(a)')''
write(io,'(a)')'    UTF-8      if the connection is for formatted input/output with an encoding form of UTF-8'
write(io,'(a)')'    UNDEFINED  the connection is for unformatted input/output.'
write(io,'(a)')''
write(io,'(a)')'    If there is no connection,'
write(io,'(a)')''
write(io,'(a)')'    UTF-8        if the processor is able to determine that the encoding form of the file is UTF-8'
write(io,'(a)')'    UNKNOWN      if the processor is unable to determine the encoding form of the file'
write(io,'(a)')''
write(io,'(a)')'        NOTE'
write(io,'(a)')'        The value assigned may be something other than UTF-8, UNDEFINED,'
write(io,'(a)')'        or UNKNOWN if the processor supports other specific encoding forms'
write(io,'(a)')'        (e.g. UTF-16BE).'
write(io,'(a)')''
write(io,'(a)')'  EXIST'
write(io,'(a)')'   .true.    if there exists a file with the specified name if inquire is by FILE=filename statement'
write(io,'(a)')'             or if by UNIT=number and the specified unit exists.'
write(io,'(a)')'   .false.   otherwise, false is assigned.'
write(io,'(a)')''
write(io,'(a)')'  FORM'
write(io,'(a)')''
write(io,'(a)')'   FORMATTED    if the connection is for formatted input/output,'
write(io,'(a)')'   UNFORMATTED  if the connection is for unformatted input/output.'
write(io,'(a)')'   UNDEFINED    If there is no connection'
write(io,'(a)')''
write(io,'(a)')'  FORMATTED'
write(io,'(a)')''
write(io,'(a)')'   YES     if FORMATTED is included in the set of allowed forms for the file'
write(io,'(a)')'   NO      if FORMATTED is not included in the set of allowed forms for the file'
write(io,'(a)')'   UNKNOWN if the processor is unable to determine whether FORMATTED is included in the'
write(io,'(a)')'             set of allowed forms for the file.'
write(io,'(a)')''
write(io,'(a)')'  ID'
write(io,'(a)')''
write(io,'(a)')'   The value of the expression specified in the ID= specifier shall be the identifier of a pending data transfer op&
   &eration'
write(io,'(a)')'   for the specified unit. This specifier interacts with the PENDING= specifier (9.10.2.21).'
write(io,'(a)')''
write(io,'(a)')'  NAME'
write(io,'(a)')''
write(io,'(a)')'  The scalar_default_char_variable in the NAME= specifier is assigned the value of the name of the file if the file'
write(io,'(a)')'  has a name; otherwise, it becomes undefined.'
write(io,'(a)')''
write(io,'(a)')'        NOTE'
write(io,'(a)')'        If this specifier appears in an INQUIRE by file statement, its'
write(io,'(a)')'        value is not necessarily the same as the name given in the FILE='
write(io,'(a)')'        specifier. However, the value returned shall be suitable for'
write(io,'(a)')'        use as the value of the file_name_expr in the FILE= specifier'
write(io,'(a)')'        in an OPEN statement.'
write(io,'(a)')''
write(io,'(a)')'        The processor may return a file name qualified by a user'
write(io,'(a)')'        identification, device, directory, or other relevant information.'
write(io,'(a)')''
write(io,'(a)')'   The case of the characters assigned to scalar_default_char_variable is processor dependent.'
write(io,'(a)')''
write(io,'(a)')'   NAMED'
write(io,'(a)')''
write(io,'(a)')'   The scalar_logical_variable in the NAMED= specifier is assigned the value true if the file has a name; otherwise&
   &,'
write(io,'(a)')'   it is assigned the value false.'
write(io,'(a)')''
write(io,'(a)')'   NEXTREC'
write(io,'(a)')''
write(io,'(a)')'   The scalar_int_variable in the NEXTREC= specifier is assigned the value n + 1, where n is the record number of'
write(io,'(a)')'   the last record read from or written to the connection for direct access. If there is a connection but no record&
   &s have'
write(io,'(a)')'   been read or written since the connection, the scalar_int_variable is assigned the value 1. If there is no conne&
   &ction,'
write(io,'(a)')'   the connection is not for direct access, or the position is indeterminate because of a previous error condition,&
   & the'
write(io,'(a)')'   scalar_int_variable becomes undefined. If there are pending data transfer operations for the specified unit, the'
write(io,'(a)')'   value assigned is computed as if all the pending data transfers had already completed.'
write(io,'(a)')''
write(io,'(a)')'   NUMBER'
write(io,'(a)')''
write(io,'(a)')'   The scalar_int_variable in the NUMBER= specifier is assigned the value of the external unit number of the unit'
write(io,'(a)')'   that is connected to the file. If there is no unit connected to the file, the value -1 is assigned.'
write(io,'(a)')''
write(io,'(a)')'   OPENED'
write(io,'(a)')''
write(io,'(a)')'   .true.   if the file specified is connected to a unit'
write(io,'(a)')'   .false. otherwise'
write(io,'(a)')''
write(io,'(a)')'   PAD'
write(io,'(a)')''
write(io,'(a)')'   YES,       corresponding to the pad mode in effect for a connection.'
write(io,'(a)')'   NO'
write(io,'(a)')''
write(io,'(a)')'   UNDEFINED  If there is no connection or if the connection is not for formatted input/output,'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'   PENDING'
write(io,'(a)')''
write(io,'(a)')'   The PENDING= specifier is used to determine whether previously pending asynchronous data transfers are'
write(io,'(a)')'   complete. A data transfer operation is previously pending if it is pending at the beginning of execution of the'
write(io,'(a)')'   INQUIRE statement.'
write(io,'(a)')''
write(io,'(a)')'   If an ID= specifier appears and the specified data transfer operation is complete, then the variable specified i&
   &n'
write(io,'(a)')'   the PENDING= specifier is assigned the value false and the INQUIRE statement performs the wait operation'
write(io,'(a)')'   for the specified data transfer.'
write(io,'(a)')''
write(io,'(a)')'   If the ID= specifier is omitted and all previously pending data transfer operations for the specified unit are'
write(io,'(a)')'   complete, then the variable specified in the PENDING= specifier is assigned the value false and the INQUIRE'
write(io,'(a)')'   statement performs wait operations for all previously pending data transfers for the specified unit.'
write(io,'(a)')''
write(io,'(a)')'   In all other cases, the variable specified in the PENDING= specifier is assigned the value true and no wait'
write(io,'(a)')'   operations are performed; in this case the previously pending data transfers remain pending after the execution'
write(io,'(a)')'   of the INQUIRE statement.'
write(io,'(a)')''
write(io,'(a)')'        NOTE:'
write(io,'(a)')'        The processor has considerable flexibility in defining when'
write(io,'(a)')'        it considers a transfer to be complete. Any of the following'
write(io,'(a)')'        approaches could be used:'
write(io,'(a)')''
write(io,'(a)')'           o The INQUIRE statement could consider an asynchronous data'
write(io,'(a)')'             transfer to be incomplete until after'
write(io,'(a)')'             the corresponding wait operation. In this case PENDING='
write(io,'(a)')'             would always return true unless there were no previously'
write(io,'(a)')'             pending data transfers for the unit.'
write(io,'(a)')''
write(io,'(a)')'           o The INQUIRE statement could wait for all specified data'
write(io,'(a)')'             transfers to complete and then always return'
write(io,'(a)')'             false for PENDING=.'
write(io,'(a)')''
write(io,'(a)')'           o The INQUIRE statement could actually test the state of the'
write(io,'(a)')'             specified data transfer operations.'
write(io,'(a)')''
write(io,'(a)')'  POS'
write(io,'(a)')''
write(io,'(a)')'  The scalar_int_variable in the POS= specifier is assigned the number of the file storage unit immediately followi&
   &ng'
write(io,'(a)')'  the current position of a file connected for stream access. If the file is positioned at its terminal position, t&
   &he'
write(io,'(a)')'  variable is assigned a value one greater than the number of the highest-numbered file storage unit in the file. I&
   &f'
write(io,'(a)')'  the file is not connected for stream access or if the position of the file is indeterminate because of previous e&
   &rror'
write(io,'(a)')'  conditions, the variable becomes undefined.'
write(io,'(a)')''
write(io,'(a)')'  POSITION'
write(io,'(a)')''
write(io,'(a)')'  The scalar_default_char_variable in the POSITION= specifier is assigned the value REWIND if the connection'
write(io,'(a)')'  was opened for positioning at its initial point, APPEND if the connection was opened for positioning before its'
write(io,'(a)')'  endfile record or at its terminal point, and ASIS if the connection was opened without changing its position.'
write(io,'(a)')'  If there is no connection or if the file is connected for direct access, the scalar_default_char_variable is assi&
   &gned'
write(io,'(a)')'  the value UNDEFINED. If the file has been repositioned since the connection, the scalar_default_char_variable'
write(io,'(a)')'  is assigned a processor-dependent value, which shall not be REWIND unless the file is positioned at its initial'
write(io,'(a)')'  point and shall not be APPEND unless the file is positioned so that its endfile record is the next record or at i&
   &ts'
write(io,'(a)')'  terminal point if it has no endfile record.'
write(io,'(a)')''
write(io,'(a)')'  READ'
write(io,'(a)')''
write(io,'(a)')'  The scalar_default_char_variable in the READ= specifier is assigned the value YES if READ is included in the'
write(io,'(a)')'  set of allowed actions for the file, NO if READ is not included in the set of allowed actions for the file, and'
write(io,'(a)')'  UNKNOWN if the processor is unable to determine whether READ is included in the set of allowed actions for'
write(io,'(a)')'  the file.'
write(io,'(a)')''
write(io,'(a)')'  READWRITE'
write(io,'(a)')''
write(io,'(a)')'  The scalar_default_char_variable in the READWRITE= specifier is assigned the value YES if READWRITE is'
write(io,'(a)')'  included in the set of allowed actions for the file, NO if READWRITE is not included in the set of allowed action&
   &s'
write(io,'(a)')'  for the file, and UNKNOWN if the processor is unable to determine whether READWRITE is included in the'
write(io,'(a)')'  set of allowed actions for the file.'
write(io,'(a)')''
write(io,'(a)')'  RECL'
write(io,'(a)')''
write(io,'(a)')'  The scalar_int_variable in the RECL= specifier is assigned the value of the record length of a connection for dir&
   &ect'
write(io,'(a)')'  access, or the value of the maximum record length of a connection for sequential access. If the connection is for'
write(io,'(a)')'  formatted input/output, the length is the number of characters for all records that contain only characters of'
write(io,'(a)')'  default kind. If the connection is for unformatted input/output, the length is measured in file storage units. If'
write(io,'(a)')'  there is no connection, or if the connection is for stream access, the scalar_int_variable becomes undefined.'
write(io,'(a)')''
write(io,'(a)')'  ROUND'
write(io,'(a)')''
write(io,'(a)')' The scalar_default_char_variable in the ROUND= specifier is assigned'
write(io,'(a)')' the value UP, DOWN, ZERO, NEAREST, COMPATIBLE, or PROCESSOR DEFINED,'
write(io,'(a)')' corresponding to the I/O rounding mode in effect for a connection for'
write(io,'(a)')' formatted input/output. If there is no connection or if the connection'
write(io,'(a)')' is not for formatted input/output, the scalar_default_char_variable'
write(io,'(a)')' is assigned the value UNDEFINED. The processor shall return the value'
write(io,'(a)')' PROCESSOR DEFINED only if the behavior of the current I/O rounding'
write(io,'(a)')' mode is different from that of the UP, DOWN,'
write(io,'(a)')' ZERO, NEAREST, and COMPATIBLE modes.'
write(io,'(a)')''
write(io,'(a)')' SEQUENTIAL'
write(io,'(a)')''
write(io,'(a)')' The scalar_default_char_variable in the SEQUENTIAL= specifier is assigned the value YES if SEQUENTIAL is'
write(io,'(a)')' included in the set of allowed access methods for the file, NO if SEQUENTIAL is not included in the set of allowed'
write(io,'(a)')' access methods for the file, and UNKNOWN if the processor is unable to determine whether SEQUENTIAL is'
write(io,'(a)')' included in the set of allowed access methods for the file.'
write(io,'(a)')''
write(io,'(a)')' SIGN'
write(io,'(a)')''
write(io,'(a)')'  The scalar_default_char_variable in the SIGN= specifier is assigned the'
write(io,'(a)')'  value PLUS, SUPPRESS, or PROCESSOR DEFINED, corresponding to the sign'
write(io,'(a)')'  mode in effect for a connection for formatted input/output. If there is'
write(io,'(a)')'  no connection, or if the connection is not for formatted input/output,'
write(io,'(a)')'  the scalar_default_char_variable is assigned the value UNDEFINED.'
write(io,'(a)')''
write(io,'(a)')'  SIZE'
write(io,'(a)')''
write(io,'(a)')'  The scalar_int_variable in the SIZE= specifier is assigned the size of the file in file storage units. If the fil&
   &e size'
write(io,'(a)')'  cannot be determined, the variable is assigned the value -1.'
write(io,'(a)')''
write(io,'(a)')'  For a file that may be connected for stream access, the file size is the number of the highest-numbered file stor&
   &age'
write(io,'(a)')'  unit in the file.'
write(io,'(a)')''
write(io,'(a)')'  For a file that may be connected for sequential or direct access, the file size may be different from the number &
   &of'
write(io,'(a)')'  storage units implied by the data in the records; the exact relationship is processor-dependent.'
write(io,'(a)')''
write(io,'(a)')'  STREAM'
write(io,'(a)')''
write(io,'(a)')'  The scalar_default_char_variable in the STREAM= specifier is assigned the value YES if STREAM is included in'
write(io,'(a)')'  the set of allowed access methods for the file, NO if STREAM is not included in the set of allowed access methods'
write(io,'(a)')'  for the file, and UNKNOWN if the processor is unable to determine whether STREAM is included in the set of'
write(io,'(a)')'  allowed access methods for the file.'
write(io,'(a)')''
write(io,'(a)')'  UNFORMATTED'
write(io,'(a)')''
write(io,'(a)')'  The scalar_default_char_variable in the UNFORMATTED= specifier is'
write(io,'(a)')'  assigned the value YES if UNFORMATTED is included in the set of allowed'
write(io,'(a)')'  forms for the file, NO if UNFORMATTED is not included in the set of'
write(io,'(a)')'  allowed forms for the file, and UNKNOWN if the processor is unable to'
write(io,'(a)')'  determine whether UNFORMATTED is included in the set of allowed forms'
write(io,'(a)')'  for the file.'
write(io,'(a)')''
write(io,'(a)')'  WRITE'
write(io,'(a)')''
write(io,'(a)')'  The scalar_default_char_variable in the WRITE= specifier is assigned the value YES if WRITE is included in the'
write(io,'(a)')'  set of allowed actions for the file, NO if WRITE is not included in the set of allowed actions for the file, and'
write(io,'(a)')'  UNKNOWN if the processor is unable to determine whether WRITE is included in the set of allowed actions for'
write(io,'(a)')'  the file.'
write(io,'(a)')''
write(io,'(a)')'INQUIRE BY OUTPUT LIST'
write(io,'(a)')''
write(io,'(a)')'  The scalar_int_variable in the IOLENGTH= specifier is assigned the processor-dependent number of file storage'
write(io,'(a)')'  units that would be required to store the data of the output list in an unformatted file. The value shall be suit&
   &able'
write(io,'(a)')'  as a RECL= specifier in an OPEN statement that connects a file for unformatted direct access when there are'
write(io,'(a)')'  input/output statements with the same input/output list.'
write(io,'(a)')''
write(io,'(a)')'  The output list in an INQUIRE statement shall not contain any derived-type list items that require a defined'
write(io,'(a)')'  input/output procedure as described in subclause 9.6.3. If a derived-type list item appears in the output list, t&
   &he'
write(io,'(a)')'  value returned for the IOLENGTH= specifier assumes that no defined input/output procedure will be invoked.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLES'
write(io,'(a)')'  Examples of INQUIRE statements are:'
write(io,'(a)')''
write(io,'(a)')'     INQUIRE (IOLENGTH = IOL) A (1:N)'
write(io,'(a)')'     INQUIRE (UNIT = JOAN, OPENED = LOG_01, NAMED = LOG_02, &'
write(io,'(a)')'        FORM = CHAR_VAR, IOSTAT = IOS)'
write(io,'(a)')'NAME'
write(io,'(a)')'    NAMELIST(7f) - [FORTRAN:STATEMENT] specify a group of data to be referred to by a single name in data input/out&
   &put'
write(io,'(a)')'    (LICENSE:PD)'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'   NAMELIST /namelist-group-name/ namelist-group-object-list [[,] /namelist-group-name/'
write(io,'(a)')'            namelist-group-object-list ] ...'
write(io,'(a)')''
write(io,'(a)')'            namelist-group-object is variable-name'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   A NAMELIST statement specifies a group of named data objects, which'
write(io,'(a)')'   may be referred to by a single name for the purpose of data transfer.'
write(io,'(a)')''
write(io,'(a)')'   The order in which the variables are specified in the NAMELIST'
write(io,'(a)')'   statement determines the order in which the values appear on output.'
write(io,'(a)')''
write(io,'(a)')'    o The namelist-group-name shall not be a name accessed by use association.'
write(io,'(a)')'    o A namelist-group-object shall not be an assumed-size array.'
write(io,'(a)')'    o A namelist-group-object shall not have the PRIVATE attribute if'
write(io,'(a)')'      the namelist-group-name has the PUBLIC attribute.'
write(io,'(a)')''
write(io,'(a)')'   Any namelist-group-name may occur more than once in the NAMELIST'
write(io,'(a)')'   statements in a scoping unit. The namelist-group-object-list following'
write(io,'(a)')'   each successive appearance of the same namelist-group-name in a'
write(io,'(a)')'   scoping unit is treated as a continuation of the list for that'
write(io,'(a)')'   namelist-group-name.'
write(io,'(a)')''
write(io,'(a)')'   A namelist group object may be a member of more than one namelist'
write(io,'(a)')'   group.'
write(io,'(a)')''
write(io,'(a)')'   A namelist group object shall either be accessed by use or host'
write(io,'(a)')'   association or shall have its type, type parameters, and shape'
write(io,'(a)')'   specified by previous specification statements or the procedure heading'
write(io,'(a)')'   in the same scoping unit or by the implicit typing rules in effect for'
write(io,'(a)')'   the scoping unit. If a namelist group object is typed by the implicit'
write(io,'(a)')'   typing rules, its appearance in any subsequent type declaration'
write(io,'(a)')'   statement shall confirm the implied type and type parameters.'
write(io,'(a)')''
write(io,'(a)')'   The specification-part of a BLOCK construct shall not contain a'
write(io,'(a)')'   NAMELIST statement.'
write(io,'(a)')''
write(io,'(a)')'   Why is NAMELIST not allowed in a BLOCK unit?'
write(io,'(a)')'   Would be handy for quick writes, like list-directed output'
write(io,'(a)')''
write(io,'(a)')'    block'
write(io,'(a)')'       namelist /nlist/ a,b,c,d'
write(io,'(a)')'       write(*,nlist)'
write(io,'(a)')'    endblock'
write(io,'(a)')''
write(io,'(a)')'   Input for a namelist input statement consists of'
write(io,'(a)')''
write(io,'(a)')'      1) optional blanks and namelist comments,'
write(io,'(a)')'      2) the character & followed immediately by the namelist-group-name as specified in the NAMELIST'
write(io,'(a)')'         statement,'
write(io,'(a)')'      3) one or more blanks,'
write(io,'(a)')'      4) a sequence of zero or more name-value subsequences separated by value separators, and'
write(io,'(a)')'      5) a slash to terminate the namelist input.'
write(io,'(a)')''
write(io,'(a)')'         A slash encountered in a namelist input record causes the input statement to terminate. A slash cannot be'
write(io,'(a)')'         used to separate two values in a namelist input statement.'
write(io,'(a)')''
write(io,'(a)')'   A group name or object name is without regard to case.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'   An example of a NAMELIST statement is:'
write(io,'(a)')''
write(io,'(a)')'     NAMELIST /NLIST/ A, B, C'
write(io,'(a)')''
write(io,'(a)')'   or a group may be defined by multiple statements using the same group name in a scoping unit:'
write(io,'(a)')''
write(io,'(a)')'     NAMELIST /NLIST/ A, B'
write(io,'(a)')'     NAMELIST /NLIST/ C'
write(io,'(a)')''
write(io,'(a)')'     ! READ/WRITE EXAMPLES: [ NML = ] namelist-group-name'
write(io,'(a)')'     READ(*,NML=NLIST)'
write(io,'(a)')'     WRITE(*,NLIST)'
write(io,'(a)')'     WRITE(*,NML=NLIST)'
write(io,'(a)')''
write(io,'(a)')'      program sample_namelist'
write(io,'(a)')'      implicit none'
write(io,'(a)')'      logical           :: l=.true.'
write(io,'(a)')'      character(len=10) :: c=''XXXXXXXXXX'''
write(io,'(a)')'      real              :: r=12.3456'
write(io,'(a)')'      integer           :: i=789'
write(io,'(a)')'      complex           :: x=(12345.6789,9876.54321)'
write(io,'(a)')'      doubleprecision   :: d= 123456789.123456789d0'
write(io,'(a)')'      namelist /nlist/ l,c,r,i,x,d'
write(io,'(a)')'         write(*,nlist)'
write(io,'(a)')'      end program sample_namelist'
write(io,'(a)')''
write(io,'(a)')'   Results:'
write(io,'(a)')''
write(io,'(a)')'      &NLIST'
write(io,'(a)')'       L=T,'
write(io,'(a)')'       C="XXXXXXXXXX",'
write(io,'(a)')'       R=  12.3456001    ,'
write(io,'(a)')'       I=        789,'
write(io,'(a)')'       X=(  12345.6787    ,  9876.54297    ),'
write(io,'(a)')'       D=  123456789.12345679     ,'
write(io,'(a)')'       /'
write(io,'(a)')''
write(io,'(a)')'   Longer example:'
write(io,'(a)')''
write(io,'(a)')'      program demo_namelist'
write(io,'(a)')'      implicit none'
write(io,'(a)')'      integer           :: lun'
write(io,'(a)')''
write(io,'(a)')'      ! create a namelist and initialize the values'
write(io,'(a)')'      logical           :: l=.true.'
write(io,'(a)')'      character(len=10) :: c=''XXXXXXXXXX'''
write(io,'(a)')'      real              :: r=12.3456'
write(io,'(a)')'      integer           :: i=789'
write(io,'(a)')'      complex           :: x=(12345.6789,9876.54321)'
write(io,'(a)')'      doubleprecision   :: d= 123456789.123456789d0'
write(io,'(a)')'      integer           :: a(5)=[1,2,3,4,5]'
write(io,'(a)')'      type point'
write(io,'(a)')'       integer           :: x=0'
write(io,'(a)')'       integer           :: y=0'
write(io,'(a)')'       character(len=10) :: color=''red'''
write(io,'(a)')'      endtype point'
write(io,'(a)')'      type(point) :: dot'
write(io,'(a)')'      namelist /nlist/ l,c,r,i,x,d,a,dot'
write(io,'(a)')''
write(io,'(a)')'      open(file=''_tmp_'',newunit=lun)'
write(io,'(a)')''
write(io,'(a)')'         write(*,*)''initial nlist'''
write(io,'(a)')'         write(*,nlist)'
write(io,'(a)')'         write(lun,nlist)'
write(io,'(a)')''
write(io,'(a)')'         write(*,*)''change values and print nlist again'''
write(io,'(a)')'         a=[10,20,30,40,50]'
write(io,'(a)')'         dot%color=''orange'''
write(io,'(a)')'         write(lun,nlist)'
write(io,'(a)')''
write(io,'(a)')'         write(*,*)''read back values. Can have multiple sets in a file'''
write(io,'(a)')'         rewind(lun)'
write(io,'(a)')'         read(lun,nlist)'
write(io,'(a)')'         read(lun,nlist)'
write(io,'(a)')'         write(*,nlist)'
write(io,'(a)')''
write(io,'(a)')'      end program demo_namelist'
write(io,'(a)')''
write(io,'(a)')'  Results:'
write(io,'(a)')''
write(io,'(a)')'    initial nlist'
write(io,'(a)')'   &NLIST'
write(io,'(a)')'    L=T,'
write(io,'(a)')'    C="XXXXXXXXXX",'
write(io,'(a)')'    R=  12.3456001    ,'
write(io,'(a)')'    I=        789,'
write(io,'(a)')'    X=(12345.6787,9876.54297),'
write(io,'(a)')'    D=  123456789.12345679     ,'
write(io,'(a)')'    A=          1,          2,          3,          4,          5,'
write(io,'(a)')''
write(io,'(a)')'    DOT%X=          0,'
write(io,'(a)')'    DOT%Y=          0,'
write(io,'(a)')'    DOT%COLOR="red       ",'
write(io,'(a)')'    /'
write(io,'(a)')'    change values and print nlist again'
write(io,'(a)')'    read back values. Can have multiple sets in a file'
write(io,'(a)')'   &NLIST'
write(io,'(a)')'    L=T,'
write(io,'(a)')'    C="XXXXXXXXXX",'
write(io,'(a)')'    R=  12.3456001    ,'
write(io,'(a)')'    I=        789,'
write(io,'(a)')'    X=(12345.6787,9876.54297),'
write(io,'(a)')'    D=  123456789.12345679     ,'
write(io,'(a)')'    A=         10,         20,         30,         40,         50,'
write(io,'(a)')''
write(io,'(a)')'    DOT%X=          0,'
write(io,'(a)')'    DOT%Y=          0,'
write(io,'(a)')'    DOT%COLOR="orange    ",'
write(io,'(a)')'    /'
write(io,'(a)')''
write(io,'(a)')'   o Scanning on input till group name is found'
write(io,'(a)')'   o reading partial lists'
write(io,'(a)')'   o string quoting'
write(io,'(a)')'   o NAMELIST in internal read and write. See'
write(io,'(a)')''
write(io,'(a)')'    ./arguments/namelist'
write(io,'(a)')''
write(io,'(a)')'OTHER'
write(io,'(a)')''
write(io,'(a)')'  C915    (R913) A namelist-group-name shall be the name of a namelist group.'
write(io,'(a)')''
write(io,'(a)')'  C916    (R913) A namelist-group-name shall not appear if a REC= specifier, format, input-item-list, or an'
write(io,'(a)')'          output-item-list appears in the data transfer statement.'
write(io,'(a)')'  C917    (R913) An io-control-spec-list shall not contain both a format and a namelist-group-name.'
write(io,'(a)')'  C919    (R913) If namelist-group-name appears without a preceding NML=, it shall be the second item in the'
write(io,'(a)')'          io-control-spec-list and the first item shall be io-unit.'
write(io,'(a)')'  C928    (R913) If a DECIMAL=, BLANK=, PAD=, SIGN=, or ROUND= specifier appears, a format or'
write(io,'(a)')'          namelist-group-name shall also appear.'
write(io,'(a)')'  C929    (R913) If a DELIM= specifier appears, either format shall be an asterisk or namelist-group-name shall'
write(io,'(a)')'          appear.'
write(io,'(a)')'3. If the data transfer statement contains a format or namelist-group-name, the statement is a formatted'
write(io,'(a)')'   input/output statement; otherwise, it is an unformatted input/output statement.'
write(io,'(a)')''
write(io,'(a)')'1. The NML= specifier supplies the namelist-group-name (5.6). This name identifies a particular collection of data'
write(io,'(a)')'   objects on which transfer is to be performed.'
write(io,'(a)')''
write(io,'(a)')'2. If a namelist-group-name appears, the statement is a namelist input/output statement.'
write(io,'(a)')''
write(io,'(a)')'4. All values following the name= part of the namelist entity (10.11) within the input records are transmitted to'
write(io,'(a)')'   the matching entity specified in the namelist-group-object-list prior to processing any succeeding entity within'
write(io,'(a)')'   the input record for namelist input statements. If an entity is specified more than once within the input record'
write(io,'(a)')'   during a namelist formatted data transfer input statement, the last occurrence of the entity specifies the value&
   & or'
write(io,'(a)')'   values to be used for that entity.'
write(io,'(a)')''
write(io,'(a)')'9.6.4.6     Namelist formatting'
write(io,'(a)')''
write(io,'(a)')' 1. If namelist formatting has been established, editing is performed as described in 10.11.'
write(io,'(a)')''
write(io,'(a)')' 2. Every allocatable namelist-group-object in the namelist group shall be allocated and every namelist-group-objec&
   &t'
write(io,'(a)')'    that is a pointer shall be associated with a target. If a namelist-group-object is polymorphic or has an ultima&
   &te'
write(io,'(a)')'    component that is allocatable or a pointer, that object shall be processed by a defined input/output procedure'
write(io,'(a)')'    (9.6.4.7).'
write(io,'(a)')''
write(io,'(a)')'9.6.5       Termination of data transfer statements'
write(io,'(a)')''
write(io,'(a)')'1. Termination of an input/output data transfer statement occurs when'
write(io,'(a)')''
write(io,'(a)')'        format processing encounters a colon or data edit descriptor and there are no remaining elements in the'
write(io,'(a)')'        input-item-list or output-item-list,'
write(io,'(a)')'        unformatted or list-directed data transfer exhausts the input-item-list or output-item-list,'
write(io,'(a)')'        namelist output exhausts the namelist-group-object-list,'
write(io,'(a)')'        an error condition occurs,'
write(io,'(a)')'        an end-of-file condition occurs,'
write(io,'(a)')''
write(io,'(a)')'        a slash (/) is encountered as a value separator (10.10, 10.11) in the record being read during list-directe&
   &d'
write(io,'(a)')'        or namelist input, or'
write(io,'(a)')'        an end-of-record condition occurs during execution of a nonadvancing input statement (9.11).'
write(io,'(a)')'2. If an error condition occurs during execution of an input/output statement that contains neither an ERR= nor'
write(io,'(a)')'   IOSTAT= specifier, error termination of the program is initiated. If an error condition occurs during execution'
write(io,'(a)')'   of an input/output statement that contains either an ERR= specifier or an IOSTAT= specifier then:'
write(io,'(a)')'        1.    processing of the input/output list, if any, terminates;'
write(io,'(a)')''
write(io,'(a)')'        2.    if the statement is a data transfer statement or the error occurs during a wait operation, all'
write(io,'(a)')'              do-variables in the statement that initiated the transfer become undefined;'
write(io,'(a)')'        3.    if an IOSTAT= specifier appears, the scalar-int-variable in the IOSTAT= specifier becomes defined'
write(io,'(a)')'              as specified in 9.11.5;'
write(io,'(a)')'        4.    if an IOMSG= specifier appears, the iomsg-variable becomes defined as specified in 9.11.6;'
write(io,'(a)')'        5.    if the statement is a READ statement and it contains a SIZE= specifier, the scalar-int-variable in'
write(io,'(a)')'              the SIZE= specifier becomes defined as specified in 9.6.2.15;'
write(io,'(a)')'        6.    if the statement is a READ statement or the error condition occurs in a wait operation for a transfer'
write(io,'(a)')'              initiated by a READ statement, all input items or namelist group objects in the statement that'
write(io,'(a)')'              initiated the transfer become undefined;'
write(io,'(a)')'        7.    if an ERR= specifier appears, a branch to the statement labeled by the label in the ERR= specifier'
write(io,'(a)')'               occurs.'
write(io,'(a)')' 8. In a data transfer statement, the variable specified in an IOSTAT=, IOMSG=, or SIZE= specifier, if any, shall'
write(io,'(a)')'    not be associated with any entity in the data transfer input/output list (9.6.3) or namelist-group-object-list,&
   & nor'
write(io,'(a)')'    with a do-variable of an io-implied-do in the data transfer input/output list.'
write(io,'(a)')'10.11        Namelist formatting'
write(io,'(a)')'10.11.1      General'
write(io,'(a)')' 1. Namelist input/output allows data editing with NAME=value subsequences. This facilitates documentation of'
write(io,'(a)')'    input and output files and more flexibility on input.'
write(io,'(a)')''
write(io,'(a)')'10.11.2      Name-value subsequences'
write(io,'(a)')' 1. The characters in one or more namelist records constitute a sequence of name-value subsequences, each of'
write(io,'(a)')'    which consists of an object designator followed by an equals and followed by one or more values and value'
write(io,'(a)')'    separators. The equals may optionally be preceded or followed by one or more contiguous blanks. The end of a'
write(io,'(a)')'    record has the same effect as a blank character, unless it is within a character constant. Any sequence of two &
   &or'
write(io,'(a)')'    more consecutive blanks is treated as a single blank, unless it is within a character constant.'
write(io,'(a)')''
write(io,'(a)')' 2. The name may be any name in the namelist-group-object-list (5.6).'
write(io,'(a)')''
write(io,'(a)')' 3. A value separator for namelist formatting is the same as for list-directed formatting (10.10).'
write(io,'(a)')''
write(io,'(a)')'10.11.3      Namelist input'
write(io,'(a)')'10.11.3.1    Overall syntax'
write(io,'(a)')''
write(io,'(a)')' 2. In each name-value subsequence, the name shall be the name of a namelist group object list item with an optiona&
   &l'
write(io,'(a)')'    qualification and the name with the optional qualification shall not be a zero-sized array, a zero-sized array &
   &section,'
write(io,'(a)')'    or a zero-length character string. The optional qualification, if any, shall not contain a vector subscript.'
write(io,'(a)')''
write(io,'(a)')'10.11.3.2    Namelist group object names'
write(io,'(a)')''
write(io,'(a)')'1. Within the input data, each name shall correspond to a particular namelist group object name. Subscripts,'
write(io,'(a)')'   strides, and substring range expressions used to qualify group object names shall be optionally signed integer'
write(io,'(a)')'   literal constants with no kind type parameters specified. If a namelist group object is an array, the input reco&
   &rd'
write(io,'(a)')'   corresponding to it may contain either the array name or the designator of a subobject of that array, using the'
write(io,'(a)')'   syntax of object designators (R601). If the namelist group object name is the name of a variable of derived type&
   &,'
write(io,'(a)')'   the name in the input record may be either the name of the variable or the designator of one of its components,'
write(io,'(a)')'   indicated by qualifying the variable name with the appropriate component name. Successive qualifications may'
write(io,'(a)')'   be applied as appropriate to the shape and type of the variable represented.'
write(io,'(a)')''
write(io,'(a)')'2. The order of names in the input records need not match the order of the namelist group object items. The input'
write(io,'(a)')'   records need not contain all the names of the namelist group object items. The definition status of any names'
write(io,'(a)')'   from the namelist-group-object-list that do not occur in the input record remains unchanged. In the input record&
   &,'
write(io,'(a)')'   each object name or subobject designator may be preceded and followed by one or more optional blanks but shall'
write(io,'(a)')'   not contain embedded blanks.'
write(io,'(a)')''
write(io,'(a)')'10.11.3.3    Namelist group object list items'
write(io,'(a)')''
write(io,'(a)')'1. The name-value subsequences are evaluated serially, in left-to-right order. A namelist group object designator'
write(io,'(a)')'   may appear in more than one name-value sequence.'
write(io,'(a)')''
write(io,'(a)')'2. When the name in the input record represents an array variable or a variable of derived type, the effect is as'
write(io,'(a)')'   if the variable represented were expanded into a sequence of scalar list items, in the same way that formatted'
write(io,'(a)')'   input/output list items are expanded (9.6.3). Each input value following the equals shall then be acceptable to'
write(io,'(a)')'   format specifications for the type of the list item in the corresponding position in the expanded sequence, exce&
   &pt'
write(io,'(a)')'   as noted in this subclause. The number of values following the equals shall not exceed the number of list items'
write(io,'(a)')'   in the expanded sequence, but may be less; in the latter case, the effect is as if sufficient null values had be&
   &en'
write(io,'(a)')'   appended to match any remaining list items in the expanded sequence.'
write(io,'(a)')''
write(io,'(a)')'        NOTE 10.35'
write(io,'(a)')'        For example, if the name in the input record is the name of an integer array of size 100, at most 100 value&
   &s,'
write(io,'(a)')'        each of which is either a digit string or a null value, may follow the equals; these values would then be'
write(io,'(a)')'        assigned to the elements of the array in array element order.'
write(io,'(a)')''
write(io,'(a)')'3. A slash encountered as a value separator during the execution of a namelist input statement causes termination'
write(io,'(a)')'   of execution of that input statement after transference of the previous value. If there are additional items in &
   &the'
write(io,'(a)')'   namelist group object being transferred, the effect is as if null values had been supplied for them.'
write(io,'(a)')''
write(io,'(a)')'4. A namelist comment may appear after any value separator except a slash. A namelist comment is also permitted'
write(io,'(a)')'   to start in the first nonblank position of an input record except within a character literal constant.'
write(io,'(a)')''
write(io,'(a)')'5. Successive namelist records are read by namelist input until a slash is encountered; the remainder of the record'
write(io,'(a)')'   is ignored and need not follow the rules for namelist input values.'
write(io,'(a)')''
write(io,'(a)')'   10.11.3.4    Namelist input values'
write(io,'(a)')''
write(io,'(a)')'1. Each value is either a null value (10.11.3.5), c, r *c, or r *, where c is a literal constant, optionally signed&
   & if integer'
write(io,'(a)')'   or real, and r is an unsigned, nonzero, integer literal constant. A kind type parameter shall not be specified f&
   &or c'
write(io,'(a)')'   or r. The constant c is interpreted as though it had the same kind type parameter as the corresponding effective'
write(io,'(a)')'   item. The r *c form is equivalent to r successive appearances of the constant c, and the r * form is equivalent &
   &to'
write(io,'(a)')'   r successive null values. Neither of these forms may contain embedded blanks, except where permitted within'
write(io,'(a)')'   the constant c.'
write(io,'(a)')''
write(io,'(a)')'2. The datum c (10.11) is any input value acceptable to format specifications for a given type, except for a restri&
   &ction'
write(io,'(a)')'   on the form of input values corresponding to list items of types logical, integer, and character as specified in&
   & this'
write(io,'(a)')'   subclause. The form of a real or complex value is dependent on the decimal edit mode in effect (10.6). The form'
write(io,'(a)')''
write(io,'(a)')'   of an input value shall be acceptable for the type of the namelist group object list item. The number and forms'
write(io,'(a)')'   of the input values that may follow the equals in a name-value subsequence depend on the shape and type of'
write(io,'(a)')'   the object represented by the name in the input record. When the name in the input record is that of a scalar'
write(io,'(a)')'   variable of an intrinsic type, the equals shall not be followed by more than one value. Blanks are never used'
write(io,'(a)')'   as zeros, and embedded blanks are not permitted in constants except within character constants and complex'
write(io,'(a)')'   constants as specified in this subclause.'
write(io,'(a)')''
write(io,'(a)')'3. When the next effective item is of type real, the input form of the input value is that of a numeric input field&
   &. A'
write(io,'(a)')'   numeric input field is a field suitable for F editing (10.7.2.3.2) that is assumed to have no fractional digits &
   &unless'
write(io,'(a)')'   a decimal symbol appears within the field.'
write(io,'(a)')''
write(io,'(a)')'4. When the next effective item is of type complex, the input form of the input value consists of a left parenthesi&
   &s'
write(io,'(a)')'   followed by an ordered pair of numeric input fields separated by a comma (if the decimal edit mode is POINT) or'
write(io,'(a)')'   a semicolon (if the decimal edit mode is COMMA), and followed by a right parenthesis. The first numeric input'
write(io,'(a)')'   field is the real part of the complex constant and the second part is the imaginary part. Each of the numeric'
write(io,'(a)')'   input fields may be preceded or followed by any number of blanks and ends of records. The end of a record may'
write(io,'(a)')'   occur between the real part and the comma or semicolon, or between the comma or semicolon and the imaginary'
write(io,'(a)')'   part.'
write(io,'(a)')''
write(io,'(a)')'5. When the next effective item is of type logical, the input form of the input value shall not include equals or v&
   &alue'
write(io,'(a)')'   separators among the optional characters permitted for L editing (10.7.3).'
write(io,'(a)')''
write(io,'(a)')'6. When the next effective item is of type integer, the value in the input record is interpreted as if an Iw edit'
write(io,'(a)')'   descriptor with a suitable value of w were used.'
write(io,'(a)')''
write(io,'(a)')'7. When the next effective item is of type character, the input form consists of a delimited sequence of zero or mo&
   &re'
write(io,'(a)')'   rep-char s whose kind type parameter is implied by the kind of the corresponding list item. Such a sequence'
write(io,'(a)')'   may be continued from the end of one record to the beginning of the next record, but the end of record shall'
write(io,'(a)')'   not occur between a doubled apostrophe in an apostrophe-delimited sequence, nor between a doubled quote in a'
write(io,'(a)')'   quote-delimited sequence. The end of the record does not cause a blank or any other character to become part'
write(io,'(a)')'   of the sequence. The sequence may be continued on as many records as needed. The characters blank, comma,'
write(io,'(a)')'   semicolon, and slash may appear in such character sequences.'
write(io,'(a)')''
write(io,'(a)')'          NOTE 10.36'
write(io,'(a)')'          A character sequence corresponding to a namelist input item of character type shall be delimited either w&
   &ith'
write(io,'(a)')'          apostrophes or with quotes. The delimiter is required to avoid ambiguity between undelimited character'
write(io,'(a)')'          sequences and object names. The value of the DELIM= specifier, if any, in the OPEN statement for an'
write(io,'(a)')'          external file is ignored during namelist input (9.5.6.8).'
write(io,'(a)')''
write(io,'(a)')'8. Let len be the length of the next effective item, and let w be the length of the character sequence. If len is l&
   &ess'
write(io,'(a)')'   than or equal to w, the leftmost len characters of the sequence are transmitted to the next effective item. If l&
   &en'
write(io,'(a)')'   is greater than w, the constant is transmitted to the leftmost w characters of the next effective item and the'
write(io,'(a)')'   remaining len-w characters of the next effective item are filled with blanks. The effect is as though the sequen&
   &ce'
write(io,'(a)')'   were assigned to the next effective item in an intrinsic assignment statement (7.2.1.3).'
write(io,'(a)')''
write(io,'(a)')'10.11.3.5      Null values'
write(io,'(a)')''
write(io,'(a)')'1. A null value is specified by'
write(io,'(a)')''
write(io,'(a)')'          the r * form,'
write(io,'(a)')'          blanks between two consecutive nonblank value separators following an equals,'
write(io,'(a)')'          zero or more blanks preceding the first value separator and following an equals, or'
write(io,'(a)')'          two consecutive nonblank value separators.'
write(io,'(a)')''
write(io,'(a)')'2. A null value has no effect on the definition status of the corresponding input list item. If the namelist group'
write(io,'(a)')'   object list item is defined, it retains its previous value; if it is undefined, it remains undefined. A null val&
   &ue shall'
write(io,'(a)')''
write(io,'(a)')'   not be used as either the real or imaginary part of a complex constant, but a single null value may represent an'
write(io,'(a)')'   entire complex constant.'
write(io,'(a)')''
write(io,'(a)')'   NOTE 10.37'
write(io,'(a)')'   The end of a record following a value separator, with or without intervening blanks, does not specify a null'
write(io,'(a)')'   value in namelist input.'
write(io,'(a)')''
write(io,'(a)')'10.11.3.6    Blanks'
write(io,'(a)')''
write(io,'(a)')'1.  All blanks in a namelist input record are considered to be part of some value separator except for'
write(io,'(a)')''
write(io,'(a)')'      o blanks embedded in a character constant,'
write(io,'(a)')'      o embedded blanks surrounding the real or imaginary part of a complex constant,'
write(io,'(a)')'      o leading blanks following the equals unless followed immediately by a slash or comma, or a semicolon if the'
write(io,'(a)')'      o decimal edit mode is comma, and'
write(io,'(a)')'      o blanks between a name and the following equals.'
write(io,'(a)')''
write(io,'(a)')'10.11.3.7    Namelist Comments'
write(io,'(a)')''
write(io,'(a)')'1. Except within a character literal constant, a "!" character after a value separator or in the first nonblank pos&
   &ition'
write(io,'(a)')'   of a namelist input record initiates a comment. The comment extends to the end of the current input record and'
write(io,'(a)')'   may contain any graphic character in the processor-dependent character set. The comment is ignored. A slash'
write(io,'(a)')'   within the namelist comment does not terminate execution of the namelist input statement. Namelist comments'
write(io,'(a)')'   are not allowed in stream input because comments depend on record structure.'
write(io,'(a)')''
write(io,'(a)')'        NOTE 10.38'
write(io,'(a)')'        Namelist input example:'
write(io,'(a)')''
write(io,'(a)')'        INTEGER I; REAL X (8); CHARACTER (11) P; COMPLEX Z;'
write(io,'(a)')'        LOGICAL :: G'
write(io,'(a)')'        NAMELIST / TODAY / G, I, P, Z, X'
write(io,'(a)')'        READ (*, NML = TODAY)'
write(io,'(a)')''
write(io,'(a)')'        The input data records are:'
write(io,'(a)')''
write(io,'(a)')'        &TODAY I = 12345, X(1) = 12345, X(3:4) = 2*1.5, I=6, ! This is a comment.'
write(io,'(a)')'        P = ''''ISN''T_BOB''S'''', Z = (123,0)/'
write(io,'(a)')''
write(io,'(a)')'        The results stored are:'
write(io,'(a)')''
write(io,'(a)')'                Variable                         Value'
write(io,'(a)')'                I                                6'
write(io,'(a)')'                X (1)                            12345.0'
write(io,'(a)')'                X (2)                            unchanged'
write(io,'(a)')'                X (3)                            1.5'
write(io,'(a)')'                X (4)                            1.5'
write(io,'(a)')'                X (5)   X (8)                    unchanged'
write(io,'(a)')'                P                                ISN''T BOB''S'
write(io,'(a)')'                Z                                (123.0,0.0)'
write(io,'(a)')'                G                                unchanged'
write(io,'(a)')''
write(io,'(a)')'  10.11.4      Namelist output'
write(io,'(a)')'  10.11.4.1    Form of namelist output'
write(io,'(a)')''
write(io,'(a)')'1. The form of the output produced is the same as that required for input, except for the forms of real, character,'
write(io,'(a)')'   and logical values. The name in the output is in upper case. With the exception of adjacent undelimited characte&
   &r'
write(io,'(a)')'   values, the values are separated by one or more blanks or by a comma, or a semicolon if the decimal edit mode'
write(io,'(a)')'   is COMMA, optionally preceded by one or more blanks and optionally followed by one or more blanks.'
write(io,'(a)')''
write(io,'(a)')'2. Namelist output shall not include namelist comments.'
write(io,'(a)')''
write(io,'(a)')'3. The processor may begin new records as necessary. However, except for complex constants and character values,'
write(io,'(a)')'   the end of a record shall not occur within a constant, character value, or name, and blanks shall not appear'
write(io,'(a)')'   within a constant, character value, or name.'
write(io,'(a)')''
write(io,'(a)')'        NOTE 10.39'
write(io,'(a)')'        The length of the output records is not specified exactly and may be processor dependent.'
write(io,'(a)')''
write(io,'(a)')'10.11.4.2    Namelist output editing'
write(io,'(a)')''
write(io,'(a)')'1. Values in namelist output records are edited as for list-directed output (10.10.4).'
write(io,'(a)')''
write(io,'(a)')'        NOTE 10.40'
write(io,'(a)')'        Namelist output records produced with a DELIM= specifier with a value of NONE and which contain a'
write(io,'(a)')'        character sequence might not be acceptable as namelist input records.'
write(io,'(a)')''
write(io,'(a)')'10.11.4.3    Namelist output records'
write(io,'(a)')''
write(io,'(a)')'1. If two or more successive values for the same namelist group item in an output record produced have identical'
write(io,'(a)')'   values, the processor has the option of producing a repeated constant of the form r *c instead of the sequence o&
   &f'
write(io,'(a)')'   identical values.'
write(io,'(a)')''
write(io,'(a)')'2. The name of each namelist group object list item is placed in the output record followed by an equals and a list'
write(io,'(a)')'   of values of the namelist group object list item.'
write(io,'(a)')''
write(io,'(a)')'3. An ampersand character followed immediately by a namelist-group-name will be produced by namelist formatting'
write(io,'(a)')'   at the start of the first output record to indicate which particular group of data objects is being output. A sl&
   &ash'
write(io,'(a)')'   is produced by namelist formatting to indicate the end of the namelist formatting.'
write(io,'(a)')''
write(io,'(a)')'4. A null value is not produced by namelist formatting.'
write(io,'(a)')''
write(io,'(a)')'5. Except for new records created by explicit formatting within a defined output procedure or by continuation of'
write(io,'(a)')'   delimited character sequences, each output record begins with a blank character.'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     equivalence(7f) - [FORTRAN:INTRINSICS]  used to specify the sharing of storage units by two or more objects in&
   & a storage unit'
write(io,'(a)')'     (LICENSE:PD)'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'     equivalence(object1,object2)'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'  An EQUIVALENCE statement is used to specify the sharing of storage units by two or more objects in a'
write(io,'(a)')'  scoping unit. This causes storage association (16.5.3) of the objects that share the storage units.'
write(io,'(a)')''
write(io,'(a)')'  If the equivalenced objects have differing type or type parameters, the EQUIVALENCE statement does not cause'
write(io,'(a)')'  type conversion or imply mathematical equivalence. If a scalar and an array are equivalenced, the scalar does'
write(io,'(a)')'  not have array properties and the array does not have the properties of a scalar.'
write(io,'(a)')''
write(io,'(a)')'     R565      equivalence-stmt             is   EQUIVALENCE equivalence-set-list'
write(io,'(a)')''
write(io,'(a)')'     R566      equivalence-set              is   ( equivalence-object , equivalence-object-list )'
write(io,'(a)')''
write(io,'(a)')'     R567      equivalence-object           is variable-name'
write(io,'(a)')'                                            or array-element'
write(io,'(a)')'                                            or substring'
write(io,'(a)')''
write(io,'(a)')'     C583      (R567) An equivalence-object shall not be a designator with a base object that is a dummy argument,'
write(io,'(a)')'               a pointer, an allocatable variable, a derived-type object that has an allocatable ultimate component&
   &,'
write(io,'(a)')'               an object of a nonsequence derived type, an object of a derived type that has a pointer at any level&
   & of'
write(io,'(a)')'               component selection, an automatic object, a function name, an entry name, a result name, a variable &
   &with'
write(io,'(a)')'               the BIND attribute, a variable in a common block that has the BIND attribute, or a named constant.'
write(io,'(a)')''
write(io,'(a)')'     C584     (R567) An equivalence-object shall not be a designator that has more than one part-ref .'
write(io,'(a)')''
write(io,'(a)')'     C585     (R567) An equivalence-object shall not be a coarray or a subobject thereof.'
write(io,'(a)')''
write(io,'(a)')'     C586     (R567) An equivalence-object shall not have the TARGET attribute.'
write(io,'(a)')''
write(io,'(a)')'     C587     (R567) Each subscript or substring range expression in an equivalence-object shall be an integer'
write(io,'(a)')'              initialization expression (7.1.12).'
write(io,'(a)')''
write(io,'(a)')'     C588     (R566) If an equivalence-object is default integer, default real, double precision real, default comp&
   &lex,'
write(io,'(a)')'              default logical, or of numeric sequence type, all of the objects in the equivalence set shall be of t&
   &hese'
write(io,'(a)')'              types.'
write(io,'(a)')''
write(io,'(a)')'     C589     (R566) If an equivalence-object is default character or of character sequence type, all of the object&
   &s in'
write(io,'(a)')'              the equivalence set shall be of these types and kinds.'
write(io,'(a)')''
write(io,'(a)')'     C590     (R566) If an equivalence-object is of a sequence type that is not a numeric sequence or character seq&
   &uence'
write(io,'(a)')'              type, all of the objects in the equivalence set shall be of the same type with the same type paramete&
   &r'
write(io,'(a)')'              values.'
write(io,'(a)')''
write(io,'(a)')'     C591     (R566) If an equivalence-object is of an intrinsic type but is not default integer, default real, dou&
   &ble'
write(io,'(a)')'              precision real, default complex, default logical, or default character, all of the objects in the equ&
   &ivalence'
write(io,'(a)')'              set shall be of the same type with the same kind type parameter value.'
write(io,'(a)')''
write(io,'(a)')'     C592     (R567) If an equivalence-object has the PROTECTED attribute, all of the objects in the equivalence se&
   &t'
write(io,'(a)')'              shall have the PROTECTED attribute.'
write(io,'(a)')''
write(io,'(a)')'     C593     (R567) The name of an equivalence-object shall not be a name made accessible by use association.'
write(io,'(a)')''
write(io,'(a)')'     C594     (R567) A substring shall not have length zero.'
write(io,'(a)')''
write(io,'(a)')'   NOTE 5.40'
write(io,'(a)')''
write(io,'(a)')'   The EQUIVALENCE statement allows the equivalencing of sequence structures and the equivalencing of'
write(io,'(a)')'   objects of intrinsic type with nondefault type parameters, but there are strict rules regarding the appearance'
write(io,'(a)')'   of these objects in an EQUIVALENCE statement.'
write(io,'(a)')''
write(io,'(a)')'   A structure that appears in an EQUIVALENCE statement shall be a sequence structure. If a sequence'
write(io,'(a)')'   structure is not of numeric sequence type or of character sequence type, it shall be equivalenced only to'
write(io,'(a)')'   objects of the same type with the same type parameter values.'
write(io,'(a)')''
write(io,'(a)')'   A structure of a numeric sequence type shall be equivalenced only to another structure of a numeric sequence'
write(io,'(a)')'   type, an object that is default integer, default real, double precision real, default complex, or default logica&
   &l'
write(io,'(a)')'   type such that components of the structure ultimately become associated only with objects of these types'
write(io,'(a)')'   and kinds.'
write(io,'(a)')''
write(io,'(a)')'   A structure of a character sequence type shall be equivalenced only to an object of default character type'
write(io,'(a)')'   or another structure of a character sequence type.'
write(io,'(a)')''
write(io,'(a)')'   An object of intrinsic type with nondefault kind type parameters shall not be equivalenced to objects of'
write(io,'(a)')'   different type or kind type parameters.'
write(io,'(a)')''
write(io,'(a)')'   Further rules on the interaction of EQUIVALENCE statements and default initialization are given in'
write(io,'(a)')'   16.5.3.4.'
write(io,'(a)')''
write(io,'(a)')'  5.7.1.2   Equivalence association'
write(io,'(a)')''
write(io,'(a)')'  An EQUIVALENCE statement specifies that the storage sequences (16.5.3.2) of the data objects specified in an'
write(io,'(a)')'  equivalence-set are storage associated. All of the nonzero-sized sequences in the equivalence-set, if any, have t&
   &he'
write(io,'(a)')'  same first storage unit, and all of the zero-sized sequences in the equivalence-set, if any, are storage associat&
   &ed with'
write(io,'(a)')'  one another and with the first storage unit of any nonzero-sized sequences. This causes the storage association'
write(io,'(a)')'  of the data objects in the equivalence-set and may cause storage association of other data objects.'
write(io,'(a)')''
write(io,'(a)')'  5.7.1.3   Equivalence of default character objects'
write(io,'(a)')''
write(io,'(a)')'  A default character data object shall not be equivalenced to an object that is not default character and not of a'
write(io,'(a)')'  character sequence type. The lengths of equivalenced default character objects need not be the same.'
write(io,'(a)')''
write(io,'(a)')'  An EQUIVALENCE statement specifies that the storage sequences of all the default character data objects'
write(io,'(a)')'  specified in an equivalence-set are storage associated. All of the nonzero-sized sequences in the equivalence-set&
   &, if'
write(io,'(a)')'  any, have the same first character storage unit, and all of the zero-sized sequences in the equivalence-set, if a&
   &ny,'
write(io,'(a)')'  are storage associated with one another and with the first character storage unit of any nonzero-sized sequences.'
write(io,'(a)')'  This causes the storage association of the data objects in the equivalence-set and may cause storage association'
write(io,'(a)')'  of other data objects.'
write(io,'(a)')''
write(io,'(a)')'       NOTE 5.41'
write(io,'(a)')'       For example, using the declarations:'
write(io,'(a)')''
write(io,'(a)')'       CHARACTER (LEN = 4) :: A, B'
write(io,'(a)')'       CHARACTER (LEN = 3) :: C (2)'
write(io,'(a)')'       EQUIVALENCE (A, C (1)), (B, C (2))'
write(io,'(a)')''
write(io,'(a)')'       the association of A, B, and C can be illustrated graphically as:'
write(io,'(a)')''
write(io,'(a)')'          1        2        3        4         5        6        7'
write(io,'(a)')'        |---      --- A    ---      ---|'
write(io,'(a)')'                                   |---      --- B    ---      ---|'
write(io,'(a)')'        |---      C(1)     ---|    |---      C(2)     ---|'
write(io,'(a)')''
write(io,'(a)')'  5.7.1.4   Array names and array element designators'
write(io,'(a)')''
write(io,'(a)')'  For a nonzero-sized array, the use of the array name unqualified by a subscript list as an equivalence-object has'
write(io,'(a)')'  the same effect as using an array element designator that identifies the first element of the array.'
write(io,'(a)')''
write(io,'(a)')'  5.7.1.5   Restrictions on EQUIVALENCE statements'
write(io,'(a)')''
write(io,'(a)')'  An EQUIVALENCE statement shall not specify that the same storage unit is to occur more than once in a'
write(io,'(a)')'  storage sequence.'
write(io,'(a)')''
write(io,'(a)')'       NOTE 5.42'
write(io,'(a)')'       For example:'
write(io,'(a)')''
write(io,'(a)')'       REAL, DIMENSION (2) :: A'
write(io,'(a)')'       REAL :: B'
write(io,'(a)')'       EQUIVALENCE (A(1), B), (A(2), B) ! Not standard-conforming'
write(io,'(a)')''
write(io,'(a)')'       is prohibited, because it would specify the same storage unit for A (1) and A (2).'
write(io,'(a)')''
write(io,'(a)')'  An EQUIVALENCE statement shall not specify that consecutive storage units are to be nonconsecutive.'
write(io,'(a)')''
write(io,'(a)')'        NOTE 5.43'
write(io,'(a)')'        For example, the following is prohibited:'
write(io,'(a)')''
write(io,'(a)')'        REAL A (2)'
write(io,'(a)')'        DOUBLE PRECISION D (2)'
write(io,'(a)')'        EQUIVALENCE (A(1), D(1)), (A(2), D(2)) ! Not standard-conforming'
write(io,'(a)')''
write(io,'(a)')'  5.7.3     Restrictions on common and equivalence'
write(io,'(a)')''
write(io,'(a)')'  An EQUIVALENCE statement shall not cause the storage sequences of two different common blocks to be'
write(io,'(a)')'  associated.'
write(io,'(a)')''
write(io,'(a)')'  Equivalence association shall not cause a derived-type object with default initialization to be associated with a&
   &n'
write(io,'(a)')'  object in a common block.'
write(io,'(a)')''
write(io,'(a)')'  Equivalence association shall not cause a common block storage sequence to be extended by adding storage units'
write(io,'(a)')'  preceding the first storage unit of the first object specified in a COMMON statement for the common block.'
write(io,'(a)')''
write(io,'(a)')'        NOTE 5.46'
write(io,'(a)')'        For example, the following is not permitted:'
write(io,'(a)')''
write(io,'(a)')'        COMMON /X/ A'
write(io,'(a)')'        REAL B (2)'
write(io,'(a)')'        EQUIVALENCE (A, B(2))          ! Not standard-conforming'
write(io,'(a)')'NAME'
write(io,'(a)')'   common(7f) - [FORTRAN:INTRINSICS] specifies blocks of variables that can be accessed by any scoping unit in the &
   &program'
write(io,'(a)')'   (LICENSE:PD)'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'   common /common-block-name/ variables, /common-block-name/ variables, ...'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'  The COMMON statement specifies blocks of physical storage, called common blocks, that can be accessed by'
write(io,'(a)')'  any of the scoping units in a program. Thus, the COMMON statement provides a global data facility based on'
write(io,'(a)')'  storage association (16.5.3).'
write(io,'(a)')''
write(io,'(a)')'  A common block that does not have a name is called blank common.'
write(io,'(a)')''
write(io,'(a)')'  R568      common-stmt                  is   COMMON'
write(io,'(a)')'                                                [ / [ common-block-name ] / ] common-block-object-list'
write(io,'(a)')'                                                [ [ , ] / [ common-block-name ] /'
write(io,'(a)')'                                                common-block-object-list ] ...'
write(io,'(a)')''
write(io,'(a)')'  R569      common-block-object          is variable-name [ ( array-spec ) ]'
write(io,'(a)')'                                         or proc-pointer-name'
write(io,'(a)')''
write(io,'(a)')'  C595      (R569) An array-spec in a common-block-object shall be an explicit-shape-spec-list.'
write(io,'(a)')''
write(io,'(a)')'  C596      (R569) Only one appearance of a given variable-name or proc-pointer-name is permitted in all'
write(io,'(a)')'            common-block-object-lists within a scoping unit.'
write(io,'(a)')''
write(io,'(a)')'  C597      (R569) A common-block-object shall not be a dummy argument, an allocatable variable, a derived-type'
write(io,'(a)')'            object with an ultimate component that is allocatable, an automatic object, a function name, an entry'
write(io,'(a)')'            name, a variable with the BIND attribute, a coarray, or a result name.'
write(io,'(a)')''
write(io,'(a)')'  C598      (R569) If a common-block-object is of a derived type, the type shall have the BIND attribute or the'
write(io,'(a)')'            SEQUENCE attribute and it shall have no default initialization.'
write(io,'(a)')''
write(io,'(a)')'  C599      (R569) A variable-name or proc-pointer-name shall not be a name made accessible by use association.'
write(io,'(a)')''
write(io,'(a)')'  In each COMMON statement, the data objects whose names appear in a common block object list following a'
write(io,'(a)')'  common block name are declared to be in that common block. If the first common block name is omitted, all'
write(io,'(a)')'  data objects whose names appear in the first common block object list are specified to be in blank common.'
write(io,'(a)')'  Alternatively, the appearance of two slashes with no common block name between them declares the data objects'
write(io,'(a)')'  whose names appear in the common block object list that follows to be in blank common.'
write(io,'(a)')''
write(io,'(a)')'  Any common block name or an omitted common block name for blank common may occur more than once in one'
write(io,'(a)')'  or more COMMON statements in a scoping unit. The common block list following each successive appearance'
write(io,'(a)')'  of the same common block name in a scoping unit is treated as a continuation of the list for that common block'
write(io,'(a)')'  name. Similarly, each blank common block object list in a scoping unit is treated as a continuation of blank'
write(io,'(a)')'  common.'
write(io,'(a)')''
write(io,'(a)')'  The form variable-name (array-spec) specifies the DIMENSION attribute for that variable.'
write(io,'(a)')''
write(io,'(a)')'  If derived-type objects of numeric sequence type (4.5.2) or character sequence type (4.5.2) appear in common, it'
write(io,'(a)')'  is as if the individual components were enumerated directly in the common list.'
write(io,'(a)')''
write(io,'(a)')'       NOTE 5.44'
write(io,'(a)')'       Examples of COMMON statements are:'
write(io,'(a)')''
write(io,'(a)')'       COMMON /BLOCKA/ A, B, D (10, 30)'
write(io,'(a)')'       COMMON I, J, K'
write(io,'(a)')''
write(io,'(a)')'  5.7.2.2      Common block storage sequence'
write(io,'(a)')''
write(io,'(a)')'  For each common block in a scoping unit, a common block storage sequence is formed as follows:'
write(io,'(a)')''
write(io,'(a)')'         (1)     A storage sequence is formed consisting of the sequence of storage units in the storage sequences'
write(io,'(a)')'                 (16.5.3.2) of all data objects in the common block object lists for the common block. The order of'
write(io,'(a)')'                 the storage sequences is the same as the order of the appearance of the common block object lists &
   &in'
write(io,'(a)')'                 the scoping unit.'
write(io,'(a)')'         (2)     The storage sequence formed in (1) is extended to include all storage units of any storage sequenc&
   &e'
write(io,'(a)')'                 associated with it by equivalence association. The sequence shall be extended only by adding stora&
   &ge'
write(io,'(a)')'                 units beyond the last storage unit. Data objects associated with an entity in a common block are'
write(io,'(a)')'                 considered to be in that common block.'
write(io,'(a)')''
write(io,'(a)')'  Only COMMON statements and EQUIVALENCE statements appearing in the scoping unit contribute to common'
write(io,'(a)')'  block storage sequences formed in that scoping unit.'
write(io,'(a)')''
write(io,'(a)')'  5.7.2.3      Size of a common block'
write(io,'(a)')''
write(io,'(a)')'  The size of a common block is the size of its common block storage sequence, including any extensions of the'
write(io,'(a)')'  sequence resulting from equivalence association.'
write(io,'(a)')''
write(io,'(a)')'  5.7.2.4      Common association'
write(io,'(a)')''
write(io,'(a)')'  Within a program, the common block storage sequences of all nonzero-sized common blocks with the same name'
write(io,'(a)')'  have the same first storage unit, and the common block storage sequences of all zero-sized common blocks with the'
write(io,'(a)')'  same name are storage associated with one another. Within a program, the common block storage sequences of'
write(io,'(a)')'  all nonzero-sized blank common blocks have the same first storage unit and the storage sequences of all zero-size&
   &d'
write(io,'(a)')'  blank common blocks are associated with one another and with the first storage unit of any nonzero-sized blank'
write(io,'(a)')'  common blocks. This results in the association of objects in different scoping units. Use or host association may'
write(io,'(a)')'  cause these associated objects to be accessible in the same scoping unit.'
write(io,'(a)')''
write(io,'(a)')'  A nonpointer object that is default integer, default real, double precision real, default complex, default logica&
   &l,'
write(io,'(a)')'  or of numeric sequence type shall be associated only with nonpointer objects of these types and kinds.'
write(io,'(a)')''
write(io,'(a)')'  A nonpointer object that is default character or of character sequence type shall be associated only with nonpoin&
   &ter'
write(io,'(a)')'  objects of these types and kinds.'
write(io,'(a)')''
write(io,'(a)')'  A nonpointer object of a derived type that is not a numeric sequence or character sequence type shall be associat&
   &ed'
write(io,'(a)')'  only with nonpointer objects of the same type with the same type parameter values.'
write(io,'(a)')''
write(io,'(a)')'  A nonpointer object of intrinsic type but which is not default integer, default real, double precision real, defa&
   &ult'
write(io,'(a)')'  complex, default logical, or default character shall be associated only with nonpointer objects of the same type'
write(io,'(a)')'  and type parameters.'
write(io,'(a)')''
write(io,'(a)')'  A data pointer shall be storage associated only with data pointers of the same type and rank. Data pointers that'
write(io,'(a)')'  are storage associated shall have deferred the same type parameters; corresponding nondeferred type parameters'
write(io,'(a)')'  shall have the same value. A procedure pointer shall be storage associated only with another procedure pointer;'
write(io,'(a)')'  either both interfaces shall be explicit or both interfaces shall be implicit. If the interfaces are explicit, th&
   &e'
write(io,'(a)')'  characteristics shall be the same. If the interfaces are implicit, either both shall be subroutines or both shall&
   & be'
write(io,'(a)')'  functions with the same type and type parameters.'
write(io,'(a)')''
write(io,'(a)')'  An object with the TARGET attribute shall be storage associated only with another object that has the TARGET'
write(io,'(a)')'  attribute and the same type and type parameters.'
write(io,'(a)')''
write(io,'(a)')'        NOTE 5.45'
write(io,'(a)')'        A common block is permitted to contain sequences of different storage units, provided each scoping unit'
write(io,'(a)')'        that accesses the common block specifies an identical sequence of storage units for the common block. For'
write(io,'(a)')'        example, this allows a single common block to contain both numeric and character storage units.'
write(io,'(a)')''
write(io,'(a)')'        Association in different scoping units between objects of default type, objects of double precision real ty&
   &pe,'
write(io,'(a)')'        and sequence structures is permitted according to the rules for equivalence objects (5.7.1).'
write(io,'(a)')''
write(io,'(a)')'  5.7.2.5   Differences between named common and blank common'
write(io,'(a)')''
write(io,'(a)')'  A blank common block has the same properties as a named common block, except for the following.'
write(io,'(a)')''
write(io,'(a)')'       Execution of a RETURN or END statement might cause data objects in a named common block to become'
write(io,'(a)')'        undefined unless the common block has the SAVE attribute, but never causes data objects in blank common'
write(io,'(a)')'        to become undefined (16.6.6).'
write(io,'(a)')'       Named common blocks of the same name shall be of the same size in all scoping units of a program in which'
write(io,'(a)')'        they appear, but blank common blocks may be of different sizes.'
write(io,'(a)')'       A data object in a named common block may be initially defined by means of a DATA statement or type'
write(io,'(a)')'        declaration statement in a block data program unit (11.3), but objects in blank common shall not be initial&
   &ly'
write(io,'(a)')'        defined.'
write(io,'(a)')''
write(io,'(a)')'  5.7.3     Restrictions on common and equivalence'
write(io,'(a)')''
write(io,'(a)')'  An EQUIVALENCE statement shall not cause the storage sequences of two different common blocks to be'
write(io,'(a)')'  associated.'
write(io,'(a)')''
write(io,'(a)')'  Equivalence association shall not cause a derived-type object with default initialization to be associated with a&
   &n'
write(io,'(a)')'  object in a common block.'
write(io,'(a)')''
write(io,'(a)')'  Equivalence association shall not cause a common block storage sequence to be extended by adding storage units'
write(io,'(a)')'  preceding the first storage unit of the first object specified in a COMMON statement for the common block.'
write(io,'(a)')''
write(io,'(a)')'        NOTE 5.46'
write(io,'(a)')'        For example, the following is not permitted:'
write(io,'(a)')''
write(io,'(a)')'        COMMON /X/ A'
write(io,'(a)')'        REAL B (2)'
write(io,'(a)')'        EQUIVALENCE (A, B(2))          ! Not standard-conforming'
write(io,'(a)')'NAME'
write(io,'(a)')'    pure(7f) - [FORTRAN:SPECIFICATION ATTRIBUTE] Pure procedures'
write(io,'(a)')'    (LICENSE:PD)'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'    pure subroutine()'
write(io,'(a)')'    pure function()'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'  A pure procedure is'
write(io,'(a)')''
write(io,'(a)')'     o a pure intrinsic procedure (13.1), defined by a pure subprogram,'
write(io,'(a)')'     o a dummy procedure that has been specified to be PURE, or'
write(io,'(a)')'     o a statement function that references only pure functions.'
write(io,'(a)')''
write(io,'(a)')'  A pure subprogram is a subprogram that has the prefix-spec PURE, or'
write(io,'(a)')'  has the prefix-spec ELEMENTAL and does not have the prefix-spec'
write(io,'(a)')'  IMPURE. The following additional constraints apply to pure subprograms.'
write(io,'(a)')''
write(io,'(a)')'    o  The specification-part of a pure function subprogram shall specify'
write(io,'(a)')'       that all its nonpointer dummy data objects have INTENT(IN).'
write(io,'(a)')''
write(io,'(a)')'    o  The specification-part of a pure subroutine subprogram shall'
write(io,'(a)')'       specify the intents of all its nonpointer dummy data objects.'
write(io,'(a)')''
write(io,'(a)')'    o  A local variable of a pure subprogram, or of a BLOCK construct'
write(io,'(a)')'       within a pure subprogram, shall not have the SAVE attribute.'
write(io,'(a)')''
write(io,'(a)')'       Variable initialization in a type-declaration-stmt or a data-stmt'
write(io,'(a)')'       implies the SAVE attribute; therefore, such initialization is'
write(io,'(a)')'       also disallowed.'
write(io,'(a)')''
write(io,'(a)')'    o  The specification-part of a pure subprogram shall specify that'
write(io,'(a)')'       all its dummy procedures are pure.'
write(io,'(a)')''
write(io,'(a)')'    o  If a procedure that is neither an intrinsic procedure nor a'
write(io,'(a)')'       statement function is used in a context that requires'
write(io,'(a)')'       it to be pure, then its interface shall be explicit in the scope of'
write(io,'(a)')'       that use. The interface shall specify that the procedure is pure.'
write(io,'(a)')''
write(io,'(a)')'    o  All internal subprograms in a pure subprogram shall be pure.'
write(io,'(a)')''
write(io,'(a)')'    o  In a pure subprogram any designator with a base object that is'
write(io,'(a)')'       in common or accessed by host or use'
write(io,'(a)')'       association, is a dummy argument of a pure function, is a dummy'
write(io,'(a)')'       argument with INTENT(IN) of a pure subroutine, is a coindexed'
write(io,'(a)')'       object, or an object that is storage associated with any such'
write(io,'(a)')'       variable, shall not be used'
write(io,'(a)')''
write(io,'(a)')'       1. in a variable definition context (16.6.7),'
write(io,'(a)')'       2. as the data-target in a pointer-assignment-stmt,'
write(io,'(a)')'       3. as the expr corresponding to a component with the POINTER'
write(io,'(a)')'          attribute in a structure-constructor ,'
write(io,'(a)')'       4. as the expr of an intrinsic assignment statement in which'
write(io,'(a)')'          the variable is of a derived type if the derived type has a'
write(io,'(a)')'          pointer component at any level of component selection, or'
write(io,'(a)')'       5. as an actual argument corresponding to a dummy argument with'
write(io,'(a)')'          INTENT(OUT) or INTENT(INOUT) or with the POINTER attribute.'
write(io,'(a)')''
write(io,'(a)')'     NOTE 12.50'
write(io,'(a)')'     Item 3 requires that processors be able to determine if entities'
write(io,'(a)')'     with the PRIVATE attribute or with private components have a'
write(io,'(a)')'     pointer component.'
write(io,'(a)')''
write(io,'(a)')'    o   Any procedure referenced in a pure subprogram, including one'
write(io,'(a)')'        referenced via a defined operation, defined assignment, defined'
write(io,'(a)')'        input/output, or finalization, shall be pure.'
write(io,'(a)')''
write(io,'(a)')'    o   A pure subprogram shall not contain a print-stmt, open-stmt,'
write(io,'(a)')'        close-stmt, backspace-stmt, endfile-stmt, rewind-stmt, flush-stmt,'
write(io,'(a)')'        wait-stmt, or inquire-stmt.'
write(io,'(a)')''
write(io,'(a)')'    o   A pure subprogram shall not contain a read-stmt or write-stmt'
write(io,'(a)')'        whose io-unit is a file-unit-number or *.'
write(io,'(a)')''
write(io,'(a)')'    o   A pure subprogram shall not contain a stop-stmt or allstop-stmt.'
write(io,'(a)')''
write(io,'(a)')'    o   A pure subprogram shall not contain an image control statement'
write(io,'(a)')'        (8.5.1).'
write(io,'(a)')''
write(io,'(a)')'     NOTE 12.51'
write(io,'(a)')''
write(io,'(a)')'     The above constraints are designed to guarantee that a pure procedure'
write(io,'(a)')'     is free from side effects (modifications of data visible outside'
write(io,'(a)')'     the procedure), which means that it is safe to reference it in'
write(io,'(a)')'     constructs such as a FORALL assignment-stmt or a DO CONCURRENT'
write(io,'(a)')'     construct, where there is no explicit order of evaluation.'
write(io,'(a)')''
write(io,'(a)')'     The constraints on pure subprograms may appear complicated, but it'
write(io,'(a)')'     is not necessary for a programmer to be intimately familiar with'
write(io,'(a)')'     them. From the programmer''s point of view, these constraints can'
write(io,'(a)')'     be summarized as follows: a pure subprogram shall not contain any'
write(io,'(a)')'     operation that could conceivably result in an assignment or pointer'
write(io,'(a)')'     assignment to a common variable, a variable accessed by use or host'
write(io,'(a)')'     association, or an INTENT (IN) dummy argument; nor shall a pure'
write(io,'(a)')'     subprogram contain any operation that could conceivably perform any'
write(io,'(a)')'     external file input/output or STOP operation. Note the use of the'
write(io,'(a)')'     word conceivably; it is not sufficient for a pure subprogram merely'
write(io,'(a)')'     to be side-effect free in practice. For example, a function that'
write(io,'(a)')'     contains an assignment to a global variable but in a block that'
write(io,'(a)')'     is not executed in any invocation of the function is nevertheless'
write(io,'(a)')'     not a pure function. The exclusion of functions of this nature is'
write(io,'(a)')'     required if strict compile-time checking is to be used.'
write(io,'(a)')''
write(io,'(a)')'     It is expected that most library procedures will conform to the'
write(io,'(a)')'     constraints required of pure procedures, and so can be declared pure'
write(io,'(a)')'     and referenced in FORALL statements and constructs, DO CONCURRENT'
write(io,'(a)')'     constructs, and within user-defined pure procedures.'
write(io,'(a)')''
write(io,'(a)')'     NOTE 12.52'
write(io,'(a)')''
write(io,'(a)')'     Pure subroutines are included to allow subroutine calls from pure'
write(io,'(a)')'     procedures in a safe way, and to allow forall-assignment-stmts to'
write(io,'(a)')'     be defined assignments. The constraints for pure subroutines are'
write(io,'(a)')'     based on the same principles as for pure functions, except that'
write(io,'(a)')'     side effects to INTENT (OUT), INTENT (INOUT), and pointer dummy'
write(io,'(a)')'     arguments are permitted.'
write(io,'(a)')'NAME'
write(io,'(a)')'  STOP(7f),ALLSTOP(7f)  - [FORTRAN:STATEMENT] initiates termination of execution'
write(io,'(a)')'  (LICENSE:PD)'
write(io,'(a)')''
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'  STOP [ stop-code ]'
write(io,'(a)')'  ALL STOP [ stop-code ]'
write(io,'(a)')''
write(io,'(a)')'  stop-code    is  scalar-char-initialization-expr'
write(io,'(a)')'               or  scalar-int-initialization-expr'
write(io,'(a)')''
write(io,'(a)')'  The scalar-char-initialization-expr shall be of default kind.'
write(io,'(a)')''
write(io,'(a)')'  The scalar-int-initialization-expr shall be of default kind.'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'  Execution of a STOP statement initiates normal termination of execution. Execution of an ALL STOP'
write(io,'(a)')'  statement initiates error termination of execution.'
write(io,'(a)')''
write(io,'(a)')'  When an image is terminated by a STOP or ALL STOP statement, its stop code, if any, is made available in a'
write(io,'(a)')'  processor-dependent manner. If any exception is signaling on that image, the processor shall issue a warning'
write(io,'(a)')'  indicating which exceptions are signaling; this warning shall be on the unit identified by the named constant'
write(io,'(a)')'  ERROR_UNIT. It is recommended that the stop code is made available by formatted output to the same unit.'
write(io,'(a)')''
write(io,'(a)')'  When normal termination occurs on more than one image, it is expected that a processor-dependent summary'
write(io,'(a)')'  of any stop codes and signaling exceptions will be made available.'
write(io,'(a)')''
write(io,'(a)')'  If the stop-code is an integer, it is recommended that the value also be used as the process exit status, if the'
write(io,'(a)')'  processor supports that concept. If the integer stop-code is used as the process exit status, the processor'
write(io,'(a)')'  might be able to interpret only values within a limited range, or only a limited portion of the integer value'
write(io,'(a)')'  (for example, only the least-significant 8 bits).'
write(io,'(a)')''
write(io,'(a)')'  If the stop-code is of type character or does not appear, or if an END PROGRAM statement is executed,'
write(io,'(a)')'  it is recommended that the value zero be supplied as the process exit status, if the processor supports that'
write(io,'(a)')'  concept.'
write(io,'(a)')'NAME'
write(io,'(a)')'    include(7f) - [FORTRAN] including source text'
write(io,'(a)')'    (LICENSE:PD)'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'    INCLUDE char-literal-constant'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'  Additional text may be incorporated into the source text of a program'
write(io,'(a)')'  unit during processing. This is accomplished with the INCLUDE line,'
write(io,'(a)')'  which has the form'
write(io,'(a)')''
write(io,'(a)')'         INCLUDE char-literal-constant'
write(io,'(a)')''
write(io,'(a)')'  An INCLUDE line is not a Fortran statement.'
write(io,'(a)')''
write(io,'(a)')'  The char-literal-constant shall not have a kind type parameter value'
write(io,'(a)')'  that is a named-constant.'
write(io,'(a)')'  The interpretation of char-literal-constant is processor dependent. An'
write(io,'(a)')'  example of a possible valid interpretation is that char-literal-constant'
write(io,'(a)')'  is the name of a file that contains the source text to be included.'
write(io,'(a)')''
write(io,'(a)')'  An INCLUDE line shall appear on a single source line where a statement'
write(io,'(a)')'  may appear; it shall be the only nonblank text on this line other than'
write(io,'(a)')'  an optional trailing comment. Thus, a statement label is not allowed.'
write(io,'(a)')''
write(io,'(a)')'  The effect of the INCLUDE line is as if the referenced source text'
write(io,'(a)')'  physically replaced the INCLUDE line prior to program'
write(io,'(a)')'  processing. Included text may contain any source text, including'
write(io,'(a)')'  additional INCLUDE lines; such nested INCLUDE lines are similarly'
write(io,'(a)')'  replaced with the specified source text. The maximum depth of nesting'
write(io,'(a)')'  of any nested INCLUDE lines is processor dependent. Inclusion of the'
write(io,'(a)')'  source text referenced by an INCLUDE line shall not, at any level of'
write(io,'(a)')'  nesting, result in inclusion of the same source text.'
write(io,'(a)')''
write(io,'(a)')'  When an INCLUDE line is resolved, the first included statement line'
write(io,'(a)')'  shall not be a continuation line and the last included statement line'
write(io,'(a)')'  shall not be continued.'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'  NOTE'
write(io,'(a)')''
write(io,'(a)')'          In some circumstances, for example where source code is'
write(io,'(a)')'          maintained in an INCLUDE file for use in programs whose source'
write(io,'(a)')'          form might be either fixed or free, observing the following'
write(io,'(a)')'          rules allows the code to be used with either source form.'
write(io,'(a)')''
write(io,'(a)')'          *   Confine statement labels to character positions 1 to'
write(io,'(a)')'              5 and statements to character positions 7 to 72.'
write(io,'(a)')'          *   Treat blanks as being significant.'
write(io,'(a)')'          *   Use only the exclamation mark (!) to indicate'
write(io,'(a)')'              a comment, but do not start the comment in character'
write(io,'(a)')'              position 6.'
write(io,'(a)')'          *   For continued statements, place an ampersand (&) in'
write(io,'(a)')'              both character position 73 of a continued line and character'
write(io,'(a)')'              position 6 of a continuation line.'
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'NAME'
write(io,'(a)')'    scratch(7f) - [FORTRAN:OPEN] where scratch files are typically written by OPEN(3f)'
write(io,'(a)')'    (LICENSE:PD)'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'    open( .... status=''scratch'')'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'    Where files opened with status=''scratch'' are written is implementation-dependent.'
write(io,'(a)')'    Often the file is unlinked so that it goes away unconditionally when the program'
write(io,'(a)')'    starts, so in many *nix environments you cannot see the scratch file that is often'
write(io,'(a)')'    used. So the compiler documentation should be referred to, but typically'
write(io,'(a)')'    a scratch file is opened with a unique filename in one of the following directories:'
write(io,'(a)')''
write(io,'(a)')'      o in the directory pointed to by the environment variable $TMPDIR, if defined.'
write(io,'(a)')'      o next directories pointed to by $TMP and $TEMP are used if the variables are'
write(io,'(a)')'        defined.'
write(io,'(a)')'      o if none of the variables are defined, then the /tmp directory is typically used'
write(io,'(a)')'        on *nix systems, and the current directory is often used on other systems.'
write(io,'(a)')''
write(io,'(a)')'    This can be important if you are generating large scratch files, as you may want'
write(io,'(a)')'    to specify they are created in a secure directory or on a high-speed server such'
write(io,'(a)')'    as a Lustre file server or memory-resident file system. Consider'
write(io,'(a)')''
write(io,'(a)')'      o Scratch files are often opened using the current permission mask'
write(io,'(a)')'        (umask) combined with possible operating-system or kernel defaults'
write(io,'(a)')'        and file-system-dependent attributes, so make sure scratch files are'
write(io,'(a)')'        properly secure'
write(io,'(a)')'      o files are written in an area that you can write to and have sufficient'
write(io,'(a)')'        space in'
write(io,'(a)')'      o that the scratch space provides optimal performance'
write(io,'(a)')'      o make sure the system cleans up properly'
write(io,'(a)')'        when programs are aborted.'
write(io,'(a)')''
write(io,'(a)')'    The behavior is very system-dependent.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE:'
write(io,'(a)')'   System-dependent example:'
write(io,'(a)')''
write(io,'(a)')'    open(newunit=lun,status=''scratch'')'
write(io,'(a)')'    inquire(unit=lun,file=filename)'
write(io,'(a)')'    write(*,*)''filename='',filename)'
write(io,'(a)')'    end'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'initialize_arrays(7f) - [FORTRAN:FAQ] Initializing small 2D numeric arrays with array constructors'
write(io,'(a)')'(LICENSE:PD)'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'Intuitively, one might assume that if one wants to initialize a'
write(io,'(a)')'small array by rows that something like the following will work:'
write(io,'(a)')''
write(io,'(a)')'   ! DOES NOT WORK'
write(io,'(a)')'   integer :: xx(3,5)= [ 1, 2, 3, 4, 5], &'
write(io,'(a)')'                       [10,20,30,40,50], &'
write(io,'(a)')'                       [11,22,33,44,55]'
write(io,'(a)')''
write(io,'(a)')'or perhaps'
write(io,'(a)')''
write(io,'(a)')'   ! DOES NOT WORK'
write(io,'(a)')'   integer :: xx(3,5)= [ [ 1, 2, 3, 4, 5], &'
write(io,'(a)')'                         [10,20,30,40,50], &'
write(io,'(a)')'                         [11,22,33,44,55]  ]'
write(io,'(a)')''
write(io,'(a)')'Someday something simpler might work, but currently the following syntax'
write(io,'(a)')'is required to specify the values in an intuitive row-column sequence'
write(io,'(a)')'using an array constructor:'
write(io,'(a)')''
write(io,'(a)')'   integer,save :: xx(3,5)= reshape([&'
write(io,'(a)')''
write(io,'(a)')'       1, 2, 3, 4, 5, &'
write(io,'(a)')'      10,20,30,40,50, &'
write(io,'(a)')'      11,22,33,44,55  &'
write(io,'(a)')''
write(io,'(a)')'      ],shape(xx),order=[2,1])'
write(io,'(a)')''
write(io,'(a)')'This is because an array constructor can be used to create and assign'
write(io,'(a)')'values only to rank-one arrays. To define arrays of more than one'
write(io,'(a)')'dimension with an array constructor, you must use the RESHAPE(3f) intrinsic'
write(io,'(a)')'function.'
write(io,'(a)')''
write(io,'(a)')'Note that the ORDER= option on RESHAPE(3f) is used to allow the values'
write(io,'(a)')'to be specified in row-column order instead of the default behavior,'
write(io,'(a)')'which fills columns first.'
write(io,'(a)')''
write(io,'(a)')'Also note that if the expressions are of type character, Fortran 95/90'
write(io,'(a)')'requires each expression to have the same character length (there is a'
write(io,'(a)')'common compiler extension that extends all strings to the length of the'
write(io,'(a)')'longest value specified, but depending on it reduces portability).'
write(io,'(a)')''
write(io,'(a)')'## Printing small arrays in row-column format'
write(io,'(a)')''
write(io,'(a)')'When working with small arrays the issue that there is no default Fortran'
write(io,'(a)')'routine for printing an array in row-column order becomes apparent. So'
write(io,'(a)')'lets create a simple solution for integer arrays (PRINT_MATRIX_INT(3f)):'
write(io,'(a)')''
write(io,'(a)')'   program demo_initialize_arrays ! initializing small arrays'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   integer,save :: xx(3,5)= reshape([&'
write(io,'(a)')'     &  1, 2, 3, 4, 5,    &'
write(io,'(a)')'     & 10,20,30,40,50,    &'
write(io,'(a)')'     & 11,22,33,44,-1055  &'
write(io,'(a)')'    ],shape(xx),order=[2,1])'
write(io,'(a)')'   call print_matrix_int(''xx array:'',xx)'
write(io,'(a)')'   contains'
write(io,'(a)')'   subroutine print_matrix_int(title,arr)'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   character(len=*),parameter::ident= "@(#)print_matrix_int(3f) - print small 2d integer arrays in row-column forma&
   &t"'
write(io,'(a)')'   character(len=*),intent(in)  :: title'
write(io,'(a)')'   integer,intent(in)           :: arr(:,:)'
write(io,'(a)')'   integer                      :: i'
write(io,'(a)')'   character(len=:),allocatable :: biggest'
write(io,'(a)')'      write(*,*)trim(title)                                                 ! print title'
write(io,'(a)')'      biggest=''           ''                                                 ! make buffer to write integer into'
write(io,'(a)')'      write(biggest,''(i0)'')ceiling(log10(real(maxval(abs(arr)))))+1         ! find how many characters to use for&
   & integers'
write(io,'(a)')'      biggest=''(" > [",*(i''//trim(biggest)//'':,","))''                       ! use this format to write a row'
write(io,'(a)')'      do i=1,size(arr,dim=1)                                                ! print one row of array at a time'
write(io,'(a)')'         write(*,fmt=biggest,advance=''no'')arr(i,:)'
write(io,'(a)')'         write(*,''(" ]")'')'
write(io,'(a)')'      enddo'
write(io,'(a)')'   end subroutine print_matrix_int'
write(io,'(a)')'   end program demo_initialize_arrays'
write(io,'(a)')''
write(io,'(a)')'Results:'
write(io,'(a)')''
write(io,'(a)')'   xx array:'
write(io,'(a)')'   > [  1,  2,  3,  4,  5 ]'
write(io,'(a)')'   > [ 10, 20, 30, 40, 50 ]'
write(io,'(a)')'   > [ 11, 22, 33, 44, 55 ]'
write(io,'(a)')''
write(io,'(a)')'We could do a more robust version that handles REAL and COMPLEX values'
write(io,'(a)')'as well as NaN values, but it has already been done. If you need to'
write(io,'(a)')'print a variety of small matrices see:'
write(io,'(a)')''
write(io,'(a)')'  dispmodule(3f), "A Fortran 95 module for pretty-printing matrices".'
write(io,'(a)')'  Kristjan Jonasson, Department of Computer Science,'
write(io,'(a)')'  School of Science and Engineering, University of Iceland,'
write(io,'(a)')'  Hjardarhaga 4, 107 Reykjavik, Iceland (jonasson@hi.is).'
write(io,'(a)')''
write(io,'(a)')'#Initializing a 2D array using DATA statements'
write(io,'(a)')''
write(io,'(a)')'Note that DATA statements are very flexible, and allow for perhaps the'
write(io,'(a)')'most intelligible way of specifying small arrays row by row. For example:'
write(io,'(a)')''
write(io,'(a)')'   ! fill rows using DATA statements'
write(io,'(a)')'   integer,save,dimension(3,5) :: gg'
write(io,'(a)')'   data gg(1,:)/  1,  2,  3,  4,  5 /'
write(io,'(a)')'   data gg(2,:)/ 10, 20, 30, 40, 50 /'
write(io,'(a)')'   data gg(3,:)/ 11, 22, 33, 44, 55 /'
write(io,'(a)')''
write(io,'(a)')'There are other ways to use a DATA statement to fill in row-column order,'
write(io,'(a)')'including use of the SIZE(3f) function and an implied-DO:'
write(io,'(a)')''
write(io,'(a)')'   ! use implied-DO so data can be declared in row-column order'
write(io,'(a)')'   integer, dimension(3,5) :: ff'
write(io,'(a)')'   DATA (( ff(J,I), I=1,size(ff,dim=2)), J=1,size(ff,dim=1)) / &'
write(io,'(a)')'      01,02,03,04,05, &'
write(io,'(a)')'      10,20,30,40,50, &'
write(io,'(a)')'      11,22,33,44,55  /'
write(io,'(a)')''
write(io,'(a)')'##Initializing a 2D array from a vector using EQUIVALENCE'
write(io,'(a)')''
write(io,'(a)')'Sometimes instead of using RESHAPE(3f) you will see someone initialize a'
write(io,'(a)')'vector and then equivalence it to a multi-dimensional array; especially'
write(io,'(a)')'if the code has a reason to access the data as both a vector and a matrix:'
write(io,'(a)')''
write(io,'(a)')'   ! multi-dimensional row1, row2, .... by equivalence'
write(io,'(a)')'   integer,parameter :: d1=3,d2=5'
write(io,'(a)')'   integer           :: ee(d1,d2)'
write(io,'(a)')'   ! note that the DATA statements could be used to initialize the array instead'
write(io,'(a)')'   integer           :: e(d1*d2) =[1,10,11, 2,20,22, 3,30,33, 4,40,44, 5,50,55]'
write(io,'(a)')'   equivalence       (e(1),ee(1,1))'
write(io,'(a)')''
write(io,'(a)')'##Notes'
write(io,'(a)')''
write(io,'(a)')'Remember that for simple initializations vector statements can be used'
write(io,'(a)')''
write(io,'(a)')'   real :: arr(10,20)=0.0'
write(io,'(a)')'   ! array constructors can be used to define constants, not just vectors'
write(io,'(a)')'   integer,parameter :: ii(10,10)=[(i,i=1,size(ii))] ! odd numbers using implied-DO'
write(io,'(a)')''
write(io,'(a)')'and that if things are too complicated you can just set the values in the executable'
write(io,'(a)')'body of the code.'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   data(7f) - [FORTRAN] DATA statement'
write(io,'(a)')'   (LICENSE:PD)'
write(io,'(a)')''
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'   data-stmt is   DATA data-stmt-set [ [ , ] data-stmt-set ] ...'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   The DATA statement specifies explicit initialization.'
write(io,'(a)')''
write(io,'(a)')'   If a nonpointer object has default initialization, it shall not appear in a data-stmt-object-list.'
write(io,'(a)')''
write(io,'(a)')'   A variable that appears in a DATA statement and has not been typed previously may appear in a subsequent type'
write(io,'(a)')'   declaration only if that declaration confirms the implicit typing. An array name, array section, or array elemen&
   &t'
write(io,'(a)')'   that appears in a DATA statement shall have had its array properties established by a previous specification'
write(io,'(a)')'   statement.'
write(io,'(a)')''
write(io,'(a)')'   Except for variables in named common blocks, a named variable has the SAVE attribute if any part of it is'
write(io,'(a)')'   initialized in a DATA statement, and this may be confirmed by explicit specification.'
write(io,'(a)')''
write(io,'(a)')'      R535    data-stmt-set                 is   data-stmt-object-list / data-stmt-value-list /'
write(io,'(a)')''
write(io,'(a)')'      R536    data-stmt-object              is variable'
write(io,'(a)')'                                            or data-implied-do'
write(io,'(a)')''
write(io,'(a)')'      R537    data-implied-do               is   ( data-i-do-object-list , data-i-do-variable ='
write(io,'(a)')'                                                    scalar-int-initialization-expr ,'
write(io,'(a)')'                                                    scalar-int-initialization-expr'
write(io,'(a)')'                                                    [ , scalar-int-initialization-expr ] )'
write(io,'(a)')''
write(io,'(a)')'      R538    data-i-do-object              is array-element'
write(io,'(a)')'                                            or scalar-structure-component'
write(io,'(a)')'                                            or data-implied-do'
write(io,'(a)')''
write(io,'(a)')'      R539    data-i-do-variable            is   do-variable'
write(io,'(a)')''
write(io,'(a)')'      C563    A data-stmt-object or data-i-do-object shall not be a coindexed variable.'
write(io,'(a)')''
write(io,'(a)')'      C564    (R536) In a variable that is a data-stmt-object, each subscript, section subscript, substring startin&
   &g point,'
write(io,'(a)')'              and substring ending point shall be an initialization expression.'
write(io,'(a)')''
write(io,'(a)')'      C565    (R536) A variable whose designator appears as a data-stmt-object or a data-i-do-object shall not be a'
write(io,'(a)')'              dummy argument, accessed by use or host association, in a named common block unless the DATA'
write(io,'(a)')'              statement is in a block data program unit, in blank common, a function name, a function result name,'
write(io,'(a)')'              an automatic object, or an allocatable variable.'
write(io,'(a)')''
write(io,'(a)')'      C566    (R536) A data-i-do-object or a variable that appears as a data-stmt-object shall not be an object des&
   &ignator'
write(io,'(a)')'              in which a pointer appears other than as the entire rightmost part-ref .'
write(io,'(a)')''
write(io,'(a)')'      C567    (R538) The array-element shall be a variable.'
write(io,'(a)')''
write(io,'(a)')'      C568    (R538) The scalar-structure-component shall be a variable.'
write(io,'(a)')''
write(io,'(a)')'      C569    (R538) The scalar-structure-component shall contain at least one part-ref that contains a subscript-l&
   &ist.'
write(io,'(a)')''
write(io,'(a)')'      C570    (R538) In an array-element or scalar-structure-component that is a data-i-do-object, any subscript sh&
   &all'
write(io,'(a)')'              be an initialization expression, and any primary within that subscript that is a data-i-do-variable s&
   &hall'
write(io,'(a)')'              be a DO variable of this data-implied-do or of a containing data-implied-do.'
write(io,'(a)')''
write(io,'(a)')'      R540     data-stmt-value               is   [ data-stmt-repeat * ] data-stmt-constant'
write(io,'(a)')''
write(io,'(a)')'      R541     data-stmt-repeat              is scalar-int-constant'
write(io,'(a)')'                                             or scalar-int-constant-subobject'
write(io,'(a)')''
write(io,'(a)')'      C571     (R541) The data-stmt-repeat shall be positive or zero. If the data-stmt-repeat is a named constant, &
   &it'
write(io,'(a)')'               shall have been declared previously in the scoping unit or made accessible by use or host associatio&
   &n.'
write(io,'(a)')''
write(io,'(a)')'      R542     data-stmt-constant            is   scalar-constant'
write(io,'(a)')'                                             or   scalar-constant-subobject'
write(io,'(a)')'                                             or   signed-int-literal-constant'
write(io,'(a)')'                                             or   signed-real-literal-constant'
write(io,'(a)')'                                             or   null-init'
write(io,'(a)')'                                             or   initial-data-target'
write(io,'(a)')'                                             or   structure-constructor'
write(io,'(a)')''
write(io,'(a)')'      C572     (R542) If a DATA statement constant value is a named constant or a structure constructor, the named'
write(io,'(a)')'               constant or derived type shall have been declared previously in the scoping unit or accessed by use &
   &or'
write(io,'(a)')'               host association.'
write(io,'(a)')''
write(io,'(a)')'      C573     (R542) If a data-stmt-constant is a structure-constructor , it shall be an initialization expression&
   &.'
write(io,'(a)')''
write(io,'(a)')'      R543     int-constant-subobject        is   constant-subobject'
write(io,'(a)')''
write(io,'(a)')'      C574     (R543) int-constant-subobject shall be of type integer.'
write(io,'(a)')''
write(io,'(a)')'      R544     constant-subobject            is   designator'
write(io,'(a)')''
write(io,'(a)')'      C575     (R544) constant-subobject shall be a subobject of a constant.'
write(io,'(a)')''
write(io,'(a)')'      C576     (R544) Any subscript, substring starting point, or substring ending point shall be an initialization&
   & expression.'
write(io,'(a)')''
write(io,'(a)')'   The data-stmt-object-list is expanded to form a sequence of pointers and scalar variables, referred to as "seque&
   &nce'
write(io,'(a)')'   of variables" in subsequent text. A nonpointer array whose unqualified name appears as a data-stmt-object or'
write(io,'(a)')'   data-i-do-object is equivalent to a complete sequence of its array elements in array element order (6.5.3.2). An'
write(io,'(a)')'   array section is equivalent to the sequence of its array elements in array element order. A data-implied-do is'
write(io,'(a)')'   expanded to form a sequence of array elements and structure components, under the control of the data-i-do-varia&
   &ble,'
write(io,'(a)')'   as in the DO construct (8.1.7.6).'
write(io,'(a)')''
write(io,'(a)')'   The data-stmt-value-list is expanded to form a sequence of data-stmt-constants. A data-stmt-repeat indicates the'
write(io,'(a)')'   number of times the following data-stmt-constant is to be included in the sequence; omission of a data-stmt-repe&
   &at'
write(io,'(a)')'   has the effect of a repeat factor of 1.'
write(io,'(a)')''
write(io,'(a)')'   A zero-sized array or a data-implied-do with an iteration count of zero contributes no variables to the expanded'
write(io,'(a)')'   sequence of variables, but a zero-length scalar character variable does contribute a variable to the expanded'
write(io,'(a)')'   sequence. A data-stmt-constant with a repeat factor of zero contributes no data-stmt-constants to the expanded'
write(io,'(a)')'   sequence of scalar data-stmt-constants.'
write(io,'(a)')''
write(io,'(a)')'   The expanded sequences of variables and data-stmt-constants are in one-to-one correspondence. Each data-stmt-con&
   &stant'
write(io,'(a)')'   specifies the initial value, initial data target, or null-init for the corresponding variable. The lengths of'
write(io,'(a)')'   the two expanded sequences shall be the same.'
write(io,'(a)')''
write(io,'(a)')'   A data-stmt-constant shall be null-init or initial-data-target if and only if the corresponding data-stmt-object&
   & has'
write(io,'(a)')'   the POINTER attribute. If data-stmt-constant is null-init, the initial association status of the corresponding d&
   &ata'
write(io,'(a)')'   statement object is disassociated. If data-stmt-constant is initial-data-target the corresponding data statement'
write(io,'(a)')'   object shall be data-pointer-initialization compatible with the initial data target; the data statement object i&
   &s'
write(io,'(a)')'   initially associated with the target.'
write(io,'(a)')''
write(io,'(a)')'   A data-stmt-constant other than boz-literal-constant, null-init, or initial-data-target shall be compatible with&
   & its'
write(io,'(a)')'   corresponding variable according to the rules of intrinsic assignment (7.2.1.2). The variable is initially defin&
   &ed'
write(io,'(a)')'   with the value specified by the data-stmt-constant; if necessary, the value is converted according to the rules &
   &of'
write(io,'(a)')'   intrinsic assignment (7.2.1.3) to a value that agrees in type, type parameters, and shape with the variable.'
write(io,'(a)')''
write(io,'(a)')'   If a data-stmt-constant is a boz-literal-constant, the corresponding variable shall be of type integer.'
write(io,'(a)')'   The boz-literal-constant is treated as if it were converted by the intrinsic function INT (13.7.81) to type inte&
   &ger with the'
write(io,'(a)')'   kind type parameter of the variable.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLES'
write(io,'(a)')'   Examples of DATA statements are:'
write(io,'(a)')''
write(io,'(a)')'          CHARACTER (LEN = 10) NAME'
write(io,'(a)')'          INTEGER, DIMENSION (0:9) :: MILES'
write(io,'(a)')'          REAL, DIMENSION (100, 100) :: SKEW'
write(io,'(a)')'          TYPE (NODE), POINTER :: HEAD_OF_LIST'
write(io,'(a)')'          TYPE (PERSON) MYNAME, YOURNAME'
write(io,'(a)')'          DATA NAME / ''JOHN DOE'' /, MILES / 10 * 0 /'
write(io,'(a)')'          DATA ((SKEW (K, J), J = 1, K), K = 1, 100) / 5050 * 0.0 /'
write(io,'(a)')'          DATA ((SKEW (K, J), J = K + 1, 100), K = 1, 99) / 4950 * 1.0 /'
write(io,'(a)')'          DATA HEAD_OF_LIST / NULL() /'
write(io,'(a)')'          DATA MYNAME / PERSON (21, ''JOHN SMITH'') /'
write(io,'(a)')'          DATA YOURNAME % AGE, YOURNAME % NAME / 35, ''FRED BROWN'' /'
write(io,'(a)')''
write(io,'(a)')'   The character variable NAME is initialized with the value JOHN DOE with padding on the right because'
write(io,'(a)')'   the length of the constant is less than the length of the variable. All ten elements of the integer array'
write(io,'(a)')'   MILES are initialized to zero. The two-dimensional array SKEW is initialized so that the lower triangle'
write(io,'(a)')'   of SKEW is zero and the strict upper triangle is one. The structures MYNAME and YOURNAME are'
write(io,'(a)')'   declared using the derived type PERSON from Note 4.17. The pointer HEAD OF LIST is declared using'
write(io,'(a)')'   the derived type NODE from Note 4.37; it is initially disassociated. MYNAME is initialized by a structure'
write(io,'(a)')'   constructor. YOURNAME is initialized by supplying a separate value for each component.'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   CLOSE(7f) - [FORTRAN:IO] terminate the connection of a specified unit to an external file.'
write(io,'(a)')'   (LICENSE:PD)'
write(io,'(a)')''
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'   CLOSE ( [UNIT= ] file-unit-number, [IOSTAT= scalar-int-variable,]'
write(io,'(a)')''
write(io,'(a)')'    [IOMSG= iomsg-variable,] [ERR= label,] [STATUS= scalar-default-char-expr]'
write(io,'(a)')'   )'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   The CLOSE statement is used to terminate the connection of a specified'
write(io,'(a)')'   unit to an external file.'
write(io,'(a)')''
write(io,'(a)')'   Execution of a CLOSE statement for a unit may occur in any program'
write(io,'(a)')'   unit of a program and need not occur in the same program unit as the'
write(io,'(a)')'   execution of an OPEN statement referring to that unit.'
write(io,'(a)')''
write(io,'(a)')'   Execution of a CLOSE statement performs a wait operation for any'
write(io,'(a)')'   pending asynchronous data transfer operations for the specified unit.'
write(io,'(a)')''
write(io,'(a)')'   Execution of a CLOSE statement specifying a unit that does not exist or'
write(io,'(a)')'   has no file connected to it is permitted and affects no file or unit.'
write(io,'(a)')''
write(io,'(a)')'   After a unit has been disconnected by execution of a CLOSE statement,'
write(io,'(a)')'   it may be connected again within the same program, either to the same'
write(io,'(a)')'   file or to a different file. After a named file has been disconnected'
write(io,'(a)')'   by execution of a CLOSE statement, it may be connected again within'
write(io,'(a)')'   the same program, either to the same unit or to a different unit,'
write(io,'(a)')'   provided that the file still exists.'
write(io,'(a)')''
write(io,'(a)')'   The input/output statements are the OPEN, CLOSE, READ, WRITE, PRINT,'
write(io,'(a)')'   BACKSPACE, ENDFILE, REWIND, FLUSH, WAIT, and INQUIRE statements.'
write(io,'(a)')''
write(io,'(a)')'   OPEN, CLOSE, BACKSPACE, ENDFILE, and REWIND statements shall not be'
write(io,'(a)')'   executed while a parent data transfer statement is active.'
write(io,'(a)')''
write(io,'(a)')'   A pure subprogram shall not contain a print-stmt, open-stmt,'
write(io,'(a)')'   close-stmt, backspace-stmt, endfile-stmt, rewind-stmt, flush-stmt,'
write(io,'(a)')'   wait-stmt, or inquire-stmt.'
write(io,'(a)')''
write(io,'(a)')'   The READ statement is a data transfer input statement. The'
write(io,'(a)')'   WRITE statement and the PRINT statement are data transfer output'
write(io,'(a)')'   statements. The OPEN statement and the CLOSE statement are file'
write(io,'(a)')'   connection statements. The INQUIRE statement is a file inquiry'
write(io,'(a)')'   statement. The BACKSPACE, ENDFILE, and REWIND statements are file'
write(io,'(a)')'   positioning statements.'
write(io,'(a)')''
write(io,'(a)')'   All input/output statements may refer to files that exist. An INQUIRE,'
write(io,'(a)')'   OPEN, CLOSE, WRITE, PRINT, REWIND, FLUSH, or ENDFILE statement'
write(io,'(a)')'   also may refer to a file that does not exist. Execution of a WRITE,'
write(io,'(a)')'   PRINT, or ENDFILE statement referring to a preconnected file that'
write(io,'(a)')'   does not exist creates the file. This file is a different file from'
write(io,'(a)')'   one preconnected on any other image.'
write(io,'(a)')''
write(io,'(a)')'   AT PROGRAM TERMINATION'
write(io,'(a)')'   During the completion step of termination of execution of a program,'
write(io,'(a)')'   all units that are connected are closed. Each unit is closed with'
write(io,'(a)')'   status KEEP unless the file status prior to termination of execution'
write(io,'(a)')'   was SCRATCH, in which case the unit is closed with status DELETE.'
write(io,'(a)')''
write(io,'(a)')'     The effect is as though a CLOSE statement without a STATUS='
write(io,'(a)')'     specifier were executed on each connected unit.'
write(io,'(a)')''
write(io,'(a)')'OPTIONS'
write(io,'(a)')'  No specifier shall appear more than once in a given close-spec-list.'
write(io,'(a)')''
write(io,'(a)')'  UNIT=file-unit-number            A file-unit-number shall be specified'
write(io,'(a)')'                                   in a close-spec-list; if the'
write(io,'(a)')'                                   optional characters UNIT= are omitted,'
write(io,'(a)')'                                   the file-unit-number shall be the'
write(io,'(a)')'                                   first item in the close-spec-list.'
write(io,'(a)')'  IOSTAT=scalar-int-variable       0 means no error occurred'
write(io,'(a)')'  IOMSG=iomsg-variable             Character variable to hold message'
write(io,'(a)')'                                   if an error occurred.'
write(io,'(a)')'  ERR=label                        The label used in the ERR= specifier'
write(io,'(a)')'                                   shall be the statement label of a'
write(io,'(a)')'                                   branch target statement that appears'
write(io,'(a)')'                                   in the same scoping unit as the'
write(io,'(a)')'                                   CLOSE statement.'
write(io,'(a)')'  STATUS=scalar-default-char-expr  The expression has a limited list of'
write(io,'(a)')'                                   character values. Any trailing blanks'
write(io,'(a)')'                                   are ignored. The value specified is'
write(io,'(a)')'                                   without regard to case.'
write(io,'(a)')''
write(io,'(a)')'                                   The scalar-default-char-expr shall'
write(io,'(a)')'                                   evaluate to KEEP or DELETE. The'
write(io,'(a)')'                                   STATUS= specifier determines the'
write(io,'(a)')'                                   disposition of the file that is'
write(io,'(a)')'                                   connected to the specified unit. KEEP'
write(io,'(a)')'                                   shall not be specified for a file'
write(io,'(a)')'                                   whose status prior to execution of a'
write(io,'(a)')'                                   CLOSE statement is SCRATCH. If KEEP'
write(io,'(a)')'                                   is specified for a file that exists,'
write(io,'(a)')'                                   the file continues to exist after the'
write(io,'(a)')'                                   execution of a CLOSE statement. If KEEP'
write(io,'(a)')'                                   is specified for a file that does not'
write(io,'(a)')'                                   exist, the file will not exist after'
write(io,'(a)')'                                   the execution of a CLOSE statement. If'
write(io,'(a)')'                                   DELETE is specified, the file will'
write(io,'(a)')'                                   not exist after the execution of a'
write(io,'(a)')'                                   CLOSE statement. If this specifier'
write(io,'(a)')'                                   is omitted, the default value is'
write(io,'(a)')'                                   KEEP, unless the file status prior'
write(io,'(a)')'                                   to execution of the CLOSE statement'
write(io,'(a)')'                                   is SCRATCH, in which case the default'
write(io,'(a)')'                                   value is DELETE.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_close'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   character(len=256) :: message'
write(io,'(a)')'   integer            :: ios'
write(io,'(a)')'      open (10, file=''employee.names'', action=''read'', iostat=ios,iomsg=message)'
write(io,'(a)')'      if (ios < 0) then'
write(io,'(a)')'         ! perform end-of-file processing on the file connected to unit 10.'
write(io,'(a)')''
write(io,'(a)')'         close (10, status=''keep'',iostat=ios,iomsg=message)'
write(io,'(a)')'         if(ios.ne.0)then'
write(io,'(a)')'            write(*,''(*(a))'')''*demo_close* close error: '',trim(message)'
write(io,'(a)')'            stop 1'
write(io,'(a)')'         endif'
write(io,'(a)')'      elseif (ios > 0) then'
write(io,'(a)')'         ! perform error processing on open'
write(io,'(a)')'         write(*,''(*(a))'')''*demo_close* open error: '',trim(message)'
write(io,'(a)')'         stop 2'
write(io,'(a)')'      endif'
write(io,'(a)')'   end program demo_close'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'  wait(7f) - [FORTRAN:IO] statement performs a wait operation for specified pending asynchronous data transfer oper&
   &ations'
write(io,'(a)')'  (LICENSE:PD)'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'    WAIT( [UNIT=] file-unit-number,'
write(io,'(a)')''
write(io,'(a)')'     [END=label,] [EOR=label,] [ERR=label,]'
write(io,'(a)')'     [ID=scalar-int-expr,] [IOMSG=iomsg-variable,] [IOSTAT=scalar-int-variable]'
write(io,'(a)')'     )'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   The WAIT(7f) statement performs a wait operation for specified pending'
write(io,'(a)')'   asynchronous data transfer operations.'
write(io,'(a)')''
write(io,'(a)')'   The CLOSE, INQUIRE, and file positioning statements may also perform'
write(io,'(a)')'   wait operations.'
write(io,'(a)')''
write(io,'(a)')'   Execution of a WAIT statement specifying a unit that does not'
write(io,'(a)')'   exist, has no file connected to it, or is not open for asynchronous'
write(io,'(a)')'   input/output is permitted, provided that the WAIT statement has no ID='
write(io,'(a)')'   specifier; such a WAIT statement does not cause an error or end-of-file'
write(io,'(a)')'   condition to occur.'
write(io,'(a)')''
write(io,'(a)')'   An EOR= specifier has no effect if the pending data transfer operation'
write(io,'(a)')'   is not a nonadvancing read.'
write(io,'(a)')''
write(io,'(a)')'   An END= specifier has no effect if the pending data transfer operation'
write(io,'(a)')'   is not a READ.'
write(io,'(a)')'OPTIONS'
write(io,'(a)')'   No specifier shall appear more than once in a given wait-spec-list.'
write(io,'(a)')''
write(io,'(a)')'    [UNIT=]file-unit-number     A file-unit-number shall be specified'
write(io,'(a)')'                                in a wait-spec-list; if the optional'
write(io,'(a)')'                                characters UNIT= are omitted, the'
write(io,'(a)')'                                file-unit-number shall be the first item'
write(io,'(a)')'                                in the wait-spec-list.'
write(io,'(a)')'    END=label, EOR=label, ERR=label   The label in the ERR=, EOR=,'
write(io,'(a)')'                                      or END= specifier is a statement'
write(io,'(a)')'                                      label of a branch target statement'
write(io,'(a)')'                                      that appears in the same scoping'
write(io,'(a)')'                                      unit as the WAIT statement.'
write(io,'(a)')'    ID=scalar-int-expr   The value of the expression specified in'
write(io,'(a)')'                         the ID= specifier shall be the identifier'
write(io,'(a)')'                         of a pending data transfer operation for the'
write(io,'(a)')'                         specified unit. If the ID= specifier appears, a'
write(io,'(a)')'                         wait operation for the specified data transfer'
write(io,'(a)')'                         operation is performed. If the ID= specifier is'
write(io,'(a)')'                         omitted, wait operations for all pending data'
write(io,'(a)')'                         transfers for the specified unit are performed.'
write(io,'(a)')'    IOMSG=iomsg-variable  if IOSTAT is not zero, a corresponding message'
write(io,'(a)')'                          describing the error'
write(io,'(a)')'    IOSTAT=scalar-int-variable  status value indicating if an error occurred.'
write(io,'(a)')'                                zero (0) indicates no error occurred.'
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'NAME'
write(io,'(a)')'   OPEN(7f) - [FORTRAN:IO] Initiates or modifies a connection between an external file and a specified unit.'
write(io,'(a)')'   (LICENSE:PD)'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')''
write(io,'(a)')'  OPEN (connect-spec-list)'
write(io,'(a)')''
write(io,'(a)')'  connect-spec  is   [ UNIT = ] file-unit-number'
write(io,'(a)')'                or   ACCESS = scalar-default-char-expr'
write(io,'(a)')'                or   ACTION = scalar-default-char-expr'
write(io,'(a)')'                or   ASYNCHRONOUS = scalar-default-char-expr'
write(io,'(a)')'                or   BLANK = scalar-default-char-expr'
write(io,'(a)')'                or   DECIMAL = scalar-default-char-expr'
write(io,'(a)')'                or   DELIM = scalar-default-char-expr'
write(io,'(a)')'                or   ENCODING = scalar-default-char-expr'
write(io,'(a)')'                or   ERR = label'
write(io,'(a)')'                or   FILE = file-name-expr'
write(io,'(a)')'                            file-name-expr is scalar-default-char-expr'
write(io,'(a)')'                or   FORM = scalar-default-char-expr'
write(io,'(a)')'                or   IOMSG = iomsg-variable'
write(io,'(a)')'                             iomsg-variable is scalar-default-char-variable'
write(io,'(a)')'                or   IOSTAT = scalar-int-variable'
write(io,'(a)')'                or   NEWUNIT = scalar-int-variable'
write(io,'(a)')'                or   PAD = scalar-default-char-expr'
write(io,'(a)')'                or   POSITION = scalar-default-char-expr'
write(io,'(a)')'                or   RECL = scalar-int-expr'
write(io,'(a)')'                or   ROUND = scalar-default-char-expr'
write(io,'(a)')'                or   SIGN = scalar-default-char-expr'
write(io,'(a)')'                or   STATUS = scalar-default-char-expr'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   An OPEN statement initiates or modifies the connection between an external file and a specified unit. The'
write(io,'(a)')'   OPEN statement may be used to connect an existing file to a unit, create a file that is preconnected, create a f&
   &ile'
write(io,'(a)')'   and connect it to a unit, or change certain modes of a connection between a file and a unit.'
write(io,'(a)')''
write(io,'(a)')'   An external unit may be connected by an OPEN statement in the main program or any subprogram and, once'
write(io,'(a)')'   connected, a reference to it may appear in any program unit of the program.'
write(io,'(a)')''
write(io,'(a)')'   If the file to be connected to the unit does not exist but is the same as the file to which the unit is preconne&
   &cted,'
write(io,'(a)')'   the modes specified by an OPEN statement become a part of the connection.'
write(io,'(a)')''
write(io,'(a)')'   If the file to be connected to the unit is not the same as the file to which the unit is connected, the effect i&
   &s as'
write(io,'(a)')'   if a CLOSE statement without a STATUS= specifier had been executed for the unit immediately prior to the'
write(io,'(a)')'   execution of an OPEN statement.'
write(io,'(a)')''
write(io,'(a)')'   If a unit is connected to a file that exists, execution of an OPEN statement for that unit is permitted. If the'
write(io,'(a)')'   FILE= specifier is not included in such an OPEN statement, the file to be connected to the unit is the same as'
write(io,'(a)')'   the file to which the unit is already connected.'
write(io,'(a)')''
write(io,'(a)')'   If the file to be connected to the unit is the same as the file to which the unit is connected, only the specifi&
   &ers for'
write(io,'(a)')'   changeable modes (9.5.2) may have values different from those currently in effect. If the POSITION= specifier'
write(io,'(a)')'   appears in such an OPEN statement, the value specified shall not disagree with the current position of the file.'
write(io,'(a)')'   If the STATUS= specifier is included in such an OPEN statement, it shall be specified with the value OLD.'
write(io,'(a)')'   Execution of such an OPEN statement causes any new values of the specifiers for changeable modes to be in'
write(io,'(a)')'   effect, but does not cause any change in any of the unspecified specifiers and the position of the file is unaff&
   &ected.'
write(io,'(a)')'   The ERR=, IOSTAT=, and IOMSG= specifiers from any previously executed OPEN statement have no effect'
write(io,'(a)')'   on any currently executed OPEN statement.'
write(io,'(a)')''
write(io,'(a)')'   A STATUS= specifier with a value of OLD is always allowed when the file to be connected to the unit is the same'
write(io,'(a)')'   as the file to which the unit is connected. In this case, if the status of the file was SCRATCH before execution&
   & of'
write(io,'(a)')'   the OPEN statement, the file will still be deleted when the unit is closed, and the file is still considered to &
   &have'
write(io,'(a)')'   a status of SCRATCH.'
write(io,'(a)')''
write(io,'(a)')'   If a file is already connected to a unit, an OPEN statement on that file with a different unit shall not be exec&
   &uted.'
write(io,'(a)')''
write(io,'(a)')'OPTIONS'
write(io,'(a)')''
write(io,'(a)')'A specifier that requires a scalar-default-char-expr may have a'
write(io,'(a)')'limited list of character values. These values are listed for each'
write(io,'(a)')'such specifier. Any trailing blanks are ignored. The value specified'
write(io,'(a)')'is without regard to case. Some specifiers have a default value if the'
write(io,'(a)')'specifier is omitted. No specifier shall appear more than once in a'
write(io,'(a)')'given connect-spec-list.'
write(io,'(a)')''
write(io,'(a)')'If the NEWUNIT= specifier does not appear, a file-unit-number shall'
write(io,'(a)')'be specified; if the optional characters UNIT= are omitted, the'
write(io,'(a)')'file-unit-number shall be the first item in the connect-spec-list.'
write(io,'(a)')''
write(io,'(a)')'The label used in the ERR= specifier shall be the statement label of'
write(io,'(a)')'a branch target statement that appears in the same scoping unit as the'
write(io,'(a)')'OPEN statement.'
write(io,'(a)')''
write(io,'(a)')'If a NEWUNIT= specifier appears, a file-unit-number shall not appear.'
write(io,'(a)')''
write(io,'(a)')'STATUS   If the STATUS= specifier has the value NEW or REPLACE, the FILE= specifier shall appear. If the STATUS='
write(io,'(a)')'         specifier has the value SCRATCH, the FILE= specifier shall not appear. If the STATUS= specifier has the va&
   &lue'
write(io,'(a)')'         OLD, the FILE= specifier shall appear unless the unit is connected and the file connected to the unit exis&
   &ts.'
write(io,'(a)')''
write(io,'(a)')'NEWUNIT  If the NEWUNIT= specifier appears in an OPEN statement, either the FILE= specifier shall appear, or the'
write(io,'(a)')'         STATUS= specifier shall appear with a value of SCRATCH. The unit identified by a NEWUNIT value shall not'
write(io,'(a)')'         be preconnected.'
write(io,'(a)')''
write(io,'(a)')'IOSTAT=, ERR=, and IOMSG=   specifiers are described in 9.11.'
write(io,'(a)')''
write(io,'(a)')'ACCESS   The scalar-default-char-expr shall evaluate to SEQUENTIAL, DIRECT, or STREAM. The ACCESS= specifier'
write(io,'(a)')'         specifies the access method for the connection of the file as being sequential, direct, or stream. If this&
   & specifier is'
write(io,'(a)')'         omitted, the default value is SEQUENTIAL. For an existing file, the specified access method shall be inclu&
   &ded in'
write(io,'(a)')'         the set of allowed access methods for the file. For a new file, the processor creates the file with a set &
   &of allowed'
write(io,'(a)')'         access methods that includes the specified method.'
write(io,'(a)')''
write(io,'(a)')'ACTION   The scalar-default-char-expr shall evaluate to READ, WRITE, or READWRITE. READ specifies that the'
write(io,'(a)')'         WRITE, PRINT, and ENDFILE statements shall not refer to this connection. WRITE specifies that READ'
write(io,'(a)')'         statements shall not refer to this connection. READWRITE permits any input/output statements to refer to t&
   &his'
write(io,'(a)')'         connection. If this specifier is omitted, the default value is processor dependent. If READWRITE is includ&
   &ed in'
write(io,'(a)')'         the set of allowable actions for a file, both READ and WRITE also shall be included in the set of allowed &
   &actions'
write(io,'(a)')'         for that file. For an existing file, the specified action shall be included in the set of allowed actions &
   &for the file.'
write(io,'(a)')'         For a new file, the processor creates the file with a set of allowed actions that includes the specified a&
   &ction.'
write(io,'(a)')''
write(io,'(a)')'ASYNCHRONOUS   The scalar-default-char-expr shall evaluate to YES or NO. If YES is specified, asynchronous input/ou&
   &tput on'
write(io,'(a)')'               the unit is allowed. If NO is specified, asynchronous input/output on the unit is not allowed. If th&
   &is specifier is'
write(io,'(a)')'               omitted, the default value is NO.'
write(io,'(a)')''
write(io,'(a)')'BLANK   The scalar-default-char-expr shall evaluate to NULL or ZERO. The BLANK= specifier is permitted only for a'
write(io,'(a)')'        connection for formatted input/output. It specifies the current value of the blank interpretation mode'
write(io,'(a)')'        (10.8.6, 9.6.2.6) for input for this connection. This mode has no effect on output. It is a changeable mode&
   & (9.5.2).'
write(io,'(a)')'        If this specifier is omitted in an OPEN statement that initiates a connection, the default value is NULL.'
write(io,'(a)')''
write(io,'(a)')'DECIMAL   The scalar-default-char-expr shall evaluate to COMMA or POINT. The DECIMAL= specifier is permitted only'
write(io,'(a)')'          for a connection for formatted input/output. It specifies the current value of the decimal edit mode'
write(io,'(a)')'          (10.6, 10.8.8, 9.6.2.7)'
write(io,'(a)')'          for this connection. This is a changeable mode (9.5.2). If this specifier is omitted in an OPEN statement'
write(io,'(a)')'          that initiates a connection, the default value is POINT.'
write(io,'(a)')''
write(io,'(a)')'DELIM   The scalar-default-char-expr shall evaluate to APOSTROPHE, QUOTE, or NONE. The DELIM= specifier is'
write(io,'(a)')'        permitted only for a connection for formatted input/output. It specifies the current value of the delimiter&
   & mode'
write(io,'(a)')'        (9.6.2.8) for list-directed (10.10.4) and namelist (10.11.4.2) output for the connection. This mode has no &
   &effect'
write(io,'(a)')'        on input. It is a changeable mode (9.5.2). If this specifier is omitted in an OPEN statement that initiates&
   & a'
write(io,'(a)')'        connection, the default value is NONE.'
write(io,'(a)')''
write(io,'(a)')'ENCODING   The scalar-default-char-expr shall evaluate to UTF-8 or DEFAULT. The ENCODING= specifier is permitted'
write(io,'(a)')'           only for a connection for formatted input/output. The value UTF-8 specifies that the encoding form of th&
   &e file is'
write(io,'(a)')'           UTF-8 as specified by ISO/IEC 10646-1:2000. Such a file is called a Unicode file, and all characters the&
   &rein are'
write(io,'(a)')'           of ISO 10646 character type. The value UTF-8 shall not be specified if the processor does not support th&
   &e ISO'
write(io,'(a)')'           10646 character type. The value DEFAULT specifies that the encoding form of the file is processor-depend&
   &ent.'
write(io,'(a)')'           If this specifier is omitted in an OPEN statement that initiates a connection, the default value is DEFA&
   &ULT.'
write(io,'(a)')''
write(io,'(a)')'FILE   The value of the FILE= specifier is the name of the file to be connected to the specified unit. Any trailing&
   & blanks'
write(io,'(a)')'       are ignored. The file-name-expr shall be a name that is allowed by the processor. If this specifier is omitt&
   &ed and'
write(io,'(a)')'       the unit is not connected to a file, the STATUS= specifier shall be specified with a value of SCRATCH; in th&
   &is'
write(io,'(a)')'       case, the connection is made to a processor-dependent file. The interpretation of case is processor dependen&
   &t.'
write(io,'(a)')''
write(io,'(a)')'FORM   The scalar-default-char-expr shall evaluate to FORMATTED or UNFORMATTED. The FORM= specifier determines'
write(io,'(a)')'       whether the file is being connected for formatted or unformatted input/output. If this specifier is omitted,'
write(io,'(a)')'       the default value is UNFORMATTED if the file is being connected for direct access or stream access, and the'
write(io,'(a)')'       default value is FORMATTED if the file is being connected for sequential access. For an existing file, the s&
   &pecified'
write(io,'(a)')'       form shall be included in the set of allowed forms for the file. For a new file, the processor creates the f&
   &ile with a'
write(io,'(a)')'       set of allowed forms that includes the specified form.'
write(io,'(a)')''
write(io,'(a)')'NEWUNIT   The variable is defined with a processor determined NEWUNIT value if no error occurs during the execution&
   & of'
write(io,'(a)')'          the OPEN statement. If an error occurs, the processor shall not change the value of the variable.'
write(io,'(a)')''
write(io,'(a)')'          A NEWUNIT value is a negative number, and shall not be equal to -1, any of the named constants ERROR_UNIT&
   &,'
write(io,'(a)')'          INPUT_UNIT, or OUTPUT_UNIT from the intrinsic module ISO_FORTRAN_ENV (13.8.2), any value'
write(io,'(a)')'          used by the processor for the unit argument to a defined input/output procedure, nor any previous NEWUNIT'
write(io,'(a)')'          value that identifies a file that is currently connected.'
write(io,'(a)')''
write(io,'(a)')'PAD    The scalar-default-char-expr shall evaluate to YES or NO. The PAD= specifier is permitted only for a connect&
   &ion'
write(io,'(a)')'       for formatted input/output. It specifies the current value of the pad mode (9.6.4.4.3, 9.6.2.10) for input f&
   &or this'
write(io,'(a)')'       connection. This mode has no effect on output. It is a changeable mode (9.5.2). If this specifier is omitted&
   & in an'
write(io,'(a)')'       OPEN statement that initiates a connection, the default value is YES.'
write(io,'(a)')''
write(io,'(a)')'POSITION   The scalar-default-char-expr shall evaluate to ASIS, REWIND, or APPEND. The connection shall be for sequ&
   &ential'
write(io,'(a)')'           or stream access. A new file is positioned at its initial point. REWIND positions an existing file at it&
   &s initial'
write(io,'(a)')'           point. APPEND positions an existing file such that the endfile record is the next record, if it has one.&
   & If an'
write(io,'(a)')'           existing file does not have an endfile record, APPEND positions the file at its terminal point. ASIS lea&
   &ves the'
write(io,'(a)')'           position unchanged if the file exists and already is connected. ASIS leaves the position unspecified if &
   &the file exists'
write(io,'(a)')'           but is not connected. If this specifier is omitted, the default value is ASIS.'
write(io,'(a)')''
write(io,'(a)')'RECL       The value of the RECL= specifier shall be positive. It specifies the length of each record in a file bei&
   &ng connected'
write(io,'(a)')'           for direct access, or specifies the maximum length of a record in a file being connected for sequential &
   &access. This'
write(io,'(a)')'           specifier shall not appear when a file is being connected for stream access. This specifier shall appear&
   & when a'
write(io,'(a)')'           file is being connected for direct access. If this specifier is omitted when a file is being connected f&
   &or sequential'
write(io,'(a)')'           access, the default value is processor dependent. If the file is being connected for formatted input/out&
   &put, the'
write(io,'(a)')'           length is the number of characters for all records that contain only characters of default kind. When a &
   &record'
write(io,'(a)')'           contains any nondefault characters, the effect of the RECL= specifier is processor dependent. If the fil&
   &e is being'
write(io,'(a)')'           connected for unformatted input/output, the length is measured in file storage units. For an existing fi&
   &le, the'
write(io,'(a)')'           value of the RECL= specifier shall be included in the set of allowed record lengths for the file. For a &
   &new file, the'
write(io,'(a)')'           processor creates the file with a set of allowed record lengths that includes the specified value.'
write(io,'(a)')''
write(io,'(a)')'ROUND      The scalar-default-char-expr shall evaluate to one of UP, DOWN, ZERO, NEAREST, COMPATIBLE, or PROCESSOR &
   &DEFINED.'
write(io,'(a)')'           The ROUND= specifier is permitted only for a connection for formatted input/output. It'
write(io,'(a)')'           specifies the current value of the I/O rounding mode (10.7.2.3.7, 9.6.2.13) for this connection. This is&
   & a changeable'
write(io,'(a)')'           mode (9.5.2). If this specifier is omitted in an OPEN statement that initiates a connection, the I/O rou&
   &nding'
write(io,'(a)')'           mode is processor dependent; it shall be one of the above modes.'
write(io,'(a)')''
write(io,'(a)')'           A processor is free to select any I/O rounding mode for the default mode. The mode might correspond'
write(io,'(a)')'           to UP, DOWN, ZERO, NEAREST, or COMPATIBLE; or it might be a completely different I/O rounding mode.'
write(io,'(a)')''
write(io,'(a)')'SIGN       The scalar-default-char-expr shall evaluate to one of PLUS, SUPPRESS, or PROCESSOR DEFINED. The'
write(io,'(a)')'          SIGN= specifier is permitted only for a connection for formatted input/output. It specifies the current v&
   &alue of'
write(io,'(a)')'          the sign mode (10.8.4, 9.6.2.14) for this connection. This is a changeable mode (9.5.2). If this specifie&
   &r is omitted'
write(io,'(a)')'          in an OPEN statement that initiates a connection, the default value is PROCESSOR DEFINED.'
write(io,'(a)')''
write(io,'(a)')'STATUS    The scalar-default-char-expr shall evaluate to OLD, NEW, SCRATCH, REPLACE, or UNKNOWN. If OLD is'
write(io,'(a)')'          specified, the file shall exist. If NEW is specified, the file shall not exist.'
write(io,'(a)')''
write(io,'(a)')'          Successful execution of an OPEN statement with NEW specified creates the file and changes the status to O&
   &LD.'
write(io,'(a)')'          If REPLACE is specified and the file does not already exist, the file is created and the status is change&
   &d to OLD.'
write(io,'(a)')'          If REPLACE is specified and the file does exist, the file is deleted, a new file is created with the same&
   & name, and'
write(io,'(a)')'          the status is changed to OLD. If SCRATCH is specified, the file is created and connected to the specified&
   & unit'
write(io,'(a)')'          for use by the program but is deleted at the execution of a CLOSE statement referring to the same unit or&
   & at'
write(io,'(a)')'          the normal termination of the program.'
write(io,'(a)')''
write(io,'(a)')'          SCRATCH shall not be specified with a named file.'
write(io,'(a)')''
write(io,'(a)')'          If UNKNOWN is specified, the status is processor dependent. If this specifier is omitted, the default val&
   &ue is'
write(io,'(a)')'          UNKNOWN.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLES'
write(io,'(a)')''
write(io,'(a)')'An example of an OPEN statement is:'
write(io,'(a)')''
write(io,'(a)')'   program demo_open'
write(io,'(a)')'   integer :: ios'
write(io,'(a)')'   character(len=256) :: message'
write(io,'(a)')'   open (10, file=''employee.names'', action=''read'', iostat=ios,iomsg=message)'
write(io,'(a)')'   if (ios < 0) then'
write(io,'(a)')'      ! Perform end-of-file processing on the file connected to unit 3.'
write(io,'(a)')'      call end_processing()'
write(io,'(a)')'   elseif (ios > 0) then'
write(io,'(a)')'      ! Perform error processing'
write(io,'(a)')'      write(*,''(a)'')trim(message)'
write(io,'(a)')'      call error_processing()'
write(io,'(a)')'      stop'
write(io,'(a)')'   else'
write(io,'(a)')'      write(*,*)''OPENED FILE'''
write(io,'(a)')'   endif'
write(io,'(a)')'   contains'
write(io,'(a)')'      subroutine end_processing()'
write(io,'(a)')'         write(*,*)''END OF FILE:'',ios,''MESSAGE='',trim(message)'
write(io,'(a)')'         close(unit=10,iostat=ios)'
write(io,'(a)')'         stop'
write(io,'(a)')'      end subroutine end_processing'
write(io,'(a)')'      subroutine error_processing()'
write(io,'(a)')'         write(*,*)''ERROR:'',ios,''MESSAGE='',trim(message)'
write(io,'(a)')'         close(unit=10,iostat=ios)'
write(io,'(a)')'         stop'
write(io,'(a)')'      end subroutine error_processing'
write(io,'(a)')'   end program demo_open'
write(io,'(a)')'NAME'
write(io,'(a)')'     use(7f) - [FORTRAN] gives a program unit accessibility to public entities in a module.'
write(io,'(a)')'     (LICENSE:PD)'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'   USE [, mode-nature ::] namespace [, rename-list]'
write(io,'(a)')'   USE [, mode-nature ::] namespace [,ONLY: only-list]'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   The USE statement makes the specified namespace accessible to the'
write(io,'(a)')'   current scoping unit. It also provides a means of renaming or limiting'
write(io,'(a)')'   the accessibility of entities in the namespace.'
write(io,'(a)')''
write(io,'(a)')'   WHERE:'
write(io,'(a)')''
write(io,'(a)')'   mode-nature    Is INTRINSIC or NON_INTRINSIC. If INTRINSIC is used, namespace'
write(io,'(a)')'                  must be the name of an intrinsic module. If NON_INTRINSIC is used,'
write(io,'(a)')'                  namespace must be the name of an nonintrinsic module. If mod-nature is'
write(io,'(a)')'                  not specified, namespace must be the name of an intrinsic or nonintrinsic'
write(io,'(a)')'                  module. If both are provided, the nonintrinsic module is used. It is an'
write(io,'(a)')'                  error to specify a user module and an intrinsic module of the same name'
write(io,'(a)')'                  in the same program unit.'
write(io,'(a)')'   namespace    is a publicly accessible namespace; ie. it is the name of a module.'
write(io,'(a)')''
write(io,'(a)')'   rename-list  is a comma-separated list of local-name => use-name'
write(io,'(a)')'   only-list    is a comma-separated list of access-id or [local-name => use-name]'
write(io,'(a)')''
write(io,'(a)')'                 local-name      is the local name for the entity specified by use-name'
write(io,'(a)')'                                 Is the name of the entity in the program unit using the module or is'
write(io,'(a)')'                                 "OPERATOR (op-name)", where op-name is the name of a defined operator'
write(io,'(a)')'                                 in the program unit using the module.'
write(io,'(a)')'                 use-name        is the name of a public entity in the specified namespace'
write(io,'(a)')'                 access-id       is use-name or generic-spec'
write(io,'(a)')'                 generic-spec    is generic-name'
write(io,'(a)')'                                 or OPERATOR (defined-operator)'
write(io,'(a)')'                                 or ASSIGNMENT (=)'
write(io,'(a)')''
write(io,'(a)')'                               generic-name is the name of a generic procedure'
write(io,'(a)')''
write(io,'(a)')'                               defined-operator is one of the intrinsic operators'
write(io,'(a)')''
write(io,'(a)')'                               or .op-name.'
write(io,'(a)')''
write(io,'(a)')'                               .op-name. is a user-defined name for the operation'
write(io,'(a)')''
write(io,'(a)')'   REMARKS'
write(io,'(a)')''
write(io,'(a)')'   rename-list and ONLY: only-list may only appear if the namespace being'
write(io,'(a)')'   used was implemented with Fortran for .NET'
write(io,'(a)')''
write(io,'(a)')'   A USE statement without ONLY provides access to all PUBLIC entities in'
write(io,'(a)')'   the specified namespace.'
write(io,'(a)')''
write(io,'(a)')'   A USE statement with ONLY provides access only to those entities that'
write(io,'(a)')'   appear in the only-list.'
write(io,'(a)')''
write(io,'(a)')'   If more than one USE statement appears in a scoping unit, the rename-lists'
write(io,'(a)')'   and only-lists are treated as one concatenated rename-list.'
write(io,'(a)')''
write(io,'(a)')'   If two or more generic interfaces that are accessible in the same'
write(io,'(a)')'   scoping unit have the same name, same operator, or are assignments,'
write(io,'(a)')'   they are interpreted as a single generic interface.'
write(io,'(a)')''
write(io,'(a)')'   Two or more accessible entities, other than generic interfaces, can'
write(io,'(a)')'   have the same name only if no entity is referenced by this name in the'
write(io,'(a)')'   scoping unit.'
write(io,'(a)')''
write(io,'(a)')'   If local-name is absent, the use-name is available by use association.'
write(io,'(a)')''
write(io,'(a)')'   An entity can be accessed by more than one local-name.'
write(io,'(a)')''
write(io,'(a)')'   A local-name must not be declared with different attributes in the'
write(io,'(a)')'   scoping unit that contains the USE statement, except that it can appear'
write(io,'(a)')'   in a PUBLIC or PRIVATE statement in the scoping unit of a module.'
write(io,'(a)')''
write(io,'(a)')'   Forward references to modules are not allowed. That is, if a module is'
write(io,'(a)')'   used in the same source file in which it resides, the module program'
write(io,'(a)')'   unit must appear before its use.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLES'
write(io,'(a)')' Samples:'
write(io,'(a)')''
write(io,'(a)')'   module example ! example is the namespace name'
write(io,'(a)')'      type type1 ! type1 is the class prototype name'
write(io,'(a)')'      contains'
write(io,'(a)')'         procedure, nopass :: static_method1'
write(io,'(a)')'      end type type1'
write(io,'(a)')'      type type2 ! type1 is the class prototype name'
write(io,'(a)')'      contains'
write(io,'(a)')'         procedure, nopass :: static_method2'
write(io,'(a)')'      end type type2'
write(io,'(a)')'   contains'
write(io,'(a)')'      subroutine static_method1(arg)'
write(io,'(a)')'         integer :: arg'
write(io,'(a)')'         ! code to implement method goes here'
write(io,'(a)')'      end subroutine static_method1'
write(io,'(a)')'      subroutine static_method2(arg)'
write(io,'(a)')'         integer :: arg'
write(io,'(a)')'         ! code to implement method goes here'
write(io,'(a)')'      end subroutine static_method2'
write(io,'(a)')'   end module example'
write(io,'(a)')''
write(io,'(a)')'   use example ! all public objects in namespace example available'
write(io,'(a)')''
write(io,'(a)')'   use example, only: type1 ! class prototype type1 available,'
write(io,'(a)')'                            ! class prototype type2 not available'
write(io,'(a)')''
write(io,'(a)')'   ! within this scoping unit, type1 is referred to as "mytype"'
write(io,'(a)')'   use example, mytype => type1'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   implied_do(7f) - [FORTRAN] documentation on usage of implied do in Fortran'
write(io,'(a)')'   (LICENSE:PD)'
write(io,'(a)')''
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Examples using implied DO loops in Fortran code.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLES'
write(io,'(a)')''
write(io,'(a)')' Sample Programs:'
write(io,'(a)')''
write(io,'(a)')'   program demo_implied_do'
write(io,'(a)')'   implicit none'
write(io,'(a)')'      integer :: i'
write(io,'(a)')'      ! [A-Z] [a-z] alphabet'
write(io,'(a)')'      character(len=1),parameter :: a2z(26*2)=[(char(i),i=65,90),(char(i),i=97,122)]'
write(io,'(a)')'      write(*,*)''Alphabet='',a2z'
write(io,'(a)')'   end program demo_implied_do'
write(io,'(a)')''
write(io,'(a)')' Expected output:'
write(io,'(a)')''
write(io,'(a)')'   Alphabet=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
write(io,'(a)')''
write(io,'(a)')' Examples of array constructors containing an implied DO are:'
write(io,'(a)')''
write(io,'(a)')'   (/ (I, I = 1, 1075) /)'
write(io,'(a)')''
write(io,'(a)')' and'
write(io,'(a)')''
write(io,'(a)')'   N=20'
write(io,'(a)')'   [ 3.6, (3.6 / I, I = 1, N) ]'
write(io,'(a)')''
write(io,'(a)')' For an io-implied-do, the loop initialization and execution are the same as for a DO construct.'
write(io,'(a)')' An example of an output list with an implied DO is:'
write(io,'(a)')''
write(io,'(a)')'   WRITE (LP, FMT = ''(10F8.2)'') (LOG (A (I)), I = 1, N + 9, K), G'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   fortran(7f) - [FORTRAN] Fortran Example'
write(io,'(a)')'   (LICENSE:PD)'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'abs (3fortran)       - [FORTRAN:INTRINSIC:NUMERIC] Absolute value'
write(io,'(a)')'achar (3fortran)     - [FORTRAN:INTRINSIC:CHARACTER] returns a character in a specified position in the ASCII colla&
   &ting sequence'
write(io,'(a)')'acos (3fortran)      - [FORTRAN:INTRINSIC:TRIGONOMETRIC] Arccosine function'
write(io,'(a)')'acosh (3fortran)     - [FORTRAN:INTRINSIC:TRIGONOMETRIC] Inverse hyperbolic cosine function'
write(io,'(a)')'adjustl (3fortran)   - [FORTRAN:INTRINSIC:CHARACTER] Left adjust a string'
write(io,'(a)')'adjustr (3fortran)   - [FORTRAN:INTRINSIC:CHARACTER] Right adjust a string'
write(io,'(a)')'aimag (3fortran)     - [FORTRAN:INTRINSIC:NUMERIC] Imaginary part of complex number'
write(io,'(a)')'aint (3fortran)      - [FORTRAN:INTRINSIC:NUMERIC] Truncate to a whole number'
write(io,'(a)')'all (3fortran)       - [FORTRAN:INTRINSIC:ARRAY REDUCTION] determines if all the values are true'
write(io,'(a)')'allocated (3fortran) - [FORTRAN:INTRINSIC:ARRAY INQUIRY] Status of an allocatable entity'
write(io,'(a)')'anint (3fortran)     - [FORTRAN:INTRINSIC:NUMERIC] Nearest whole number'
write(io,'(a)')'any (3fortran)       - [FORTRAN:INTRINSIC:ARRAY REDUCTION] determines if any of the values in the logical array are&
   & true.'
write(io,'(a)')'asin (3fortran)      - [FORTRAN:INTRINSIC:TRIGONOMETRIC] Arcsine function'
write(io,'(a)')'asinh (3fortran)     - [FORTRAN:INTRINSIC:TRIGONOMETRIC] Inverse hyperbolic sine function'
write(io,'(a)')'atan (3fortran)      - [FORTRAN:INTRINSIC:TRIGONOMETRIC] Arctangent function'
write(io,'(a)')'atan2 (3fortran)     - [FORTRAN:INTRINSIC:TRIGONOMETRIC] Arctangent function'
write(io,'(a)')'atanh (3fortran)     - [FORTRAN:INTRINSIC:TRIGONOMETRIC] Inverse hyperbolic tangent function'
write(io,'(a)')'associated (3fortran) - [FORTRAN:INTRINSIC] Status of a pointer or pointer/target pair'
write(io,'(a)')'atomic_add (3fortran) - [FORTRAN:INTRINSIC] Atomic ADD operation'
write(io,'(a)')'atomic_and (3fortran) - [FORTRAN:INTRINSIC:ATOMIC:BIT MANIPULATION] Atomic bitwise AND operation'
write(io,'(a)')'atomic_cas (3fortran) - [FORTRAN:INTRINSIC] Atomic compare and swap'
write(io,'(a)')'atomic_define (3fortran) - [FORTRAN:INTRINSIC] Setting a variable atomically'
write(io,'(a)')'atomic_fetch_add (3fortran) - [FORTRAN:INTRINSIC] Atomic ADD operation with prior fetch'
write(io,'(a)')'atomic_fetch_and (3fortran) - [FORTRAN:INTRINSIC:ATOMIC:BIT MANIPULATION] Atomic bitwise AND operation with prior f&
   &etch'
write(io,'(a)')'atomic_fetch_or (3fortran) - [FORTRAN:INTRINSIC:ATOMIC:BIT MANIPULATION] Atomic bitwise OR operation with prior fet&
   &ch'
write(io,'(a)')'atomic_fetch_xor (3fortran) - [FORTRAN:INTRINSIC:ATOMIC:BIT MANIPULATION] Atomic bitwise XOR operation with prior f&
   &etch'
write(io,'(a)')'atomic_or (3fortran) - [FORTRAN:INTRINSIC:ATOMIC:BIT MANIPULATION] Atomic bitwise OR operation'
write(io,'(a)')'atomic_ref (3fortran) - [FORTRAN:INTRINSIC] Obtaining the value of a variable atomically'
write(io,'(a)')'atomic_xor (3fortran) - [FORTRAN:INTRINSIC:ATOMIC:BIT MANIPULATION] Atomic bitwise OR operation'
write(io,'(a)')'bessel_j0 (3fortran) - [FORTRAN:INTRINSIC:MATHEMATICS] Bessel function of the first kind of order 0'
write(io,'(a)')'bessel_j1 (3fortran) - [FORTRAN:INTRINSIC:MATHEMATICS] Bessel function of the first kind of order 1'
write(io,'(a)')'bessel_jn (3fortran) - [FORTRAN:INTRINSIC:MATHEMATICS] Bessel function of the first kind'
write(io,'(a)')'bessel_y0 (3fortran) - [FORTRAN:INTRINSIC:MATHEMATICS] Bessel function of the second kind of order 0'
write(io,'(a)')'bessel_y1 (3fortran) - [FORTRAN:INTRINSIC:MATHEMATICS] Bessel function of the second kind of order 1'
write(io,'(a)')'bessel_yn (3fortran) - [FORTRAN:INTRINSIC:MATHEMATICS] Bessel function of the second kind'
write(io,'(a)')'bge (3fortran)       - [FORTRAN:INTRINSIC:BIT COMPARE] Bitwise greater than or equal to'
write(io,'(a)')'bgt (3fortran)       - [FORTRAN:INTRINSIC:BIT COMPARE] Bitwise greater than'
write(io,'(a)')'bit_size (3fortran)  - [FORTRAN:INTRINSIC:BIT INQUIRY] Bit size inquiry function'
write(io,'(a)')'ble (3fortran)       - [FORTRAN:INTRINSIC:BIT COMPARE] Bitwise less than or equal to'
write(io,'(a)')'blt (3fortran)       - [FORTRAN:INTRINSIC:BIT COMPARE] Bitwise less than'
write(io,'(a)')'btest (3fortran)     - [FORTRAN:INTRINSIC:BIT MANIPULATION] Bit test function'
write(io,'(a)')'c_associated (3fortran) - [FORTRAN:INTRINSIC:ISO_C_BINDING] Status of a C pointer'
write(io,'(a)')'c_f_pointer (3fortran) - [FORTRAN:INTRINSIC:ISO_C_BINDING] Convert C into Fortran pointer'
write(io,'(a)')'c_f_procpointer (3fortran) - [FORTRAN:INTRINSIC:ISO_C_BINDING] Convert C into Fortran procedure pointer'
write(io,'(a)')'c_funloc (3fortran)  - [FORTRAN:INTRINSIC:ISO_C_BINDING] Obtain the C address of a procedure'
write(io,'(a)')'c_loc (3fortran)     - [FORTRAN:INTRINSIC:ISO_C_BINDING] Obtain the C address of an object'
write(io,'(a)')'c_sizeof (3fortran)  - [FORTRAN:INTRINSIC:ISO_C_BINDING] Size in bytes of an expression'
write(io,'(a)')'ceiling (3fortran)   - [FORTRAN:INTRINSIC:NUMERIC] Integer ceiling function'
write(io,'(a)')'char (3fortran)      - [FORTRAN:INTRINSIC:CHARACTER] Character conversion function'
write(io,'(a)')'cmplx (3fortran)     - [FORTRAN:INTRINSIC:NUMERIC] Complex conversion function'
write(io,'(a)')'co_broadcast (3fortran) - [FORTRAN:INTRINSIC:COLLECTIVE] Copy a value to all images the current set of images'
write(io,'(a)')'co_lbound (3fortran) - [FORTRAN:INTRINSIC:COLLECTIVE] Lower codimension bounds of an array'
write(io,'(a)')'co_max (3fortran)    - [FORTRAN:INTRINSIC:COLLECTIVE] Maximal value on the current set of images'
write(io,'(a)')'co_min (3fortran)    - [FORTRAN:INTRINSIC:COLLECTIVE] Minimal value on the current set of images'
write(io,'(a)')'co_reduce (3fortran) - [FORTRAN:INTRINSIC:COLLECTIVE] Reduction of values on the current set of images'
write(io,'(a)')'co_sum (3fortran)    - [FORTRAN:INTRINSIC:COLLECTIVE] Sum of values on the current set of images'
write(io,'(a)')'co_ubound (3fortran) - [FORTRAN:INTRINSIC:COLLECTIVE] Upper codimension bounds of an array'
write(io,'(a)')'command_argument_count (3fortran) - [FORTRAN:INTRINSIC:SYSTEM ENVIRONMENT] Get number of command line arguments'
write(io,'(a)')'compiler_options (3fortran) - [FORTRAN:INTRINSIC] Options passed to the compiler'
write(io,'(a)')'compiler_version (3fortran) - [FORTRAN:INTRINSIC] Compiler version string'
write(io,'(a)')'conjg (3fortran)     - [FORTRAN:INTRINSIC:NUMERIC] Complex conjugate function'
write(io,'(a)')'cos (3fortran)       - [FORTRAN:INTRINSIC:TRIGONOMETRIC] Cosine function'
write(io,'(a)')'cosh (3fortran)      - [FORTRAN:INTRINSIC:TRIGONOMETRIC] Hyperbolic cosine function'
write(io,'(a)')'count (3fortran)     - [FORTRAN:INTRINSIC:ARRAY REDUCTION] Count function'
write(io,'(a)')'cpu_time (3fortran)  - [FORTRAN:INTRINSIC:SYSTEM ENVIRONMENT] return CPU processor time in seconds'
write(io,'(a)')'cshift (3fortran)    - [FORTRAN:INTRINSIC:TRANSFORMATIONAL FUNCTION] Circular shift elements of an array'
write(io,'(a)')'date_and_time (3fortran) - [FORTRAN:INTRINSIC:SYSTEM ENVIRONMENT] gets current time'
write(io,'(a)')'dble (3fortran)      - [FORTRAN:INTRINSIC:NUMERIC] Double conversion function'
write(io,'(a)')'digits (3fortran)    - [FORTRAN:INTRINSIC] Significant digits function'
write(io,'(a)')'dim (3fortran)       - [FORTRAN:INTRINSIC:NUMERIC] Positive difference'
write(io,'(a)')'dot_product (3fortran) - [FORTRAN:INTRINSIC:TRANSFORMATIONAL FUNCTION] Dot product function'
write(io,'(a)')'dprod (3fortran)     - [FORTRAN:INTRINSIC:NUMERIC] Double product function'
write(io,'(a)')'dshiftl (3fortran)   - [FORTRAN:INTRINSIC:BIT MANIPULATION] combines bits of arguments I and J'
write(io,'(a)')'dshiftr (3fortran)   - [FORTRAN:INTRINSIC:BIT MANIPULATION] combines bits of arguments I and J'
write(io,'(a)')'eoshift (3fortran)   - [FORTRAN:INTRINSIC:TRANSFORMATIONAL FUNCTION] End-off shift elements of an array'
write(io,'(a)')'epsilon (3fortran)   - [FORTRAN:INTRINSIC] Epsilon function'
write(io,'(a)')'erf (3fortran)       - [FORTRAN:INTRINSIC:MATHEMATICS] Error function'
write(io,'(a)')'erfc (3fortran)      - [FORTRAN:INTRINSIC:MATHEMATICS] Complementary error function'
write(io,'(a)')'erfc_scaled (3fortran) - [FORTRAN:INTRINSIC:MATHEMATICS] Error function'
write(io,'(a)')'event_query (3fortran) - [FORTRAN:INTRINSIC] Query whether a coarray event has occurred'
write(io,'(a)')'execute_command_line (3fortran) - [FORTRAN:INTRINSIC:SYSTEM ENVIRONMENT] Execute a shell command'
write(io,'(a)')'exp (3fortran)       - [FORTRAN:INTRINSIC:MATHEMATICS] Exponential function'
write(io,'(a)')'exponent (3fortran)  - [FORTRAN:INTRINSIC:MODEL_COMPONENTS] Exponent function'
write(io,'(a)')'extends_type_of (3fortran) - [FORTRAN:INTRINSIC] True if and only if the dynamic type of A is an extension of the d&
   &ynamic type of...'
write(io,'(a)')'findloc (3fortran)   - [FORTRAN:INTRINSIC] Location of the first element of ARRAY identified by MASK along dimensio&
   &n DIM having a...'
write(io,'(a)')'float (3fortran)     - [FORTRAN:INTRINSIC] Convert integer to default real'
write(io,'(a)')'floor (3fortran)     - [FORTRAN:INTRINSIC:NUMERIC] Integer floor function'
write(io,'(a)')'format (3fortran)    - [FORTRAN:INTRINSIC:I/O] Format statement'
write(io,'(a)')'fraction (3fortran)  - [FORTRAN:INTRINSIC:MODEL_COMPONENTS] Fractional part of the model representation'
write(io,'(a)')'gamma (3fortran)     - [FORTRAN:INTRINSIC:MATHEMATICS] Gamma function'
write(io,'(a)')'get_command (3fortran) - [FORTRAN:INTRINSIC:SYSTEM ENVIRONMENT] Get the entire command line'
write(io,'(a)')'get_command_argument (3fortran) - [FORTRAN:INTRINSIC:SYSTEM ENVIRONMENT] Get command line arguments'
write(io,'(a)')'get_environment_variable (3fortran) - [FORTRAN:INTRINSIC:SYSTEM ENVIRONMENT] Get an environmental variable'
write(io,'(a)')'huge (3fortran)      - [FORTRAN:INTRINSIC] Largest number of a kind'
write(io,'(a)')'hypot (3fortran)     - [FORTRAN:INTRINSIC:MATHEMATICS] Euclidean distance function'
write(io,'(a)')'iachar (3fortran)    - [FORTRAN:INTRINSIC:CHARACTER] Code in ASCII collating sequence'
write(io,'(a)')'iall (3fortran)      - [FORTRAN:INTRINSIC:BIT MANIPULATION] Bitwise and of array elements'
write(io,'(a)')'iand (3fortran)      - [FORTRAN:INTRINSIC:BIT MANIPULATION] Bitwise logical and'
write(io,'(a)')'iany (3fortran)      - [FORTRAN:INTRINSIC:BIT MANIPULATION] Bitwise or of array elements'
write(io,'(a)')'ibclr (3fortran)     - [FORTRAN:INTRINSIC:BIT MANIPULATION] Clear bit'
write(io,'(a)')'ibits (3fortran)     - [FORTRAN:INTRINSIC:BIT MANIPULATION] Bit extraction'
write(io,'(a)')'ibset (3fortran)     - [FORTRAN:INTRINSIC:BIT MANIPULATION] Set bit'
write(io,'(a)')'ichar (3fortran)     - [FORTRAN:INTRINSIC:CHARACTER] Character-to-integer conversion function'
write(io,'(a)')'ieor (3fortran)      - [FORTRAN:INTRINSIC:BIT MANIPULATION] Bitwise logical exclusive or'
write(io,'(a)')'image_index (3fortran) - [FORTRAN:INTRINSIC] Cosubscript to image index conversion'
write(io,'(a)')'index (3fortran)     - [FORTRAN:INTRINSIC:CHARACTER] Position of a substring within a string'
write(io,'(a)')'int (3fortran)       - [FORTRAN:INTRINSIC:NUMERIC] Convert to integer type'
write(io,'(a)')'ior (3fortran)       - [FORTRAN:INTRINSIC:BIT MANIPULATION] Bitwise logical inclusive or'
write(io,'(a)')'iparity (3fortran)   - [FORTRAN:INTRINSIC:BIT MANIPULATION] Bitwise exclusive or of array elements'
write(io,'(a)')'is_contiguous (3fortran) - [FORTRAN:INTRINSIC:ARRAY INQUIRY] test if object is contiguous'
write(io,'(a)')'is_iostat_end (3fortran) - [FORTRAN:INTRINSIC] Test for end-of-file value'
write(io,'(a)')'is_iostat_eor (3fortran) - [FORTRAN:INTRINSIC] Test for end-of-record value'
write(io,'(a)')'ishft (3fortran)     - [FORTRAN:INTRINSIC:BIT MANIPULATION] Shift bits'
write(io,'(a)')'ishftc (3fortran)    - [FORTRAN:INTRINSIC:BIT MANIPULATION] Shift bits circularly'
write(io,'(a)')'kind (3fortran)      - [FORTRAN:INTRINSIC] Kind of an entity'
write(io,'(a)')'kracken (3)          - [ARGUMENTS:M_kracken] crack command line options on Fortran programs, using "-KEYWORD VALUE"&
   & syntax'
write(io,'(a)')'lbound (3fortran)    - [FORTRAN:INTRINSIC:ARRAY INQUIRY] Lower dimension bounds of an array'
write(io,'(a)')'leadz (3fortran)     - [FORTRAN:INTRINSIC:BIT INQUIRY] Number of leading zero bits of an integer'
write(io,'(a)')'len (3fortran)       - [FORTRAN:INTRINSIC:CHARACTER] Length of a character entity'
write(io,'(a)')'len_trim (3fortran)  - [FORTRAN:INTRINSIC:CHARACTER] Length of a character entity without trailing blank characters'
write(io,'(a)')'lge (3fortran)       - [FORTRAN:INTRINSIC:CHARACTER] Lexical greater than or equal'
write(io,'(a)')'lgt (3fortran)       - [FORTRAN:INTRINSIC:CHARACTER] Lexical greater than'
write(io,'(a)')'lle (3fortran)       - [FORTRAN:INTRINSIC:CHARACTER] Lexical less than or equal'
write(io,'(a)')'llt (3fortran)       - [FORTRAN:INTRINSIC:CHARACTER] Lexical less than'
write(io,'(a)')'log (3fortran)       - [FORTRAN:INTRINSIC:MATHEMATICS] Logarithm function'
write(io,'(a)')'log10 (3fortran)     - [FORTRAN:INTRINSIC:MATHEMATICS] Base 10 logarithm function'
write(io,'(a)')'log_gamma (3fortran) - [FORTRAN:INTRINSIC:MATHEMATICS] Logarithm of the Gamma function'
write(io,'(a)')'logical (3fortran)   - [FORTRAN:INTRINSIC:BIT MANIPULATION] Bitwise logical and'
write(io,'(a)')'maskl (3fortran)     - [FORTRAN:INTRINSIC] Left justified mask'
write(io,'(a)')'maskr (3fortran)     - [FORTRAN:INTRINSIC] Right justified mask'
write(io,'(a)')'matmul (3fortran)    - [FORTRAN:INTRINSIC:TRANSFORMATIONAL FUNCTION] matrix multiplication'
write(io,'(a)')'max (3fortran)       - [FORTRAN:INTRINSIC:NUMERIC] Maximum value of an argument list'
write(io,'(a)')'maxexponent (3fortran) - [FORTRAN:INTRINSIC] Maximum exponent of a real kind'
write(io,'(a)')'maxloc (3fortran)    - [FORTRAN:INTRINSIC:ARRAY LOCATION] Location of the maximum value within an array'
write(io,'(a)')'maxval (3fortran)    - [FORTRAN:INTRINSIC:ARRAY REDUCTION] determines the maximum value in an array or row'
write(io,'(a)')'merge (3fortran)     - [FORTRAN:INTRINSIC:ARRAY CONSTRUCTION] Merge variables'
write(io,'(a)')'merge_bits (3fortran) - [FORTRAN:INTRINSIC:BIT MANIPULATION] Merge of bits under mask'
write(io,'(a)')'min (3fortran)       - [FORTRAN:INTRINSIC:NUMERIC] Minimum value of an argument list'
write(io,'(a)')'minexponent (3fortran) - [FORTRAN:INTRINSIC] Minimum exponent of a real kind'
write(io,'(a)')'minloc (3fortran)    - [FORTRAN:INTRINSIC:ARRAY LOCATION] Location of the minimum value within an array'
write(io,'(a)')'minval (3fortran)    - [FORTRAN:INTRINSIC:ARRAY REDUCTION] Minimum value of an array'
write(io,'(a)')'mod (3fortran)       - [FORTRAN:INTRINSIC:NUMERIC] Remainder function'
write(io,'(a)')''
write(io,'(a)')'associate (7fortran) - [FORTRAN:EXECUTION CONTROL] associate construct'
write(io,'(a)')'allocate (7fortran)  - [FORTRAN] The ALLOCATE statement dynamically creates pointer targets and allocatable variabl&
   &es.'
write(io,'(a)')'array_constructors (7fortran) - [FORTRAN] An array constructor can be used to create and assign values to rank-one &
   &arrays (and ar...'
write(io,'(a)')'backspace (7fortran) - [FORTRAN:FILE_POSITIONING] - backspace one record on specified I/O unit'
write(io,'(a)')'block (7fortran)     - [FORTRAN:EXECUTION CONTROL] construct'
write(io,'(a)')'case (7fortran)      - [FORTRAN:EXECUTION CONTROL] select a block based on the value of an expression (a case)'
write(io,'(a)')'continue (7fortran)  - [FORTRAN:EXECUTION CONTROL] construct'
write(io,'(a)')'cycle (7fortran)     - [FORTRAN:EXECUTION CONTROL] construct'
write(io,'(a)')'data (7fortran)      - [FORTRAN] DATA statement'
write(io,'(a)')'deallocate (7fortran) - [FORTRAN:STATEMENT] causes allocated variables and targets to be deallocated'
write(io,'(a)')'do (7fortran)        - [FORTRAN:EXECUTION CONTROL] construct'
write(io,'(a)')'endselect (7fortran) - [FORTRAN:EXECUTION CONTROL] select a block based on the value of an expression (a case)'
write(io,'(a)')'exit (7fortran)      - [FORTRAN:EXECUTION CONTROL] statement'
write(io,'(a)')'flush (7fortran)     - [FORTRAN:IO] flush I/O buffers of specified files'
write(io,'(a)')'fortran (7fortran)   - [FORTRAN] Fortran Example'
write(io,'(a)')'fortran_continuation_line (7fortran) - [FORTRAN] Fortran Continuation Lines'
write(io,'(a)')'fortran_recursion (7fortran) - [FORTRAN] Examples of recursion'
write(io,'(a)')'free_source_form (7fortran) - [FORTRAN] syntax of free source form statements, comments, and continuation lines'
write(io,'(a)')'if (7fortran)        - [FORTRAN:EXECUTION CONTROL] selects a block based on a sequence of logical expressions.'
write(io,'(a)')'implicit (7fortran)  - [FORTRAN:STATEMENT] specify default type (if any) associated to a starting letter'
write(io,'(a)')'implied_do (7fortran) - [FORTRAN] documentation on usage of implied do in Fortran'
write(io,'(a)')'include (7fortran)   - [FORTRAN] including source text'
write(io,'(a)')'initialize_arrays (7fortran) - [FORTRAN:FAQ] Initializing small 2D numeric arrays with array constructors'
write(io,'(a)')'inquire (7fortran)   - [FORTRAN:FILE_INQUIRE] File inquiry statement'
write(io,'(a)')'intrinsics (7fortran) - [FORTRAN] intrinsic man(1) pages'
write(io,'(a)')'intrinsics_project (7fortran) - [FORTRAN] intrinsic man(1) pages'
write(io,'(a)')'iso_c_binding (7fortran) - [FORTRAN] standard intrinsic module which defines named constants, types, and procedures&
   & for C interoperability'
write(io,'(a)')'iso_fortran_env (7fortran) - [FORTRAN] standard intrinsic module provides public entities related to the Fortran en&
   &vironment'
write(io,'(a)')'namelist (7fortran)  - [FORTRAN:STATEMENT] specify a group of data to be referred to by a single name in data input&
   &/output'
write(io,'(a)')'nullify (7fortran)   - [FORTRAN:STATEMENT] causes pointers to be disassociated'
write(io,'(a)')'open (7fortran)      - [FORTRAN:IO] Initiates or modifies a connection between an external file and a specified uni&
   &t.'
write(io,'(a)')'pointers (7fortran)  - [FORTRAN] Pointers and targets methods'
write(io,'(a)')''
write(io,'(a)')'modulo (3fortran)    - [FORTRAN:INTRINSIC:NUMERIC] Modulo function'
write(io,'(a)')'move_alloc (3fortran) - [FORTRAN:INTRINSIC] Move allocation from one object to another'
write(io,'(a)')'mvbits (3fortran)    - [FORTRAN:INTRINSIC:BIT MANIPULATION] Move bits from one integer to another'
write(io,'(a)')'nearest (3fortran)   - [FORTRAN:INTRINSIC:MODEL_COMPONENTS] Nearest representable number'
write(io,'(a)')'new_line (3fortran)  - [FORTRAN:INTRINSIC] New line character'
write(io,'(a)')'nint (3fortran)      - [FORTRAN:INTRINSIC:NUMERIC] Nearest whole number'
write(io,'(a)')'norm2 (3fortran)     - [FORTRAN:INTRINSIC:MATHEMATICS] Euclidean vector norm'
write(io,'(a)')'not (3fortran)       - [FORTRAN:INTRINSIC:BIT MANIPULATION] Logical negation'
write(io,'(a)')'notopen (3)          - [M_io] Find a FUN/LUN (Fortran-unit-number) that is not in use'
write(io,'(a)')'null (3fortran)      - [FORTRAN:INTRINSIC:TRANSFORMATIONAL FUNCTION] Function that returns an disassociated pointer'
write(io,'(a)')'num_images (3fortran) - [FORTRAN:INTRINSIC] Number of images'
write(io,'(a)')'pack (3fortran)      - [FORTRAN:INTRINSIC:ARRAY CONSTRUCTION] Pack an array into an array of rank one'
write(io,'(a)')'parity (3fortran)    - [FORTRAN:INTRINSIC:TRANSFORMATIONAL FUNCTION] Reduction with exclusive OR()'
write(io,'(a)')'popcnt (3fortran)    - [FORTRAN:INTRINSIC:BIT INQUIRY] Number of bits set'
write(io,'(a)')'poppar (3fortran)    - [FORTRAN:INTRINSIC:BIT INQUIRY] Parity of the number of bits set'
write(io,'(a)')'precision (3fortran) - [FORTRAN:INTRINSIC] Decimal precision of a real kind'
write(io,'(a)')'present (3fortran)   - [FORTRAN:INTRINSIC] Determine whether an optional dummy argument is specified'
write(io,'(a)')'process_close (3)    - [M_process] Fortran Module for calling process-related C functions from Fortran'
write(io,'(a)')'process_open_read (3) - [M_process] Fortran Module for calling process-related C functions from Fortran'
write(io,'(a)')'process_open_write (3) - [M_process] Fortran Module for calling process-related C functions from Fortran'
write(io,'(a)')'process_readline (3) - [M_process] Fortran Module for calling process-related C functions from Fortran'
write(io,'(a)')'process_writeline (3) - [M_process] Fortran Module for calling process-related C functions from Fortran'
write(io,'(a)')'product (3fortran)   - [FORTRAN:INTRINSIC:ARRAY REDUCTION] Product of array elements'
write(io,'(a)')'protected (7fortran) - [FORTRAN:SPECIFICATION ATTRIBUTE] protect use associated module objects from change outside &
   &of the module'
write(io,'(a)')'pure (7fortran)      - [FORTRAN:SPECIFICATION ATTRIBUTE] Pure procedures'
write(io,'(a)')'radix (3fortran)     - [FORTRAN:INTRINSIC] Base of a model number'
write(io,'(a)')'random_number (3fortran) - [FORTRAN:INTRINSIC] Pseudo-random number'
write(io,'(a)')'random_seed (3fortran) - [FORTRAN:INTRINSIC] Initialize a pseudo-random number sequence'
write(io,'(a)')'range (3fortran)     - [FORTRAN:INTRINSIC] Decimal exponent range of a real kind'
write(io,'(a)')'rank (3fortran)      - [FORTRAN:INTRINSIC:ARRAY INQUIRY] Rank of a data object'
write(io,'(a)')'real (3fortran)      - [FORTRAN:INTRINSIC:NUMERIC] Convert to real type'
write(io,'(a)')'redo (3)             - [M_history] Fortran-based Input History Editor'
write(io,'(a)')'repeat (3fortran)    - [FORTRAN:INTRINSIC:CHARACTER] Repeated string concatenation'
write(io,'(a)')'reshape (3fortran)   - [FORTRAN:INTRINSIC:ARRAY RESHAPE] Function to reshape an array'
write(io,'(a)')'return (3fortran)    - [fortran] completes execution of the instance of the subprogram in which it appears'
write(io,'(a)')'rewind (7fortran)    - [FORTRAN:FILE_POSITIONING] rewind specified sequential access I/O unit'
write(io,'(a)')'rrspacing (3fortran) - [FORTRAN:INTRINSIC:MODEL_COMPONENTS] Reciprocal of the relative spacing'
write(io,'(a)')'same_type_as (3fortran) - [FORTRAN:INTRINSIC] Query dynamic types for equality'
write(io,'(a)')'save (7fortran)      - [FORTRAN:STATEMENT:ATTRIBUTE] specifies that a local variable retains its status and value a&
   &fter a RETURN'
write(io,'(a)')'scale (3fortran)     - [FORTRAN:INTRINSIC:MODEL_COMPONENTS] Scale a real value'
write(io,'(a)')'scan (3fortran)      - [FORTRAN:INTRINSIC:CHARACTER] Scan a string for the presence of a set of characters'
write(io,'(a)')'scratch (7fortran)   - [FORTRAN:OPEN] where scratch files are typically written by OPEN(3f)'
write(io,'(a)')'select (7fortran)    - [FORTRAN:EXECUTION CONTROL] select a block based on the value of an expression (a case)'
write(io,'(a)')'select_type (3fortran) - [FORTRAN:EXECUTION_CONTROL] select_type'
write(io,'(a)')'selected_char_kind (3fortran) - [FORTRAN:INTRINSIC] Choose character kind'
write(io,'(a)')'selected_int_kind (3fortran) - [FORTRAN:INTRINSIC] Choose integer kind'
write(io,'(a)')'selected_real_kind (3fortran) - [FORTRAN:INTRINSIC] Choose real kind'
write(io,'(a)')'set_exponent (3fortran) - [FORTRAN:INTRINSIC:MODEL_COMPONENTS] Set the exponent of the model'
write(io,'(a)')'shape (3fortran)     - [FORTRAN:INTRINSIC:ARRAY INQUIRY] Determine the shape of an array'
write(io,'(a)')'shifta (3fortran)    - [FORTRAN:INTRINSIC:BIT MANIPULATION] shift bits right with fill'
write(io,'(a)')'shiftl (3fortran)    - [FORTRAN:INTRINSIC:BIT MANIPULATION] shift bits left'
write(io,'(a)')'shiftr (3fortran)    - [FORTRAN:INTRINSIC:BIT MANIPULATION] shift bits right'
write(io,'(a)')'sign (3fortran)      - [FORTRAN:INTRINSIC:NUMERIC] Sign copying function'
write(io,'(a)')'sign (7fortran)      - [FORTRAN:IO] option to force optional plus sign on output values'
write(io,'(a)')'sin (3fortran)       - [FORTRAN:INTRINSIC:TRIGONOMETRIC] Sine function'
write(io,'(a)')'sinh (3fortran)      - [FORTRAN:INTRINSIC:TRIGONOMETRIC] Hyperbolic sine function'
write(io,'(a)')'size (3fortran)      - [FORTRAN:INTRINSIC:ARRAY INQUIRY] Determine the size of an array'
write(io,'(a)')'sngl (3fortran)      - [FORTRAN:INTRINSIC] Convert double precision real to default real'
write(io,'(a)')'spacing (3fortran)   - [FORTRAN:INTRINSIC:MODEL_COMPONENTS] Smallest distance between two numbers of a given type'
write(io,'(a)')'spread (3fortran)    - [FORTRAN:INTRINSIC:ARRAY CONSTRUCTION] Add a dimension to an array'
write(io,'(a)')'sqrt (3fortran)      - [FORTRAN:INTRINSIC:MATHEMATICS] Square-root function'
write(io,'(a)')'stop (7fortran)      - [FORTRAN:STATEMENT] initiates termination of execution'
write(io,'(a)')'storage_size (3fortran) - [FORTRAN:INTRINSIC:BIT INQUIRY] Storage size in bits'
write(io,'(a)')'sum (3fortran)       - [FORTRAN:INTRINSIC:ARRAY REDUCTION] sum the elements of an array'
write(io,'(a)')'system_chdir (3)     - [M_system] call chdir(3c) from Fortran to change working directory'
write(io,'(a)')'system_clock (3fortran) - [FORTRAN:INTRINSIC:SYSTEM ENVIRONMENT] Return numeric data from a real-time clock.'
write(io,'(a)')'system_getegid (3)   - [M_system:QUERY] get the effective group ID (GID) of current process from Fortran by calling&
   & getegid(3c)'
write(io,'(a)')'system_getenv (3)    - [M_system:ENVIRONMENT] get environment variable from Fortran by calling get_environment_vari&
   &able(3f)'
write(io,'(a)')'system_geteuid (3)   - [M_system:QUERY] get effective UID of current process from Fortran by calling geteuid(3c)'
write(io,'(a)')'system_getgid (3)    - [M_system:QUERY] get the real group ID (GID) of current process from Fortran by calling getg&
   &id(3c)'
write(io,'(a)')'system_getpid (3)    - [M_system:QUERY] get PID (process ID) of current process from Fortran by calling getpid(3c)'
write(io,'(a)')'system_getppid (3)   - [M_system:QUERY] get parent process ID (PPID) of current process from Fortran by calling get&
   &ppid(3c)'
write(io,'(a)')'system_getuid (3)    - [M_system:QUERY] get real UID of current process from Fortran by calling getuid(3c)'
write(io,'(a)')'system_putenv (3)    - [M_system:ENVIRONMENT] set environment variable from Fortran by calling putenv(3c)'
write(io,'(a)')'system_readline (3)  - [M_readline] Call readline(3c) from Fortran'
write(io,'(a)')'system_uname (3)     - [M_system] call a C wrapper that calls uname(3c) to get current system information from Fort&
   &ran'
write(io,'(a)')'tan (3fortran)       - [FORTRAN:INTRINSIC:TRIGONOMETRIC] Tangent function'
write(io,'(a)')'tanh (3fortran)      - [FORTRAN:INTRINSIC:TRIGONOMETRIC] Hyperbolic tangent function'
write(io,'(a)')'this_image (3fortran) - [FORTRAN:INTRINSIC] Cosubscript index of this image'
write(io,'(a)')'tiny (3fortran)      - [FORTRAN:INTRINSIC] Smallest positive number of a real kind'
write(io,'(a)')'trailz (3fortran)    - [FORTRAN:INTRINSIC:BIT INQUIRY] Number of trailing zero bits of an integer'
write(io,'(a)')'transfer (3fortran)  - [FORTRAN:INTRINSIC:BIT MANIPULATION] Transfer bit patterns'
write(io,'(a)')'transpose (3fortran) - [FORTRAN:INTRINSIC:ARRAY MANIPULATION] Transpose an array of rank two'
write(io,'(a)')'trim (3fortran)      - [FORTRAN:INTRINSIC:CHARACTER] Remove trailing blank characters of a string'
write(io,'(a)')'ubound (3fortran)    - [FORTRAN:INTRINSIC:ARRAY INQUIRY] Upper dimension bounds of an array'
write(io,'(a)')'ufpp (1)             - [DEVELOPER] pre-process FORTRAN source files'
write(io,'(a)')'ufpp_overview (7)    - [DEVELOPER] a Fortran source code pre-processor'
write(io,'(a)')'unicode_example1 (1) - [FORTRAN] UNICODE example'
write(io,'(a)')'unpack (3fortran)    - [FORTRAN:INTRINSIC:ARRAY CONSTRUCTION] Store the elements of a vector in an array of higher &
   &rank'
write(io,'(a)')'upper_quoted (3)     - [M_strings:CASE] ! elemental function converts string to miniscule skipping strings quoted p&
   &er Fortran syn...'
write(io,'(a)')'use (7fortran)       - [FORTRAN] gives a program unit accessibility to public entities in a module.'
write(io,'(a)')'verify (3fortran)    - [FORTRAN:INTRINSIC:CHARACTER] Scan a string for the absence of a set of characters'
write(io,'(a)')'where (7fortran)     - [FORTRAN:ASSIGNMENT] masked array assignment'
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  Sample'
write(io,'(a)')''
write(io,'(a)')'   program demo_fortran'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   character(len=*),parameter :: ident="@(#)example(1f): example program"'
write(io,'(a)')'   integer :: bb'
write(io,'(a)')'   integer :: i_myloop'
write(io,'(a)')'      call sub1(10,bb)'
write(io,'(a)')'      write(*,*)''BB='',bb'
write(io,'(a)')'   !-----------------------------------------------------------------------'
write(io,'(a)')'   MYLOOP: do I_MYLOOP=1,10  ! DO loop'
write(io,'(a)')'      cycle MYLOOP           ! start next pass of loop'
write(io,'(a)')'      exit  MYLOOP           ! go to next statement after corresponding ENDDO'
write(io,'(a)')'   enddo MYLOOP'
write(io,'(a)')'   !-----------------------------------------------------------------------'
write(io,'(a)')'   block'
write(io,'(a)')'   character(LEN=1) :: c'
write(io,'(a)')'   select case (c)'
write(io,'(a)')'   case (''a'' : ''j'')'
write(io,'(a)')'      write(*,*)  ''One of the first ten letters'''
write(io,'(a)')'   case (''l'' : ''p'', ''u'' : ''y'')'
write(io,'(a)')'      write(*,*)  ''One of l, m, n, o, p, u, v, w, x, y'''
write(io,'(a)')'   case (''z'', ''q'' : ''t'')'
write(io,'(a)')'      WRITE(*,*)  ''One of z, q, r, s, t'''
write(io,'(a)')'   case default'
write(io,'(a)')'      write(*,*)  ''Other characters, which may not be letters'''
write(io,'(a)')'   endselect'
write(io,'(a)')'   endblock'
write(io,'(a)')'   !-----------------------------------------------------------------------'
write(io,'(a)')'   CHAR: block'
write(io,'(a)')'   ! ALLOCATABLE CHARACTER ARRAY'
write(io,'(a)')'   character(len=80),allocatable :: help_text(:)'
write(io,'(a)')'   integer                       :: i'
write(io,'(a)')'   help_text=[ &'
write(io,'(a)')'   &''12345678901234567890123456789012345678901234567890123456789012345678901234567890'',&'
write(io,'(a)')'   &''This is example help text for the example program                               '',&'
write(io,'(a)')'   &''The example program uses kracken(3f) for command line parsing.                  '',&'
write(io,'(a)')'   &''                                                                                '',&'
write(io,'(a)')'   &''                                                                                '',&'
write(io,'(a)')'   &''                                                                                '',&'
write(io,'(a)')'   &''                                                                                '']'
write(io,'(a)')'   WRITE(*,''(a)'')(help_text(i),i=1,size(help_text))'
write(io,'(a)')'   endblock CHAR'
write(io,'(a)')'   !-----------------------------------------------------------------------'
write(io,'(a)')''
write(io,'(a)')'     contains'
write(io,'(a)')''
write(io,'(a)')'     subroutine sub1(a,b,c)'
write(io,'(a)')'     integer,intent(in)                                 :: a'
write(io,'(a)')'     integer,intent(out)                                :: b'
write(io,'(a)')'     character(len=:),intent(out),allocatable,optional  :: c'
write(io,'(a)')'        b=2*a'
write(io,'(a)')'        if(present(c))then'
write(io,'(a)')'           c=''Hello World'''
write(io,'(a)')'        endif'
write(io,'(a)')'     end subroutine sub1'
write(io,'(a)')''
write(io,'(a)')'     integer function signum (n)'
write(io,'(a)')'     !An integer signum function'
write(io,'(a)')'     integer,intent(in) :: n'
write(io,'(a)')'     select case (n)'
write(io,'(a)')'     case  (:-1)  ;  signum  =  -1'
write(io,'(a)')'     case  (0)    ;  signum  =   0'
write(io,'(a)')'     case  (1:)   ;  signum  =   1'
write(io,'(a)')'     end select'
write(io,'(a)')'     end function signum'
write(io,'(a)')''
write(io,'(a)')'   end program demo_fortran'
write(io,'(a)')'NAME'
write(io,'(a)')'  iso_fortran_env(7f) - [FORTRAN] standard intrinsic module provides public entities related to the Fortran environ&
   &ment'
write(io,'(a)')'  (LICENSE:PD)'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'   use, intrinsic :: iso_fortran_env, only : integer_kinds, int8, int16, int32, int64'
write(io,'(a)')'   use, intrinsic :: iso_fortran_env, only : real_kinds, real32, real64, real128'
write(io,'(a)')'   use, intrinsic :: iso_fortran_env, only : logical_kinds'
write(io,'(a)')'   use, intrinsic :: iso_fortran_env, only : character_kinds, character_storage_size'
write(io,'(a)')''
write(io,'(a)')'   use, intrinsic :: iso_fortran_env, only : compiler_options, compiler_version'
write(io,'(a)')''
write(io,'(a)')'   use, intrinsic :: iso_fortran_env, only : error_unit, input_unit, output_unit'
write(io,'(a)')''
write(io,'(a)')'   use, intrinsic :: iso_fortran_env, only : file_storage_size, numeric_storage_size'
write(io,'(a)')'   use, intrinsic :: iso_fortran_env, only : iostat_end, iostat_eor, iostat_inquire_internal_unit'
write(io,'(a)')'   use, intrinsic :: iso_fortran_env, only : stat_stopped_image'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'  The intrinsic module ISO_FORTRAN_ENV provides at least the following'
write(io,'(a)')'  public entities relating to the Fortran environment.'
write(io,'(a)')''
write(io,'(a)')'  GENERAL'
write(io,'(a)')''
write(io,'(a)')'  This part of ISO/IEC 1539 defines five standard intrinsic modules: a'
write(io,'(a)')'  Fortran environment module, a set of three modules to support exception'
write(io,'(a)')'  handling and IEEE arithmetic, and a module to support interoperability'
write(io,'(a)')'  with the C programming language.'
write(io,'(a)')''
write(io,'(a)')'  The IEEE_EXCEPTIONS, IEEE_ARITHMETIC, and IEEE_FEATURES intrinsic'
write(io,'(a)')'  modules are described in Clause 14. The intrinsic module ISO_C_BINDING'
write(io,'(a)')'  is described in Clause 15.'
write(io,'(a)')''
write(io,'(a)')'  The types and procedures defined in standard intrinsic modules are'
write(io,'(a)')'  not themselves intrinsic.'
write(io,'(a)')''
write(io,'(a)')'  A processor may extend the standard intrinsic modules to provide public'
write(io,'(a)')'  entities in them in addition to those specified in ISO/IEC 1539.'
write(io,'(a)')''
write(io,'(a)')'  To avoid potential name conflicts with program entities, it is'
write(io,'(a)')'  recommended that a program use the ONLY option in any USE statement'
write(io,'(a)')'  that references a standard intrinsic module.'
write(io,'(a)')''
write(io,'(a)')'  CHARACTER_KINDS'
write(io,'(a)')''
write(io,'(a)')'   The values of the elements of the default integer named constant array'
write(io,'(a)')'   CHARACTER_KINDS are the kind values supported by the processor for'
write(io,'(a)')'   variables of type character. The order of the values is processor'
write(io,'(a)')'   dependent. The size of the array is the number of character kinds'
write(io,'(a)')'   supported.'
write(io,'(a)')''
write(io,'(a)')'  CHARACTER_STORAGE_SIZE'
write(io,'(a)')''
write(io,'(a)')'  The value of the default integer scalar constant CHARACTER_STORAGE_SIZE'
write(io,'(a)')'  is the size expressed in bits of the character storage unit (16.5.3.2).'
write(io,'(a)')''
write(io,'(a)')'  COMPILER_OPTIONS'
write(io,'(a)')''
write(io,'(a)')'  Description             Processor-dependent string describing the'
write(io,'(a)')'                          options that controlled the program translation'
write(io,'(a)')'                          phase.'
write(io,'(a)')''
write(io,'(a)')'  Class                   Inquiry function.'
write(io,'(a)')''
write(io,'(a)')'  Argument                None.'
write(io,'(a)')''
write(io,'(a)')'  Result Characteristics  Default character scalar with'
write(io,'(a)')'                          processor-dependent length.'
write(io,'(a)')''
write(io,'(a)')'  Result Value            A processor-dependent value which describes'
write(io,'(a)')'                          the options that controlled the translation'
write(io,'(a)')'                          phase of program execution.'
write(io,'(a)')''
write(io,'(a)')'  EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'     COMPILER_OPTIONS() might have the value ''/OPTIMIZE /FLOAT=IEEE''.'
write(io,'(a)')''
write(io,'(a)')'  COMPILER_VERSION'
write(io,'(a)')''
write(io,'(a)')'  Description             Processor-dependent string identifying the'
write(io,'(a)')'                          program translation phase.'
write(io,'(a)')''
write(io,'(a)')'  Class                   Inquiry function.'
write(io,'(a)')''
write(io,'(a)')'  Argument                None.'
write(io,'(a)')''
write(io,'(a)')'  Result Characteristics  Default character scalar with'
write(io,'(a)')'                          processor-dependent length.'
write(io,'(a)')''
write(io,'(a)')'  Result Value            A processor-dependent value that identifies'
write(io,'(a)')'                          the name and version of the program translation'
write(io,'(a)')'                          phase of the processor.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  COMPILER_VERSION() might have the value ''Fast KL-10 Compiler Version 7''.'
write(io,'(a)')''
write(io,'(a)')'  For both COMPILER_OPTIONS and COMPILER VERSION the processor should'
write(io,'(a)')'  include relevant information that could be useful in solving problems'
write(io,'(a)')'  found long after the translation phase. For example, compiler release'
write(io,'(a)')'  and patch level, default compiler arguments, environment variable'
write(io,'(a)')'  values, and run time library requirements might be included. A processor'
write(io,'(a)')'  might include this information in an object file automatically,'
write(io,'(a)')'  without the user needing to save the result of this function in'
write(io,'(a)')'  a variable.'
write(io,'(a)')''
write(io,'(a)')'  ERROR_UNIT'
write(io,'(a)')''
write(io,'(a)')'  The value of the default integer scalar constant ERROR_UNIT identifies'
write(io,'(a)')'  the processor-dependent preconnected external unit used for the purpose'
write(io,'(a)')'  of error reporting. This unit may be the same as OUTPUT_UNIT. The'
write(io,'(a)')'  value shall not be -1.'
write(io,'(a)')''
write(io,'(a)')'  FILE_STORAGE_SIZE'
write(io,'(a)')''
write(io,'(a)')'  The value of the default integer scalar constant FILE_STORAGE_SIZE is'
write(io,'(a)')'  the size expressed in bits of the file storage unit.'
write(io,'(a)')''
write(io,'(a)')'  INPUT_UNIT'
write(io,'(a)')''
write(io,'(a)')'  The value of the default integer scalar constant INPUT_UNIT identifies'
write(io,'(a)')'  the same processor-dependent external unit preconnected for sequential'
write(io,'(a)')'  formatted input as the one identified by an asterisk in a READ'
write(io,'(a)')'  statement; this unit is the one used for a READ statement that does'
write(io,'(a)')'  not contain an input/output control list (9.6.4.2). The value shall'
write(io,'(a)')'  not be -1.'
write(io,'(a)')''
write(io,'(a)')'  INTEGER_KINDS'
write(io,'(a)')''
write(io,'(a)')'  The values of the elements of the default integer named constant'
write(io,'(a)')'  array INTEGER_KINDS are the kind values supported by the processor'
write(io,'(a)')'  for variables of type integer. The order of the values is processor'
write(io,'(a)')'  dependent. The size of the array is the number of integer kinds'
write(io,'(a)')'  supported.'
write(io,'(a)')''
write(io,'(a)')'  INT8, INT16, INT32, and INT64'
write(io,'(a)')''
write(io,'(a)')'  The values of these default integer scalar named constants shall be'
write(io,'(a)')'  those of the kind type parameters that specify an INTEGER type whose'
write(io,'(a)')'  storage size expressed in bits is 8, 16, 32, and 64 respectively. If,'
write(io,'(a)')'  for any of these constants, the processor supports more than one'
write(io,'(a)')'  kind of that size, it is processor-dependent which kind value is'
write(io,'(a)')'  provided. If the processor supports no kind of a particular size,'
write(io,'(a)')'  that constant shall be equal to -2 if the processor supports kinds of'
write(io,'(a)')'  a larger size and -1 otherwise.'
write(io,'(a)')''
write(io,'(a)')'  IOSTAT_END'
write(io,'(a)')''
write(io,'(a)')'  The value of the default integer scalar constant IOSTAT_END is'
write(io,'(a)')'  assigned to the variable specified in an IOSTAT= specifier (9.11.5)'
write(io,'(a)')'  if an end-of-file condition occurs during execution of an input/output'
write(io,'(a)')'  statement and no error condition occurs. This value shall be negative.'
write(io,'(a)')''
write(io,'(a)')'  IOSTAT_EOR'
write(io,'(a)')''
write(io,'(a)')'  The value of the default integer scalar constant IOSTAT_EOR is assigned'
write(io,'(a)')'  to the variable specified in an IOSTAT= specifier (9.11.5) if an'
write(io,'(a)')'  end-of-record condition occurs during execution of an input/output'
write(io,'(a)')'  statement and no end-of-file or error condition occurs. This value'
write(io,'(a)')'  shall be negative and different from the value of IOSTAT_END.'
write(io,'(a)')''
write(io,'(a)')'  IOSTAT_INQUIRE_INTERNAL_UNIT'
write(io,'(a)')''
write(io,'(a)')'  The value of the default integer scalar constant'
write(io,'(a)')'  IOSTAT_INQUIRE_INTERNAL_UNIT is assigned to the variable specified in an'
write(io,'(a)')'  IOSTAT= specifier in an INQUIRE statement (9.10) if a file-unit-number'
write(io,'(a)')'  identifies an internal unit in that statement.'
write(io,'(a)')''
write(io,'(a)')'  This can only occur when a user defined derived type input/output'
write(io,'(a)')'  procedure is called by the processor as the result of executing a'
write(io,'(a)')'  parent data transfer statement for an internal unit.'
write(io,'(a)')''
write(io,'(a)')'  LOGICAL_KINDS'
write(io,'(a)')''
write(io,'(a)')'  The values of the elements of the default integer named constant'
write(io,'(a)')'  array LOGICAL KINDS are the kind values supported by the processor'
write(io,'(a)')'  for variables of type logical. The order of the values is processor'
write(io,'(a)')'  dependent. The size of the array is the number of logical kinds'
write(io,'(a)')'  supported.'
write(io,'(a)')''
write(io,'(a)')'  NUMERIC_STORAGE_SIZE'
write(io,'(a)')''
write(io,'(a)')'  The value of the default integer scalar constant NUMERIC_STORAGE_SIZE'
write(io,'(a)')'  is the size expressed in bits of the numeric storage unit (16.5.3.2).'
write(io,'(a)')''
write(io,'(a)')'  OUTPUT_UNIT'
write(io,'(a)')''
write(io,'(a)')'  The value of the default integer scalar constant OUTPUT_UNIT identifies'
write(io,'(a)')'  the same processor-dependent external unit preconnected for sequential'
write(io,'(a)')'  formatted output as the one identified by an asterisk in a WRITE'
write(io,'(a)')'  statement. The value shall not be -1.'
write(io,'(a)')''
write(io,'(a)')'  REAL_KINDS'
write(io,'(a)')''
write(io,'(a)')'  The values of the elements of the default integer named constant'
write(io,'(a)')'  array REAL KINDS are the kind values supported by the processor'
write(io,'(a)')'  for variables of type real. The order of the values is processor'
write(io,'(a)')'  dependent. The size of the array is the number of real kinds supported.'
write(io,'(a)')''
write(io,'(a)')'  REAL32, REAL64, and REAL128'
write(io,'(a)')''
write(io,'(a)')'  The values of these default integer scalar named constants shall be'
write(io,'(a)')'  those of the kind type parameters that specify a REAL type whose storage'
write(io,'(a)')'  size expressed in bits is 32, 64, and 128 respectively. If, for any of'
write(io,'(a)')'  these constants, the processor supports more than one kind of that size,'
write(io,'(a)')'  it is processor-dependent which kind value is provided. If the processor'
write(io,'(a)')'  supports no kind of a particular size, that constant shall be equal'
write(io,'(a)')'  to -2 if the processor supports kinds of a larger size and -1 otherwise.'
write(io,'(a)')''
write(io,'(a)')'  STAT STOPPED IMAGE'
write(io,'(a)')''
write(io,'(a)')'  The value of the default integer scalar constant STAT STOPPED IMAGE is'
write(io,'(a)')'  assigned to the variable specified in a STAT= specifier (6.6.4, 8.5.5)'
write(io,'(a)')'  if execution of the statement with that specifier or argument requires'
write(io,'(a)')'  synchronization with an image that has initiated termination of'
write(io,'(a)')'  execution. This value shall be positive and different from the value'
write(io,'(a)')'  of IOSTAT INQUIRE INTERNAL UNIT.'
write(io,'(a)')'NAME'
write(io,'(a)')'iso_c_binding(7f) - [FORTRAN] standard intrinsic module which defines named constants, types, and procedures for C &
   &interoperability'
write(io,'(a)')'(LICENSE:PD)'
write(io,'(a)')''
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')''
write(io,'(a)')'   Interoperability with C'
write(io,'(a)')'      1 General'
write(io,'(a)')'      2 The ISO C BINDING intrinsic module'
write(io,'(a)')'         15.2.1 Summary of contents'
write(io,'(a)')'         15.2.2 Named constants and derived types in the module'
write(io,'(a)')'         15.2.3 Procedures in the module'
write(io,'(a)')'      3 Interoperability between Fortran and C entities'
write(io,'(a)')'         15.3.1 General'
write(io,'(a)')'         15.3.2 Interoperability of intrinsic types'
write(io,'(a)')'         15.3.3 Interoperability with C pointer types'
write(io,'(a)')'         15.3.4 Interoperability of derived types and C struct types'
write(io,'(a)')'         15.3.5 Interoperability of scalar variables'
write(io,'(a)')'         15.3.6 Interoperability of array variables'
write(io,'(a)')'         15.3.7 Interoperability of procedures and procedure interfaces'
write(io,'(a)')'      4 Interoperation with C global variables'
write(io,'(a)')'         15.4.1 General'
write(io,'(a)')'         15.4.2 Binding labels for common blocks and variables'
write(io,'(a)')'      5 Interoperation with C functions'
write(io,'(a)')'         15.5.1 Definition and reference of interoperable procedures'
write(io,'(a)')'         15.5.2 Binding labels for procedures'
write(io,'(a)')'         15.5.3 Exceptions and IEEE arithmetic procedures'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'[[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'INTRINSIC PROCEDURES'
write(io,'(a)')''
write(io,'(a)')'   The following intrinsic procedures are provided by the module; their'
write(io,'(a)')'   definition can be found in man(1) pages:'
write(io,'(a)')''
write(io,'(a)')'   * c_associated'
write(io,'(a)')'   * c_f_pointer'
write(io,'(a)')'   * c_f_procpointer'
write(io,'(a)')'   * c_funloc'
write(io,'(a)')'   * c_loc'
write(io,'(a)')'   * c_sizeof'
write(io,'(a)')''
write(io,'(a)')'NAMED CONSTANTS'
write(io,'(a)')''
write(io,'(a)')'iso_c_binding(7f) module also provides the following named constants of'
write(io,'(a)')'type default integer, which can be used as `kind` type parameters.'
write(io,'(a)')''
write(io,'(a)')'   #-------------#-------------------------#-----------------------#----------#'
write(io,'(a)')'   | Fortran Type| Named constant          | C type                | Note     |'
write(io,'(a)')'   |-------------|-------------------------|-----------------------|----------|'
write(io,'(a)')'   |  integer    |  c_int                  |  int                  |          |'
write(io,'(a)')'   |  integer    |  c_short                |  short int            |          |'
write(io,'(a)')'   |  integer    |  c_long                 |  long int             |          |'
write(io,'(a)')'   |  integer    |  c_long_long            |  long long int        |          |'
write(io,'(a)')'   |  integer    |  c_signed_char          |  signed char/         |          |'
write(io,'(a)')'   |             |                         |  unsigned  char       |          |'
write(io,'(a)')'   |  integer    |  c_size_t               |  size_t               |          |'
write(io,'(a)')'   |  integer    |  c_int8_t               |  int8_t               |          |'
write(io,'(a)')'   |  integer    |  c_int16_t              |  int16_t              |          |'
write(io,'(a)')'   |  integer    |  c_int32_t              |  int32_t              |          |'
write(io,'(a)')'   |  integer    |  c_int64_t              |  int64_t              |          |'
write(io,'(a)')'   |  integer    |  c_int_least8_t         |  int_least8_t         |          |'
write(io,'(a)')'   |  integer    |  c_int_least16_t        |  int_least16_t        |          |'
write(io,'(a)')'   |  integer    |  c_int_least32_t        |  int_least32_t        |          |'
write(io,'(a)')'   |  integer    |  c_int_least64_t        |  int_least64_t        |          |'
write(io,'(a)')'   |  integer    |  c_int_fast8_t          |  int_fast8_t          |          |'
write(io,'(a)')'   |  integer    |  c_int_fast16_t         |  int_fast16_t         |          |'
write(io,'(a)')'   |  integer    |  c_int_fast32_t         |  int_fast32_t         |          |'
write(io,'(a)')'   |  integer    |  c_int_fast64_t         |  int_fast64_t         |          |'
write(io,'(a)')'   |  integer    |  c_intmax_t             |  intmax_t             |          |'
write(io,'(a)')'   |  integer    |  c_intptr_t             |  intptr_t             |          |'
write(io,'(a)')'   |  integer    |  c_ptrdiff_t            |  intptr_t             | TS 29113 |'
write(io,'(a)')'   |  real       |  c_float                |  float                |          |'
write(io,'(a)')'   |  real       |  c_double               |  double               |          |'
write(io,'(a)')'   |  real       |  c_long_double          |  long double          |          |'
write(io,'(a)')'   |  complex    |  c_float_complex        |  float _Complex       |          |'
write(io,'(a)')'   |  complex    |  c_double_complex       |  double _Complex      |          |'
write(io,'(a)')'   |  complex    |  c_long_double_complex  |  long double _Complex |          |'
write(io,'(a)')'   |  logical    |  c_bool                 |  _Bool                |          |'
write(io,'(a)')'   |  character  |  c_char                 |  char                 |          |'
write(io,'(a)')'   #-------------#-------------------------#-----------------------#----------#'
write(io,'(a)')''
write(io,'(a)')'   -1 if the companion processor defines the corresponding C type'
write(io,'(a)')'   and there is no interoperating Fortran processor kind or -2 if the'
write(io,'(a)')'   C processor does not define the corresponding C type.'
write(io,'(a)')''
write(io,'(a)')'Additionally, the following parameters of type `character(kind=c_char)`'
write(io,'(a)')'are defined.'
write(io,'(a)')''
write(io,'(a)')'   #---------------------#-----------------#--------#'
write(io,'(a)')'   | Name                | C definition    | Value  |'
write(io,'(a)')'   |---------------------|-----------------|--------|'
write(io,'(a)')'   | `c_null_char`       | null character  | `''\0''` |'
write(io,'(a)')'   | `c_alert`           | alert           | `''\a''` |'
write(io,'(a)')'   | `c_backspace`       | backspace       | `''\b''` |'
write(io,'(a)')'   | `c_form_feed`       | form feed       | `''\f''` |'
write(io,'(a)')'   | `c_new_line`        | new line        | `''\n''` |'
write(io,'(a)')'   | `c_carriage_return` | carriage return | `''\r''` |'
write(io,'(a)')'   | `c_horizontal_tab`  | horizontal tab  | `''\t''` |'
write(io,'(a)')'   | `c_vertical_tab`    | vertical tab    | `''\v''` |'
write(io,'(a)')'   #---------------------#-----------------#--------#'
write(io,'(a)')''
write(io,'(a)')'Moreover, the following two named constants are defined:'
write(io,'(a)')''
write(io,'(a)')'   #---------------#----------#'
write(io,'(a)')'   | Name          | Type     |'
write(io,'(a)')'   |---------------|----------|'
write(io,'(a)')'   | c_null_ptr    | c_ptr    |'
write(io,'(a)')'   | c_null_funptr | c_funptr |'
write(io,'(a)')'   #---------------#----------#'
write(io,'(a)')''
write(io,'(a)')'Both are equivalent to the value `NULL` in C.'
write(io,'(a)')''
write(io,'(a)')'INTEROPERABILITY WITH C'
write(io,'(a)')''
write(io,'(a)')'GENERAL'
write(io,'(a)')' 15.1'
write(io,'(a)')''
write(io,'(a)')'  Fortran provides a means of referencing procedures that are defined by'
write(io,'(a)')'  means of the C programming language or procedures that can be described'
write(io,'(a)')'  by C prototypes as defined in 6.7.5.3 of the C International Standard,'
write(io,'(a)')'  even if they are not actually defined by means of C. Conversely,'
write(io,'(a)')'  there is a means of specifying that a procedure defined by a Fortran'
write(io,'(a)')'  subprogram can be referenced from a function defined by means of'
write(io,'(a)')'  C. In addition, there is a means of declaring global variables that'
write(io,'(a)')'  are associated with C variables whose names have external linkage as'
write(io,'(a)')'  defined in 6.2.2 of the C International Standard.'
write(io,'(a)')''
write(io,'(a)')'  The ISO C BINDING module provides access to named constants that'
write(io,'(a)')'  represent kind type parameters of data representations compatible with'
write(io,'(a)')'  C types. Fortran also provides facilities for defining derived types'
write(io,'(a)')'  (4.5) and enumerations (4.6) that correspond to C types.'
write(io,'(a)')''
write(io,'(a)')'  To avoid potential name conflicts with program entities, it'
write(io,'(a)')'  is recommended that a program use the ONLY option in any USE'
write(io,'(a)')'  statement that references the ISO C BINDING intrinsic module.'
write(io,'(a)')''
write(io,'(a)')'THE ISO_C_BINDING INTRINSIC MODULE'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')' NAMED CONSTANTS AND DERIVED TYPES IN THE MODULE'
write(io,'(a)')'  15.2.2'
write(io,'(a)')''
write(io,'(a)')'     The values of C_FLOAT, C_DOUBLE, and C_LONG_DOUBLE shall each be a'
write(io,'(a)')'     valid value for a real kind type parameter on the processor or shall'
write(io,'(a)')'     be -1 if the companion processor''s type does not have a precision'
write(io,'(a)')'     equal to the precision of any of the Fortran processor''s real'
write(io,'(a)')'     kinds, -2 if the companion processor''s type does not have a range'
write(io,'(a)')'     equal to the range of any of the Fortran processor''s real kinds,'
write(io,'(a)')'     -3 if the companion processor''s type has neither the precision'
write(io,'(a)')'     nor range of any of the Fortran processor''s real kinds, and equal'
write(io,'(a)')'     to -4 if there is no interoperating Fortran processor kind for'
write(io,'(a)')'     other reasons.'
write(io,'(a)')''
write(io,'(a)')'     The values of C_FLOAT_COMPLEX, C_DOUBLE_COMPLEX,'
write(io,'(a)')'     and C_LONG_DOUBLE_COMPLEX shall be the same as those of C_FLOAT,'
write(io,'(a)')'     C_DOUBLE, and C_LONG_DOUBLE, respectively.'
write(io,'(a)')''
write(io,'(a)')'     The value of C_BOOL shall be a valid value for a logical kind'
write(io,'(a)')'     parameter on the processor or shall be -1.'
write(io,'(a)')''
write(io,'(a)')'     The value of C_CHAR shall be a valid value for a character kind type'
write(io,'(a)')'     parameter on the processor or shall be -1. The value of C_CHAR is'
write(io,'(a)')'     known as the C character kind.'
write(io,'(a)')''
write(io,'(a)')'     The entity C_NULL_PTR shall be a named constant of type C_PTR. The'
write(io,'(a)')'     value of C_NULL_PTR shall be the same as the value NULL in C. The'
write(io,'(a)')'     entity C_NULL_FUNPTR shall be a named constant of type C_FUNPTR.'
write(io,'(a)')'     The value of C_NULL_FUNPTR shall be that of a null pointer to a'
write(io,'(a)')'     function in C.'
write(io,'(a)')''
write(io,'(a)')'           NOTE 15.2'
write(io,'(a)')'           The value of NEW_LINE(C_NEW_LINE) is C_NEW_LINE (13.7.120).'
write(io,'(a)')''
write(io,'(a)')'PROCEDURES IN THE MODULE'
write(io,'(a)')' 15.2.3'
write(io,'(a)')''
write(io,'(a)')'    In the detailed descriptions below, procedure names are generic and'
write(io,'(a)')'    not specific.'
write(io,'(a)')''
write(io,'(a)')'  C_ASSOCIATED (C_PTR_1 [, C_PTR_2])'
write(io,'(a)')'  15.2.3.2'
write(io,'(a)')''
write(io,'(a)')'   Description. True if and only if C_PTR_1 is associated with an entity and C_PTR_2 is absent, or if C_PTR_1'
write(io,'(a)')'   and C_PTR_2 are associated with the same entity.'
write(io,'(a)')''
write(io,'(a)')'   Class. Inquiry function.'
write(io,'(a)')''
write(io,'(a)')'   Arguments.'
write(io,'(a)')''
write(io,'(a)')'   C_PTR_1    shall be a scalar of type C_PTR or C_FUNPTR.'
write(io,'(a)')'   C_PTR_2    (optional) shall be a scalar of the same type as C_PTR_1.'
write(io,'(a)')''
write(io,'(a)')'  Result Characteristics. Default logical scalar.'
write(io,'(a)')''
write(io,'(a)')'  Result Value.'
write(io,'(a)')''
write(io,'(a)')'  Case (i):      If C_PTR_2 is absent, the result is false if C_PTR_1 is a C null pointer and true otherwise.'
write(io,'(a)')'  Case (ii):     If C_PTR_2 is present, the result is false if C_PTR_1 is a C null pointer. If C_PTR_1 is not a C n&
   &ull'
write(io,'(a)')'                 pointer, the result is true if C_PTR_1 compares equal to C_PTR_2 in the sense of 6.3.2.3 and 6.5.9'
write(io,'(a)')'                 of the C International Standard, and false otherwise.'
write(io,'(a)')''
write(io,'(a)')'  NOTE 15.3'
write(io,'(a)')''
write(io,'(a)')'   The following example illustrates the use of C LOC and C ASSOCIATED.'
write(io,'(a)')''
write(io,'(a)')'       USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_PTR, C_FLOAT, C_ASSOCIATED, C_LOC'
write(io,'(a)')'       INTERFACE'
write(io,'(a)')'         SUBROUTINE FOO(GAMMA) BIND(C)'
write(io,'(a)')'           IMPORT C_PTR'
write(io,'(a)')'           TYPE(C_PTR), VALUE :: GAMMA'
write(io,'(a)')'         END SUBROUTINE FOO'
write(io,'(a)')'       END INTERFACE'
write(io,'(a)')'       REAL(C_FLOAT), TARGET, DIMENSION(100) :: ALPHA'
write(io,'(a)')'       TYPE(C_PTR) :: BETA'
write(io,'(a)')'       ...'
write(io,'(a)')'       IF (.NOT. C_ASSOCIATED(BETA)) THEN'
write(io,'(a)')'         BETA = C_LOC(ALPHA)'
write(io,'(a)')'       ENDIF'
write(io,'(a)')'       CALL FOO(BETA)'
write(io,'(a)')''
write(io,'(a)')'  C_F_POINTER (CPTR, FPTR [, SHAPE])'
write(io,'(a)')'   15.2.3.3'
write(io,'(a)')''
write(io,'(a)')'    Description. Associate a data pointer with the target of a C pointer and specify its shape.'
write(io,'(a)')''
write(io,'(a)')'    Class. Subroutine.'
write(io,'(a)')''
write(io,'(a)')'  Arguments.'
write(io,'(a)')'  CPTR    shall be a scalar of type C_PTR. It is an INTENT(IN) argument. Its value shall be'
write(io,'(a)')'          the C address of an interoperable data entity, or'
write(io,'(a)')'          the result of a reference to C_LOC with a noninteroperable argument.'
write(io,'(a)')'          The value of CPTR shall not be the C address of a Fortran variable that does not have the TARGET'
write(io,'(a)')'          attribute.'
write(io,'(a)')'  FPTR    shall be a pointer, and shall not be a coindexed object. It is an INTENT (OUT) argument.'
write(io,'(a)')'          If the value of CPTR is the C address of an interoperable data entity, FPTR shall be a data pointer'
write(io,'(a)')'          with type and type parameters interoperable with the type of the entity. In this case, FPTR becomes'
write(io,'(a)')'          pointer associated with the target of CPTR. If FPTR is an array, its shape is specified by SHAPE'
write(io,'(a)')'          and each lower bound is 1.'
write(io,'(a)')'          If the value of CPTR is the result of a reference to C LOC with a noninteroperable argument X,'
write(io,'(a)')'          FPTR shall be a nonpolymorphic scalar pointer with the same type and type parameters as X. In'
write(io,'(a)')'          this case, X or its target if it is a pointer shall not have been deallocated or have become undefined'
write(io,'(a)')'          due to execution of a RETURN or END statement since the reference. FPTR becomes pointer'
write(io,'(a)')'          associated with X or its target.'
write(io,'(a)')'  SHAPE   (optional) shall be of type integer and rank one. It is an INTENT (IN) argument. SHAPE shall be'
write(io,'(a)')'          present if and only if FPTR is an array; its size shall be equal to the rank of FPTR.'
write(io,'(a)')''
write(io,'(a)')'C_F_PROCPOINTER (CPTR, FPTR)'
write(io,'(a)')' 15.2.3.4'
write(io,'(a)')''
write(io,'(a)')'  Description. Associate a procedure pointer with the target of a C function pointer.'
write(io,'(a)')''
write(io,'(a)')'  Class. Subroutine.'
write(io,'(a)')''
write(io,'(a)')'  Arguments.'
write(io,'(a)')''
write(io,'(a)')'  CPTR          shall be a scalar of type C_FUNPTR. It is an INTENT (IN) argument. Its value shall be the C'
write(io,'(a)')'                address of a procedure that is interoperable.'
write(io,'(a)')'  FPTR          shall be a procedure pointer, and shall not be a component of a coindexed object. It is an INTENT'
write(io,'(a)')'                (OUT) argument. The interface for FPTR shall be interoperable with the prototype that describes'
write(io,'(a)')'                the target of CPTR. FPTR becomes pointer associated with the target of CPTR.'
write(io,'(a)')''
write(io,'(a)')'    NOTE 15.4'
write(io,'(a)')''
write(io,'(a)')'        The term "target" in the descriptions of C F POINTER and C F PROCPOINTER denotes the entity'
write(io,'(a)')'        referenced by a C pointer, as described in 6.2.5 of the C International Standard.'
write(io,'(a)')''
write(io,'(a)')' C_FUNLOC (X)'
write(io,'(a)')' 15.2.3.5'
write(io,'(a)')''
write(io,'(a)')'  Description. C address of the argument.'
write(io,'(a)')''
write(io,'(a)')'  Class. Inquiry function.'
write(io,'(a)')''
write(io,'(a)')'  Argument. X shall either be a procedure that is interoperable, or a procedure pointer associated with an'
write(io,'(a)')'  interoperable procedure. It shall not be a coindexed object.'
write(io,'(a)')''
write(io,'(a)')'  Result Characteristics. Scalar of type C FUNPTR.'
write(io,'(a)')''
write(io,'(a)')'  Result Value. The result value is described using the result name FPTR. The result is determined as if'
write(io,'(a)')'  C - FUNPTR were a derived type containing an implicit-interface procedure pointer component PX and the pointer'
write(io,'(a)')'  assignment FPTR%PX => X were executed.'
write(io,'(a)')''
write(io,'(a)')'  The result is a value that can be used as an actual FPTR argument in a call to C F PROCPOINTER where'
write(io,'(a)')'  FPTR has attributes that would allow the pointer assignment FPTR => X. Such a call to C F PROCPOINTER'
write(io,'(a)')'  shall have the effect of the pointer assignment FPTR => X.'
write(io,'(a)')''
write(io,'(a)')'  15.2.3.6   C LOC (X)'
write(io,'(a)')''
write(io,'(a)')'  Description. C address of the argument.'
write(io,'(a)')''
write(io,'(a)')'  Class. Inquiry function.'
write(io,'(a)')''
write(io,'(a)')'  Argument. X shall have either the POINTER or TARGET attribute. It shall not be a coindexed object. It'
write(io,'(a)')'  shall either be a contiguous variable with interoperable type and type parameters, or be a scalar, nonpolymorphic'
write(io,'(a)')'  variable with no length type parameters. If it is allocatable, it shall be allocated. If it is a pointer, it shal&
   &l be'
write(io,'(a)')'  associated. If it is an array, it shall have nonzero size.'
write(io,'(a)')''
write(io,'(a)')'  Result Characteristics. Scalar of type C PTR.'
write(io,'(a)')''
write(io,'(a)')'  Result Value. The result value is described using the result name CPTR.'
write(io,'(a)')''
write(io,'(a)')'  If X is a scalar data entity, the result is determined as if C PTR were a derived type containing a scalar pointe&
   &r'
write(io,'(a)')'  component PX of the type and type parameters of X and the pointer assignment CPTR%PX => X were executed.'
write(io,'(a)')''
write(io,'(a)')'  If X is an array data entity, the result is determined as if C PTR were a derived type containing a scalar pointe&
   &r'
write(io,'(a)')'  component PX of the type and type parameters of X and the pointer assignment of CPTR%PX to the first'
write(io,'(a)')'  element of X were executed.'
write(io,'(a)')''
write(io,'(a)')'  If X is a data entity that is interoperable or has interoperable type and type parameters, the result is the valu&
   &e'
write(io,'(a)')'  that the C processor returns as the result of applying the unary "&" operator (as defined in the C International'
write(io,'(a)')'  Standard, 6.5.3.2) to the target of CPTR%PX.'
write(io,'(a)')''
write(io,'(a)')'  The result is a value that can be used as an actual CPTR argument in a call to C F POINTER where FPTR'
write(io,'(a)')'  has attributes that would allow the pointer assignment FPTR => X. Such a call to C F POINTER shall have'
write(io,'(a)')'  the effect of the pointer assignment FPTR => X.'
write(io,'(a)')''
write(io,'(a)')'       NOTE 15.5'
write(io,'(a)')'       Where the actual argument is of noninteroperable type or type parameters, the result of C LOC provides an'
write(io,'(a)')'       opaque "handle" for it. In an actual implementation, this handle might be the C address of the argument;'
write(io,'(a)')'       however, portable C functions should treat it as a void (generic) C pointer that cannot be dereferenced'
write(io,'(a)')'       (6.5.3.2 in the C International Standard).'
write(io,'(a)')''
write(io,'(a)')'  15.2.3.7   C SIZEOF (X)'
write(io,'(a)')''
write(io,'(a)')'  Description. Size of X in bytes.'
write(io,'(a)')''
write(io,'(a)')'  Class. Inquiry function.'
write(io,'(a)')''
write(io,'(a)')'  Argument. X shall be an interoperable data entity that is not an assumed-size array.'
write(io,'(a)')''
write(io,'(a)')'  Result Characteristics. Scalar integer of kind C SIZE T (15.3.2).'
write(io,'(a)')''
write(io,'(a)')'  Result Value. If X is scalar, the result value is the value that the companion processor returns as the result of'
write(io,'(a)')'  applying the sizeof operator (C International Standard, subclause 6.5.3.4) to an object of a type that interopera&
   &tes'
write(io,'(a)')'  with the type and type parameters of X.'
write(io,'(a)')''
write(io,'(a)')'  If X is an array, the result value is the value that the companion processor returns as the result of applying th&
   &e'
write(io,'(a)')'  sizeof operator to an object of a type that interoperates with the type and type parameters of X, multiplied by'
write(io,'(a)')'  the number of elements in X.'
write(io,'(a)')''
write(io,'(a)')'  15.3       Interoperability between Fortran and C entities'
write(io,'(a)')''
write(io,'(a)')'  15.3.1     General'
write(io,'(a)')'  Subclause 15.3 defines the conditions under which a Fortran entity is interoperable. If a Fortran entity is'
write(io,'(a)')'  interoperable, an equivalent entity may be defined by means of C and the Fortran entity interoperates with the C'
write(io,'(a)')'  entity. There does not have to be such an interoperating C entity.'
write(io,'(a)')''
write(io,'(a)')'       NOTE 15.6'
write(io,'(a)')'       A Fortran entity can be interoperable with more than one C entity.'
write(io,'(a)')''
write(io,'(a)')'  15.3.2     Interoperability of intrinsic types'
write(io,'(a)')'  Table 15.2 shows the interoperability between Fortran intrinsic types and C types. A Fortran intrinsic type'
write(io,'(a)')'  with particular type parameter values is interoperable with a C type if the type and kind type parameter value'
write(io,'(a)')'  are listed in the table on the same row as that C type; if the type is character, interoperability also requires'
write(io,'(a)')'  that the length type parameter be omitted or be specified by an initialization expression whose value is one. A'
write(io,'(a)')'  combination of Fortran type and type parameters that is interoperable with a C type listed in the table is also'
write(io,'(a)')'  interoperable with any unqualified C type that is compatible with the listed C type.'
write(io,'(a)')''
write(io,'(a)')'  The second column of the table refers to the named constants made accessible by the ISO C BINDING intrinsic'
write(io,'(a)')'  module. If the value of any of these named constants is negative, there is no combination of Fortran type and'
write(io,'(a)')'  type parameters interoperable with the C type shown in that row.'
write(io,'(a)')''
write(io,'(a)')'  A combination of intrinsic type and type parameters is interoperable if it is interoperable with a C type. The'
write(io,'(a)')'  C types mentioned in table 15.2 are defined in subclauses 6.2.5, 7.17, and 7.18.1 of the C International Standard&
   &.'
write(io,'(a)')''
write(io,'(a)')'                         Table 15.2: Interoperability between Fortran and C types'
write(io,'(a)')'                           Named constant from the ISO C BINDING module'
write(io,'(a)')'       Fortran type                                                        C type'
write(io,'(a)')'                           (kind type parameter if value is positive)'
write(io,'(a)')'                            C_INT                                          int'
write(io,'(a)')'                            C_SHORT                                        short int'
write(io,'(a)')'                            C_LONG                                         long int'
write(io,'(a)')'                            C_LONG_LONG                                    long long int'
write(io,'(a)')'                            C_SIGNED_CHAR                                  signed char'
write(io,'(a)')'                                                                           unsigned char'
write(io,'(a)')'                            C_SIZE_T                                       size t'
write(io,'(a)')'                            C_INT8_T                                       int8 t'
write(io,'(a)')'                            C_INT16_T                                      int16 t'
write(io,'(a)')'                            C_INT32_T                                      int32 t'
write(io,'(a)')'                            C_INT64_T                                      int64 t'
write(io,'(a)')'                            C_INT_LEAST8_T                                 int least8 t'
write(io,'(a)')'                            C_INT_LEAST16_T                                int least16 t'
write(io,'(a)')'                            C_INT_LEAST32_T                                int least32 t'
write(io,'(a)')'       INTEGER              C_INT_LEAST64_T                                int least64 t'
write(io,'(a)')'                            C_INT_FAST8_T                                  int fast8 t'
write(io,'(a)')'                            C_INT_FAST16_T                                 int fast16 t'
write(io,'(a)')'                            C_INT_FAST32_T                                 int fast32 t'
write(io,'(a)')'                            C_INT_FAST64_T                                 int fast64 t'
write(io,'(a)')'                            C_INTMAX_T                                     intmax t'
write(io,'(a)')'                            C_INTPTR_T                                     intptr t'
write(io,'(a)')'                            C_FLOAT                                        float'
write(io,'(a)')'       REAL                 C_DOUBLE                                       double'
write(io,'(a)')'                            C_LONG_DOUBLE                                  long double'
write(io,'(a)')'                            C_FLOAT_COMPLEX                                float Complex'
write(io,'(a)')'       COMPLEX              C_DOUBLE_COMPLEX                               double Complex'
write(io,'(a)')'                            C_LONG_DOUBLE_COMPLEX                          long double Complex'
write(io,'(a)')'       LOGICAL              C_BOOL                                         Bool'
write(io,'(a)')'       CHARACTER            C_CHAR                                         char'
write(io,'(a)')''
write(io,'(a)')'      NOTE 15.7'
write(io,'(a)')'      For example, the type integer with a kind type parameter of C_SHORT is interoperable with the C type'
write(io,'(a)')'      short or any C type derived (via typedef) from short.'
write(io,'(a)')''
write(io,'(a)')'      NOTE 15.8'
write(io,'(a)')'      The C International Standard specifies that the representations for nonnegative signed integers are the'
write(io,'(a)')'      same as the corresponding values of unsigned integers. Because Fortran does not provide direct support for'
write(io,'(a)')'      unsigned kinds of integers, the ISO C BINDING module does not make accessible named constants for their'
write(io,'(a)')'      kind type parameter values. A user can use the signed kinds of integers to interoperate with the unsigned'
write(io,'(a)')'      types and all their qualified versions as well. This has the potentially surprising side effect that the C ty&
   &pe'
write(io,'(a)')'      unsigned char is interoperable with the type integer with a kind type parameter of C SIGNED CHAR.'
write(io,'(a)')''
write(io,'(a)')'  15.3.3     Interoperability with C pointer types'
write(io,'(a)')'  C PTR and C FUNPTR shall be derived types with only private components. No direct component of either of'
write(io,'(a)')'  these types is allocatable or a pointer. C PTR is interoperable with any C object pointer type. C FUNPTR is'
write(io,'(a)')'  interoperable with any C function pointer type.'
write(io,'(a)')''
write(io,'(a)')'       NOTE 15.9'
write(io,'(a)')'       This implies that a C processor is required to have the same representation method for all C object pointer'
write(io,'(a)')'       types and the same representation method for all C function pointer types if the C processor is to be'
write(io,'(a)')'       the target of interoperability of a Fortran processor. The C International Standard does not impose this'
write(io,'(a)')'       requirement.'
write(io,'(a)')''
write(io,'(a)')'       NOTE 15.10'
write(io,'(a)')'       The function C LOC can be used to return a value of type C PTR that is the C address of an allocated'
write(io,'(a)')'       allocatable variable. The function C FUNLOC can be used to return a value of type C FUNPTR that is'
write(io,'(a)')'       the C address of a procedure. For C LOC and C FUNLOC the returned value is of an interoperable type'
write(io,'(a)')'       and thus may be used in contexts where the procedure or allocatable variable is not directly allowed. For'
write(io,'(a)')'       example, it could be passed as an actual argument to a C function.'
write(io,'(a)')''
write(io,'(a)')'       Similarly, type C FUNPTR or C PTR can be used in a dummy argument or structure component and can'
write(io,'(a)')'       have a value that is the C address of a procedure or allocatable variable, even in contexts where a procedur&
   &e'
write(io,'(a)')'       or allocatable variable is not directly allowed.'
write(io,'(a)')''
write(io,'(a)')'  15.3.4     Interoperability of derived types and C struct types'
write(io,'(a)')'  A Fortran derived type is interoperable if it has the BIND attribute.'
write(io,'(a)')''
write(io,'(a)')'  C1501 (R425) A derived type with the BIND attribute shall not have the SEQUENCE attribute.'
write(io,'(a)')''
write(io,'(a)')'  C1502 (R425) A derived type with the BIND attribute shall not have type parameters.'
write(io,'(a)')''
write(io,'(a)')'  C1503 (R425) A derived type with the BIND attribute shall not have the EXTENDS attribute.'
write(io,'(a)')''
write(io,'(a)')'  C1504 (R425) A derived type with the BIND attribute shall not have a type-bound-procedure-part.'
write(io,'(a)')''
write(io,'(a)')'  C1505 (R425) Each component of a derived type with the BIND attribute shall be a nonpointer, nonallocatable'
write(io,'(a)')'        data component with interoperable type and type parameters.'
write(io,'(a)')''
write(io,'(a)')'       NOTE 15.11'
write(io,'(a)')'       The syntax rules and their constraints require that a derived type that is interoperable have components'
write(io,'(a)')'       that are all data entities that are interoperable. No component is permitted to be allocatable or a pointer,'
write(io,'(a)')'       but the value of a component of type C FUNPTR or C PTR may be the C address of such an entity.'
write(io,'(a)')''
write(io,'(a)')'  A Fortran derived type is interoperable with a C struct type if the derived-type definition of the Fortran type'
write(io,'(a)')'  specifies BIND(C) (4.5.2), the Fortran derived type and the C struct type have the same number of components,'
write(io,'(a)')'  and the components of the Fortran derived type have types and type parameters that are interoperable with'
write(io,'(a)')'  the types of the corresponding components of the C struct type. A component of a Fortran derived type and'
write(io,'(a)')'  a component of a C struct type correspond if they are declared in the same relative position in their respective'
write(io,'(a)')'  type definitions.'
write(io,'(a)')''
write(io,'(a)')'       NOTE 15.12'
write(io,'(a)')'       The names of the corresponding components of the derived type and the C struct type need not be the'
write(io,'(a)')'       same.'
write(io,'(a)')''
write(io,'(a)')'  There is no Fortran type that is interoperable with a C struct type that contains a bit field or that contains a'
write(io,'(a)')'  flexible array member. There is no Fortran type that is interoperable with a C union type.'
write(io,'(a)')''
write(io,'(a)')'        NOTE 15.13'
write(io,'(a)')'        For example, the C type myctype, declared below, is interoperable with the Fortran type myftype, declared'
write(io,'(a)')'        below.'
write(io,'(a)')''
write(io,'(a)')'        typedef struct'
write(io,'(a)')'          int m, n;'
write(io,'(a)')'          float r;'
write(io,'(a)')'         myctype'
write(io,'(a)')''
write(io,'(a)')'        USE, INTRINSIC :: ISO_C_BINDING'
write(io,'(a)')'        TYPE, BIND(C) :: MYFTYPE'
write(io,'(a)')'          INTEGER(C_INT) :: I, J'
write(io,'(a)')'          REAL(C_FLOAT) :: S'
write(io,'(a)')'        END TYPE MYFTYPE'
write(io,'(a)')''
write(io,'(a)')'        The names of the types and the names of the components are not significant for the purposes of determining'
write(io,'(a)')'        whether a Fortran derived type is interoperable with a C struct type.'
write(io,'(a)')''
write(io,'(a)')'        NOTE 15.14'
write(io,'(a)')'        The C International Standard requires the names and component names to be the same in order for the types'
write(io,'(a)')'        to be compatible (C International Standard, subclause 6.2.7). This is similar to Fortran''s rule describing'
write(io,'(a)')'        when different derived type definitions describe the same sequence type. This rule was not extended to'
write(io,'(a)')'        determine whether a Fortran derived type is interoperable with a C struct type because the case of identifi&
   &ers'
write(io,'(a)')'        is significant in C but not in Fortran.'
write(io,'(a)')''
write(io,'(a)')'  15.3.5       Interoperability of scalar variables'
write(io,'(a)')'  A scalar Fortran variable is interoperable if its type and type parameters are interoperable, it is not a coarray&
   &,'
write(io,'(a)')'  and it has neither the ALLOCATABLE nor the POINTER attribute.'
write(io,'(a)')''
write(io,'(a)')'  An interoperable scalar Fortran variable is interoperable with a scalar C entity if their types and type paramete&
   &rs'
write(io,'(a)')'  are interoperable.'
write(io,'(a)')''
write(io,'(a)')'  15.3.6       Interoperability of array variables'
write(io,'(a)')'  An array Fortran variable is interoperable if its type and type parameters are interoperable, it is not a coarray&
   &,'
write(io,'(a)')'  and it is of explicit shape or assumed size.'
write(io,'(a)')''
write(io,'(a)')'  An explicit-shape or assumed-size array of rank r, with a shape of e1 ... er is interoperable with a C array'
write(io,'(a)')'  if its size is nonzero and'
write(io,'(a)')'         (1)    either'
write(io,'(a)')'                (a)      the array is assumed-size, and the C array does not specify a size, or'
write(io,'(a)')'                (b)      the array is an explicit-shape array, and the extent of the last dimension (er ) is the sa&
   &me as'
write(io,'(a)')'                         the size of the C array, and'
write(io,'(a)')'         (2)    either'
write(io,'(a)')'                (a)      r is equal to one, and an element of the array is interoperable with an element of the C a&
   &rray,'
write(io,'(a)')''
write(io,'(a)')'                         or'
write(io,'(a)')''
write(io,'(a)')'               (b)   r is greater than one, and an explicit-shape array with shape of e1 . . . er-1 , with the'
write(io,'(a)')'                     same type and type parameters as the original array, is interoperable with a C array of a type'
write(io,'(a)')'                     equal to the element type of the original C array.'
write(io,'(a)')''
write(io,'(a)')'       NOTE 15.15'
write(io,'(a)')'       An element of a multi-dimensional C array is an array type, so a Fortran array of rank one is not'
write(io,'(a)')'       interoperable with a multidimensional C array.'
write(io,'(a)')''
write(io,'(a)')'       NOTE 15.16'
write(io,'(a)')'       An allocatable array or array pointer is never interoperable. Such an array does not meet the requirement'
write(io,'(a)')'       of being an explicit-shape or assumed-size array.'
write(io,'(a)')''
write(io,'(a)')'       NOTE 15.17'
write(io,'(a)')'       For example, a Fortran array declared as'
write(io,'(a)')''
write(io,'(a)')'       INTEGER :: A(18, 3:7, *)'
write(io,'(a)')''
write(io,'(a)')'       is interoperable with a C array declared as'
write(io,'(a)')''
write(io,'(a)')'       int b[][5][18]'
write(io,'(a)')''
write(io,'(a)')'       NOTE 15.18'
write(io,'(a)')'       The C programming language defines null-terminated strings, which are actually arrays of the C type char'
write(io,'(a)')'       that have a C null character in them to indicate the last valid element. A Fortran array of type character'
write(io,'(a)')'       with a kind type parameter equal to C CHAR is interoperable with a C string.'
write(io,'(a)')''
write(io,'(a)')'       Fortran''s rules of sequence association (12.5.2.11) permit a character scalar actual argument to correspond'
write(io,'(a)')'       to a dummy argument array. This makes it possible to argument associate a Fortran character string with'
write(io,'(a)')'       a C string.'
write(io,'(a)')''
write(io,'(a)')'       Note 15.22 has an example of interoperation between Fortran and C strings.'
write(io,'(a)')''
write(io,'(a)')'  15.3.7      Interoperability of procedures and procedure interfaces'
write(io,'(a)')'  A Fortran procedure is interoperable if it has the BIND attribute, that is, if its interface is specified with a'
write(io,'(a)')'  proc-language-binding-spec.'
write(io,'(a)')''
write(io,'(a)')'  A Fortran procedure interface is interoperable with a C function prototype if'
write(io,'(a)')''
write(io,'(a)')'        (1)    the interface has the BIND attribute,'
write(io,'(a)')'        (2)    either'
write(io,'(a)')'               (a)   the interface describes a function whose result variable is a scalar that is interoperable wit&
   &h'
write(io,'(a)')'                     the result of the prototype or'
write(io,'(a)')'               (b)   the interface describes a subroutine and the prototype has a result type of void,'
write(io,'(a)')'        (3)    the number of dummy arguments of the interface is equal to the number of formal parameters of the'
write(io,'(a)')'               prototype,'
write(io,'(a)')'        (4)    any dummy argument with the VALUE attribute is interoperable with the corresponding formal'
write(io,'(a)')'               parameter of the prototype,'
write(io,'(a)')'        (5)    any dummy argument without the VALUE attribute corresponds to a formal parameter of the'
write(io,'(a)')'               prototype that is of a pointer type, and the dummy argument is interoperable with an entity of the'
write(io,'(a)')'               referenced type (C International Standard, 6.2.5, 7.17, and 7.18.1) of the formal parameter, and'
write(io,'(a)')'        (6)    the prototype does not have variable arguments as denoted by the ellipsis (...).'
write(io,'(a)')''
write(io,'(a)')'        NOTE 15.19'
write(io,'(a)')'        The referenced type of a C pointer type is the C type of the object that the C pointer type points to.'
write(io,'(a)')'        For example, the referenced type of the pointer type int * is int.'
write(io,'(a)')''
write(io,'(a)')'        NOTE 15.20'
write(io,'(a)')'        The C language allows specification of a C function that can take a variable number of arguments (C'
write(io,'(a)')'        International Standard, 7.15). This part of ISO/IEC 1539 does not provide a mechanism for Fortran'
write(io,'(a)')'        procedures to interoperate with such C functions.'
write(io,'(a)')''
write(io,'(a)')'  A formal parameter of a C function prototype corresponds to a dummy argument of a Fortran interface if they'
write(io,'(a)')'  are in the same relative positions in the C parameter list and the dummy argument list, respectively.'
write(io,'(a)')''
write(io,'(a)')'        NOTE 15.21'
write(io,'(a)')'        For example, a Fortran procedure interface described by'
write(io,'(a)')''
write(io,'(a)')'        INTERFACE'
write(io,'(a)')'          FUNCTION FUNC(I, J, K, L, M) BIND(C)'
write(io,'(a)')'            USE, INTRINSIC :: ISO_C_BINDING'
write(io,'(a)')'            INTEGER(C_SHORT) :: FUNC'
write(io,'(a)')'            INTEGER(C_INT), VALUE :: I'
write(io,'(a)')'            REAL(C_DOUBLE) :: J'
write(io,'(a)')'            INTEGER(C_INT) :: K, L(10)'
write(io,'(a)')'            TYPE(C_PTR), VALUE :: M'
write(io,'(a)')'          END FUNCTION FUNC'
write(io,'(a)')'        END INTERFACE'
write(io,'(a)')''
write(io,'(a)')'        is interoperable with the C function prototype'
write(io,'(a)')''
write(io,'(a)')'        short func(int i, double *j, int *k, int l[10], void *m)'
write(io,'(a)')''
write(io,'(a)')'        A C pointer may correspond to a Fortran dummy argument of type C PTR with the VALUE attribute or'
write(io,'(a)')'        to a Fortran scalar that does not have the VALUE attribute. In the above example, the C pointers j and'
write(io,'(a)')'        k correspond to the Fortran scalars J and K, respectively, and the C pointer m corresponds to the Fortran'
write(io,'(a)')'        dummy argument M of type C PTR.'
write(io,'(a)')''
write(io,'(a)')'        NOTE 15.22'
write(io,'(a)')'        The interoperability of Fortran procedure interfaces with C function prototypes is only one part of invocat&
   &ion'
write(io,'(a)')'        of a C function from Fortran. There are four pieces to consider in such an invocation: the procedure'
write(io,'(a)')'        reference, the Fortran procedure interface, the C function prototype, and the C function. Conversely,'
write(io,'(a)')'        the invocation of a Fortran procedure from C involves the function reference, the C function prototype,'
write(io,'(a)')'        the Fortran procedure interface, and the Fortran procedure. In order to determine whether a reference is'
write(io,'(a)')'        allowed, it is necessary to consider all four pieces.'
write(io,'(a)')''
write(io,'(a)')'        For example, consider a C function that can be described by the C function prototype'
write(io,'(a)')''
write(io,'(a)')'        void copy(char in[], char out[]);'
write(io,'(a)')''
write(io,'(a)')'        Such a function may be invoked from Fortran as follows:'
write(io,'(a)')''
write(io,'(a)')'          USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_CHAR, C_NULL_CHAR'
write(io,'(a)')'          INTERFACE'
write(io,'(a)')'            SUBROUTINE COPY(IN, OUT) BIND(C)'
write(io,'(a)')'              IMPORT C_CHAR'
write(io,'(a)')'              CHARACTER(KIND=C_CHAR), DIMENSION(*) :: IN, OUT'
write(io,'(a)')'            END SUBROUTINE COPY'
write(io,'(a)')'          END INTERFACE'
write(io,'(a)')''
write(io,'(a)')'           CHARACTER(LEN=10, KIND=C_CHAR) :: &'
write(io,'(a)')'         &      DIGIT_STRING = C_CHAR_''123456789'' // C_NULL_CHAR'
write(io,'(a)')'           CHARACTER(KIND=C_CHAR) :: DIGIT_ARR(10)'
write(io,'(a)')''
write(io,'(a)')'          CALL COPY(DIGIT_STRING, DIGIT_ARR)'
write(io,'(a)')'          PRINT ''(1X, A1)'', DIGIT_ARR(1:9)'
write(io,'(a)')'          END'
write(io,'(a)')''
write(io,'(a)')'       The procedure reference has character string actual arguments. These correspond to character array dummy'
write(io,'(a)')'       arguments in the procedure interface body as allowed by Fortran''s rules of sequence association (12.5.2.11)&
   &.'
write(io,'(a)')'       Those array dummy arguments in the procedure interface are interoperable with the formal parameters of'
write(io,'(a)')'       the C function prototype. The C function is not shown here, but is assumed to be compatible with the C'
write(io,'(a)')'       function prototype.'
write(io,'(a)')''
write(io,'(a)')'  15.4      Interoperation with C global variables'
write(io,'(a)')''
write(io,'(a)')'  15.4.1     General'
write(io,'(a)')'  A C variable whose name has external linkage may interoperate with a common block or with a variable declared'
write(io,'(a)')'  in the scope of a module. The common block or variable shall be specified to have the BIND attribute.'
write(io,'(a)')''
write(io,'(a)')'  At most one variable that is associated with a particular C variable whose name has external linkage is permitted'
write(io,'(a)')'  to be declared within all the Fortran program units of a program. A variable shall not be initially defined by'
write(io,'(a)')'  more than one processor.'
write(io,'(a)')''
write(io,'(a)')'  If a common block is specified in a BIND statement, it shall be specified in a BIND statement with the same'
write(io,'(a)')'  binding label in each scoping unit in which it is declared. A C variable whose name has external linkage interope&
   &rates'
write(io,'(a)')'  with a common block that has been specified in a BIND statement'
write(io,'(a)')'        if the C variable is of a struct type and the variables that are members of the common block are interopera&
   &ble'
write(io,'(a)')'        with corresponding components of the struct type, or'
write(io,'(a)')'        if the common block contains a single variable, and the variable is interoperable with the C variable.'
write(io,'(a)')''
write(io,'(a)')'  There does not have to be an associated C entity for a Fortran entity with the BIND attribute.'
write(io,'(a)')''
write(io,'(a)')'       NOTE 15.23'
write(io,'(a)')'       The following are examples of the usage of the BIND attribute for variables and for a common block.'
write(io,'(a)')'       The Fortran variables, C EXTERN and C2, interoperate with the C variables, c extern and myVariable,'
write(io,'(a)')'       respectively. The Fortran common blocks, COM and SINGLE, interoperate with the C variables, com and'
write(io,'(a)')'       single, respectively.'
write(io,'(a)')''
write(io,'(a)')'       MODULE LINK_TO_C_VARS'
write(io,'(a)')'         USE, INTRINSIC :: ISO_C_BINDING'
write(io,'(a)')'         INTEGER(C_INT), BIND(C) :: C_EXTERN'
write(io,'(a)')'          INTEGER(C_LONG) :: C2'
write(io,'(a)')'          BIND(C, NAME=''myVariable'') :: C2'
write(io,'(a)')''
write(io,'(a)')'          COMMON /COM/ R, S'
write(io,'(a)')'          REAL(C_FLOAT) :: R, S, T'
write(io,'(a)')'          BIND(C) :: /COM/, /SINGLE/'
write(io,'(a)')'          COMMON /SINGLE/ T'
write(io,'(a)')'        END MODULE LINK_TO_C_VARS'
write(io,'(a)')'        int c_extern;'
write(io,'(a)')'        long myVariable;'
write(io,'(a)')'        struct float r, s; com;'
write(io,'(a)')'        float single;'
write(io,'(a)')''
write(io,'(a)')'  15.4.2     Binding labels for common blocks and variables'
write(io,'(a)')'  The binding label of a variable or common block is a default character value that specifies the name by which'
write(io,'(a)')'  the variable or common block is known to the companion processor.'
write(io,'(a)')''
write(io,'(a)')'  If a variable or common block has the BIND attribute with the NAME= specifier and the value of its expression,'
write(io,'(a)')'  after discarding leading and trailing blanks, has nonzero length, the variable or common block has this as its'
write(io,'(a)')'  binding label. The case of letters in the binding label is significant. If a variable or common block has the BIN&
   &D'
write(io,'(a)')'  attribute specified without a NAME= specifier, the binding label is the same as the name of the entity using'
write(io,'(a)')'  lower case letters. Otherwise, the variable or common block has no binding label.'
write(io,'(a)')''
write(io,'(a)')'  The binding label of a C variable whose name has external linkage is the same as the name of the C variable.'
write(io,'(a)')'  A Fortran variable or common block with the BIND attribute that has the same binding label as a C variable'
write(io,'(a)')'  whose name has external linkage is linkage associated (16.5.1.5) with that variable.'
write(io,'(a)')''
write(io,'(a)')'  15.5      Interoperation with C functions'
write(io,'(a)')''
write(io,'(a)')'  15.5.1     Definition and reference of interoperable procedures'
write(io,'(a)')'  A procedure that is interoperable may be defined either by means other than Fortran or by means of a Fortran'
write(io,'(a)')'  subprogram, but not both.'
write(io,'(a)')''
write(io,'(a)')'  If the procedure is defined by means other than Fortran, it shall'
write(io,'(a)')''
write(io,'(a)')'        be describable by a C prototype that is interoperable with the interface,'
write(io,'(a)')'        have a name that has external linkage as defined by 6.2.2 of the C International Standard, and'
write(io,'(a)')'        have the same binding label as the interface.'
write(io,'(a)')''
write(io,'(a)')'  A reference to such a procedure causes the function described by the C prototype to be called as specified in the'
write(io,'(a)')'  C International Standard.'
write(io,'(a)')''
write(io,'(a)')'  A reference in C to a procedure that has the BIND attribute, has the same binding label, and is defined by means'
write(io,'(a)')'  of Fortran, causes the Fortran procedure to be invoked.'
write(io,'(a)')''
write(io,'(a)')'  A procedure defined by means of Fortran shall not invoke setjmp or longjmp (C International Standard, 7.13).'
write(io,'(a)')'  If a procedure defined by means other than Fortran invokes setjmp or longjmp, that procedure shall not cause'
write(io,'(a)')'  any procedure defined by means of Fortran to be invoked. A procedure defined by means of Fortran shall not be'
write(io,'(a)')'  invoked as a signal handler (C International Standard, 7.14.1).'
write(io,'(a)')''
write(io,'(a)')'  If a procedure defined by means of Fortran and a procedure defined by means other than Fortran perform'
write(io,'(a)')'  input/output operations on the same external file, the results are processor dependent (9.5.4).'
write(io,'(a)')''
write(io,'(a)')'  15.5.2     Binding labels for procedures'
write(io,'(a)')'  The binding label of a procedure is a default character value that specifies the name by which a procedure with'
write(io,'(a)')'  the BIND attribute is known to the companion processor.'
write(io,'(a)')''
write(io,'(a)')'  If a procedure has the BIND attribute with the NAME= specifier and the value of its expression, after discarding'
write(io,'(a)')'  leading and trailing blanks, has nonzero length, the procedure has this as its binding label. The case of letters'
write(io,'(a)')'  in the binding label is significant. If a procedure has the BIND attribute with no NAME= specifier, and the'
write(io,'(a)')'  procedure is not a dummy procedure, internal procedure, or procedure pointer, then the binding label of the'
write(io,'(a)')'  procedure is the same as the name of the procedure using lower case letters. Otherwise, the procedure has no'
write(io,'(a)')'  binding label.'
write(io,'(a)')''
write(io,'(a)')'  C1506 A procedure defined in a submodule shall not have a binding label unless its interface is declared in the'
write(io,'(a)')'        ancestor module.'
write(io,'(a)')''
write(io,'(a)')'  The binding label for a C function whose name has external linkage is the same as the C function name.'
write(io,'(a)')''
write(io,'(a)')'       NOTE 15.24'
write(io,'(a)')'       In the following sample, the binding label of C SUB is "c_sub", and the binding label of C FUNC is'
write(io,'(a)')'       "C_funC".'
write(io,'(a)')''
write(io,'(a)')'       SUBROUTINE C_SUB() BIND(C)'
write(io,'(a)')'         ...'
write(io,'(a)')'       END SUBROUTINE C_SUB'
write(io,'(a)')''
write(io,'(a)')'       INTEGER(C_INT) FUNCTION C_FUNC() BIND(C, NAME="C_funC")'
write(io,'(a)')'         USE, INTRINSIC :: ISO_C_BINDING'
write(io,'(a)')'         ...'
write(io,'(a)')'       END FUNCTION C_FUNC'
write(io,'(a)')''
write(io,'(a)')'       The C International Standard permits functions to have names that are not permitted as Fortran names;'
write(io,'(a)')'       it also distinguishes between names that would be considered as the same name in Fortran. For example,'
write(io,'(a)')'       a C name may begin with an underscore, and C names that differ in case are distinct names.'
write(io,'(a)')''
write(io,'(a)')'       The specification of a binding label allows a program to use a Fortran name to refer to a procedure defined'
write(io,'(a)')'       by a companion processor.'
write(io,'(a)')''
write(io,'(a)')'  15.5.3     Exceptions and IEEE arithmetic procedures'
write(io,'(a)')'  A procedure defined by means other than Fortran shall not use signal (C International Standard, 7.14.1) to change'
write(io,'(a)')'  the handling of any exception that is being handled by the Fortran processor.'
write(io,'(a)')''
write(io,'(a)')'  A procedure defined by means other than Fortran shall not alter the floating-point status (14.7) other than by'
write(io,'(a)')'  setting an exception flag to signaling.'
write(io,'(a)')''
write(io,'(a)')'  The values of the floating-point exception flags on entry to a procedure defined by means other than Fortran are'
write(io,'(a)')'  processor-dependent.'
write(io,'(a)')'NAME'
write(io,'(a)')'   fortran_recursion(7f) - [FORTRAN] Examples of recursion'
write(io,'(a)')'   (LICENSE:PD)'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  Sample program that does a simple flood fill using recursion'
write(io,'(a)')''
write(io,'(a)')'   program testit'
write(io,'(a)')'      integer  :: array(20,50)'
write(io,'(a)')'   ! Fill array with rectangles of values'
write(io,'(a)')'      array(:,:)=61 ! fill array'
write(io,'(a)')'      do  i=  5   ,  15;  do  j=  4   ,  45;  array(i  ,  j)=  43;  enddo;  enddo'
write(io,'(a)')'      do  i=  10  ,  12;  do  j=  3   ,  35;  array(i  ,  j)=  45;  enddo;  enddo'
write(io,'(a)')'      do  i=  13  ,  18;  do  j=  2   ,  45;  array(i  ,  j)=  45;  enddo;  enddo'
write(io,'(a)')'      do  i=  2   ,  10;  do  j=  26  ,  49;  array(i  ,  j)=  45;  enddo;  enddo'
write(io,'(a)')'      do  i=  3   ,  8;   do  j=  30  ,  44;  array(i  ,  j)=  42;  enddo;  enddo'
write(io,'(a)')'      do  i=  2   ,  2;   do  j=  2   ,  14;  array(i  ,  j)=  45;  enddo;  enddo'
write(io,'(a)')'   !  print the array assuming the values can be printed as characters'
write(io,'(a)')'      WRITE (*, FMT = ''(50a1)'') ((char(array(i,j)),j=1,50,1),i=1,20,1)'
write(io,'(a)')'   !  pick a point and flood fill value 45 with value 35'
write(io,'(a)')'      call flood_fill(array,10,17,45,35)'
write(io,'(a)')'      write(*,''(a)'')'
write(io,'(a)')'      WRITE (*, FMT = ''(50a1)'') ((char(array(i,j)),j=1,50,1),i=1,20,1)'
write(io,'(a)')'   contains'
write(io,'(a)')'      recursive subroutine flood_fill(array,y,x,old_attribute,new_attribute)'
write(io,'(a)')'   ! Stack-based recursive flood-fill (Four-way)'
write(io,'(a)')'   !'
write(io,'(a)')'   ! Flood fill, also called seed fill, is an algorithm that determines the'
write(io,'(a)')'   ! area connected to a given node in a multi-dimensional array. It is used'
write(io,'(a)')'   ! in pixel-based graphics to "bucket" fill connected, similarly-colored'
write(io,'(a)')'   ! areas with a different color,'
write(io,'(a)')'   !'
write(io,'(a)')'   ! The flood fill algorithm takes three parameters: a start node, a target'
write(io,'(a)')'   ! color, and a replacement color. The algorithm looks for all nodes in the'
write(io,'(a)')'   ! array which are connected to the start node by a path of the target color,'
write(io,'(a)')'   ! and changes them to the replacement color.'
write(io,'(a)')'   !'
write(io,'(a)')'   ! Depending on whether we consider nodes touching at the corners connected'
write(io,'(a)')'   ! or not, we have two variations, Eight-way and Four-way, respectively.'
write(io,'(a)')'   !'
write(io,'(a)')'   ! One implicitly stack-based (recursive) flood-fill implementation (for'
write(io,'(a)')'   ! a two-dimensional array) goes as follows:'
write(io,'(a)')'   !'
write(io,'(a)')'   ! Flood-fill (node, target-color, replacement-color):'
write(io,'(a)')'   !  1. If target-color is equal to replacement-color, return.'
write(io,'(a)')'   !  2. If the color of node is not equal to target-color, return.'
write(io,'(a)')'   !  3. Set the color of node to replacement-color.'
write(io,'(a)')'   !  4. Perform Flood-fill (one step to the west of node, target-color, replacement-color).'
write(io,'(a)')'   !     Perform Flood-fill (one step to the east of node, target-color, replacement-color).'
write(io,'(a)')'   !     Perform Flood-fill (one step to the north of node, target-color, replacement-color).'
write(io,'(a)')'   !     Perform Flood-fill (one step to the south of node, target-color, replacement-color).'
write(io,'(a)')'   !  5. Return.'
write(io,'(a)')'   !'
write(io,'(a)')'   ! Though easy to understand, the implementation of the algorithm above'
write(io,'(a)')'   ! is impractical in languages and environments where stack space is'
write(io,'(a)')'   ! severely constrained. Many other algorithms are available if this is an issue.'
write(io,'(a)')'         integer  ::  array(:,:)'
write(io,'(a)')'         integer  :: y, x, old_attribute, new_attribute'
write(io,'(a)')'         integer  :: test_attribute'
write(io,'(a)')'         test_attribute=array(y,x)'
write(io,'(a)')'         if(test_attribute.eq.new_attribute) return'
write(io,'(a)')'         if(test_attribute.ne.old_attribute) return'
write(io,'(a)')'         array(y,x)=new_attribute'
write(io,'(a)')'         if(x.gt.1)                call flood_fill(array,y,x-1,old_attribute,new_attribute)'
write(io,'(a)')'         if(x.lt.size(array,dim=2))call flood_fill(array,y,x+1,old_attribute,new_attribute)'
write(io,'(a)')'         if(y.gt.1)                call flood_fill(array,y-1,x,old_attribute,new_attribute)'
write(io,'(a)')'         if(y.lt.size(array,dim=1))call flood_fill(array,y+1,x,old_attribute,new_attribute)'
write(io,'(a)')'      end subroutine flood_fill'
write(io,'(a)')'   end program testit'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   fortran_continuation_line(7f) - [FORTRAN] Fortran Continuation Lines'
write(io,'(a)')'   (LICENSE:PD)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'If a statement is too long to fit on a line, it can be continued with'
write(io,'(a)')'the following methods: If a line is ended with an ampersand, &, it will'
write(io,'(a)')'be continued on the next line. Continuation is normally to the first'
write(io,'(a)')'character of the next non-comment line.'
write(io,'(a)')''
write(io,'(a)')'   A = 174.5 * Year   &'
write(io,'(a)')'       + Count / 100'
write(io,'(a)')'The above is equivalent to the following'
write(io,'(a)')''
write(io,'(a)')'   A = 174.5 * Year  + Count / 100'
write(io,'(a)')''
write(io,'(a)')'Note that & is not part of the statement.'
write(io,'(a)')''
write(io,'(a)')'   A = 174.5 * Year   &'
write(io,'(a)')'   !  this is a comment line'
write(io,'(a)')'       + Count / 100'
write(io,'(a)')''
write(io,'(a)')'The above is equivalent to the following, since the comment is ignored'
write(io,'(a)')'by the compiler:'
write(io,'(a)')''
write(io,'(a)')'   A = 174.5 * Year  + Count / 100'
write(io,'(a)')''
write(io,'(a)')'If the first non-blank character of the continuation line is &,'
write(io,'(a)')'continuation is to the first character after the &:'
write(io,'(a)')''
write(io,'(a)')'   A = 174.5 + ThisIsALong&'
write(io,'(a)')'        &VariableName * 123.45'
write(io,'(a)')''
write(io,'(a)')'is equivalent to'
write(io,'(a)')''
write(io,'(a)')'   A = 174.5 + ThisIsALongVariableName * 123.45'
write(io,'(a)')''
write(io,'(a)')'In this case, there should be no spaces between the last character and'
write(io,'(a)')'the & on the first line. For example,'
write(io,'(a)')''
write(io,'(a)')'   A = 174.5 + ThisIsALong   &'
write(io,'(a)')'        &VariableName * 123.45'
write(io,'(a)')''
write(io,'(a)')'is equivalent to'
write(io,'(a)')''
write(io,'(a)')'   A = 174.5 + ThisIsALong   VariableName * 123.45'
write(io,'(a)')''
write(io,'(a)')'Note that there are spaces between ThisIsALong and VariableName. In this'
write(io,'(a)')'way, a token (name and number) can be split over two lines. However,'
write(io,'(a)')'this is not recommended'
write(io,'(a)')''
write(io,'(a)')'SPECIFICALLY'
write(io,'(a)')'3.3.2.4     Free form statement continuation'
write(io,'(a)')''
write(io,'(a)')'1. The character "&" is used to indicate that the current statement is'
write(io,'(a)')'   continued on the next line that is not a'
write(io,'(a)')'   comment line. Comment lines cannot be continued; an "&" in a comment'
write(io,'(a)')'   has no effect. Comments may occur within a continued statement. When'
write(io,'(a)')'   used for continuation, the "&" is not part of the statement. No line'
write(io,'(a)')'   shall contain a single "&" as the only nonblank character or as the'
write(io,'(a)')'   only nonblank character before an "!" that initiates a comment.'
write(io,'(a)')''
write(io,'(a)')'2. If a noncharacter context is to be continued, an "&" shall be the last'
write(io,'(a)')'   nonblank character on the line, or the last'
write(io,'(a)')'   nonblank character before an "!". There shall be a later line that is'
write(io,'(a)')'   not a comment; the statement is continued on the next such line. If'
write(io,'(a)')'   the first nonblank character on that line is an "&", the statement'
write(io,'(a)')'   continues at the next character position following that "&"; otherwise,'
write(io,'(a)')'   it continues with the first character position of that line.'
write(io,'(a)')''
write(io,'(a)')'3. If a lexical token is split across the end of a line, the first nonblank'
write(io,'(a)')'   character on the first following noncomment'
write(io,'(a)')'   line shall be an "&" immediately followed by the successive characters'
write(io,'(a)')'   of the split token.'
write(io,'(a)')''
write(io,'(a)')'4. If a character context is to be continued, an "&" shall be the last'
write(io,'(a)')'   nonblank character on the line and shall not be'
write(io,'(a)')'   followed by commentary. There shall be a later line that is not a'
write(io,'(a)')'   comment; an "&" shall be the first nonblank character on the next such'
write(io,'(a)')'   line and the statement continues with the next character following that'
write(io,'(a)')'  "&".'
write(io,'(a)')''
write(io,'(a)')'So this is OK:'
write(io,'(a)')''
write(io,'(a)')'   POINT=[&   ! define a Point <X,Y,Z>'
write(io,'(a)')'   & 10, &    ! the X component'
write(io,'(a)')'   & 20, &    ! the Y component'
write(io,'(a)')'   & 30  ]    ! the Z component'
write(io,'(a)')''
write(io,'(a)')'because you can have comments after the ampersand when it is not a string.'
write(io,'(a)')'But this is not OK:'
write(io,'(a)')''
write(io,'(a)')'   STRING=[''&   ! create a sentence'
write(io,'(a)')'   & This&      ! first word'
write(io,'(a)')'   & is&        ! second word'
write(io,'(a)')'   & sentence&  ! third word'
write(io,'(a)')'   & a'']        ! forth word (a comment here is OK)'
write(io,'(a)')''
write(io,'(a)')'Because when continuing a string you cannot have a comment after the ampersand.'
write(io,'(a)')'This is OK:'
write(io,'(a)')''
write(io,'(a)')'   STRING=[''&'
write(io,'(a)')'   ! create a sentence'
write(io,'(a)')'   & This&'
write(io,'(a)')'   ! first word'
write(io,'(a)')'   & is&'
write(io,'(a)')'   ! second word'
write(io,'(a)')'   & sentence&'
write(io,'(a)')'   ! third word'
write(io,'(a)')'   & a'']        ! forth word (a comment here is OK)'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'Long strings:'
write(io,'(a)')''
write(io,'(a)')'   Subroutine LongString()'
write(io,'(a)')''
write(io,'(a)')'   Character (len=200) :: string1, String2'
write(io,'(a)')'   string1 = "A very long string that won''t fit on a single &'
write(io,'(a)')'              &line can be made through proper continuation."'
write(io,'(a)')''
write(io,'(a)')'   string2 = "A very long string that won''t fit on a single " // &'
write(io,'(a)')'             "line can be made through proper continuation."'
write(io,'(a)')'   if (string1 == string2) then'
write(io,'(a)')'     print *, "string1 and 2 are identical!"'
write(io,'(a)')'     print *, "string1 & 2=",string1'
write(io,'(a)')'   else'
write(io,'(a)')'     print *, "string1 and 2 don''t match!"'
write(io,'(a)')'   endif'
write(io,'(a)')''
write(io,'(a)')'   End Subroutine LongString'
write(io,'(a)')''
write(io,'(a)')'.so select.7'
write(io,'(a)')'.so select.7'
write(io,'(a)')'NAME'
write(io,'(a)')'   select(7f) - [FORTRAN:EXECUTION CONTROL] select a block based on the value of an expression (a case)'
write(io,'(a)')'   (LICENSE:PD)'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'1 The CASE construct selects for execution at most one of its constituent blocks. The selection is based on the'
write(io,'(a)')'  value of an expression.'
write(io,'(a)')''
write(io,'(a)')'  R810      case-construct               is   select-case-stmt'
write(io,'(a)')'                                                   [ case-stmt'
write(io,'(a)')'                                                        block ] ...'
write(io,'(a)')'                                                   end-select-stmt'
write(io,'(a)')''
write(io,'(a)')'  R811      select-case-stmt             is   [ case-construct-name : ] SELECT CASE  case-expr)'
write(io,'(a)')''
write(io,'(a)')'  R812      case-stmt                    is   CASE case-selector [case-construct-name]'
write(io,'(a)')''
write(io,'(a)')'  R813      end-select-stmt              is   END SELECT [ case-construct-name ]'
write(io,'(a)')''
write(io,'(a)')'  C809      (R810) If the select-case-stmt of a case-construct specifies'
write(io,'(a)')'            a case-construct-name, the corresponding end-select-stmt'
write(io,'(a)')'            shall specify the same case-construct-name. If'
write(io,'(a)')'            the select-case-stmt of a case-construct does not specify a'
write(io,'(a)')'            case-construct-name, the corresponding end-select-stmt shall'
write(io,'(a)')'            not specify a case-construct-name. If a case-stmt specifies'
write(io,'(a)')'            a case-construct-name, the corresponding select-case-stmt'
write(io,'(a)')'            shall specify the same case-construct-name.'
write(io,'(a)')''
write(io,'(a)')'  R814      case-expr                    is scalar-int-expr'
write(io,'(a)')'                                         or scalar-char-expr'
write(io,'(a)')'                                         or scalar-logical-expr'
write(io,'(a)')''
write(io,'(a)')'  R815      case-selector                is (case-value-range-list)'
write(io,'(a)')'                                         or DEFAULT'
write(io,'(a)')''
write(io,'(a)')'  C810      (R810) No more than one of the selectors of one of the CASE statements shall be DEFAULT.'
write(io,'(a)')''
write(io,'(a)')'  R816      case-value-range             is   case-value'
write(io,'(a)')'                                         or   case-value :'
write(io,'(a)')'                                         or   : case-value'
write(io,'(a)')'                                         or   case-value : case-value'
write(io,'(a)')''
write(io,'(a)')'  R817      case-value                   is scalar-int-initialization-expr'
write(io,'(a)')'                                         or scalar-char-initialization-expr'
write(io,'(a)')'                                         or scalar-logical-initialization-expr'
write(io,'(a)')''
write(io,'(a)')'  C811      (R810) For a given case-construct, each case-value shall be'
write(io,'(a)')'            of the same type as case-expr . For character'
write(io,'(a)')'            type, the kind type parameters shall be the same; character'
write(io,'(a)')'            length differences are allowed.'
write(io,'(a)')''
write(io,'(a)')'  C812      (R810) A case-value-range using a colon shall not be used'
write(io,'(a)')'            if case-expr is of type logical.'
write(io,'(a)')''
write(io,'(a)')'  C813      (R810) For a given case-construct, there shall be no possible'
write(io,'(a)')'            value of the case-expr that matches more'
write(io,'(a)')'            than one case-value-range.'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'  8.1.5      CASE construct'
write(io,'(a)')'  8.1.5.1    Purpose and form of the CASE construct'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'  8.1.5.2     Execution of a CASE construct'
write(io,'(a)')''
write(io,'(a)')'   The execution of the SELECT CASE statement causes the case expression'
write(io,'(a)')'   to be evaluated. The resulting value is called the case index. For a'
write(io,'(a)')'   case value range list, a match occurs if the case index matches any'
write(io,'(a)')'   of the case value ranges in the list. For a case index with a value'
write(io,'(a)')'   of c, a match is determined as follows.'
write(io,'(a)')''
write(io,'(a)')'        1. If the case value range contains a single value v without a colon, a match occurs for type logical if'
write(io,'(a)')'           the expression c .EQV. v is true, and a match occurs for type integer or character if the expression'
write(io,'(a)')'           c == v is true.'
write(io,'(a)')'        2. If the case value range is of the form low : high, a match occurs if the expression low <= c .AND.'
write(io,'(a)')'           c <= high is true.'
write(io,'(a)')'        3. If the case value range is of the form low :, a match occurs if the expression low <= c is true.'
write(io,'(a)')'        4. If the case value range is of the form : high, a match occurs if the expression c <= high is true.'
write(io,'(a)')'        5. If no other selector matches and a DEFAULT selector appears, it matches the case index.'
write(io,'(a)')'        6. If no other selector matches and the DEFAULT selector does not appear, there is no match.'
write(io,'(a)')''
write(io,'(a)')'   The block following the CASE statement containing the matching'
write(io,'(a)')'   selector, if any, is executed. This completes execution of the'
write(io,'(a)')'   construct.'
write(io,'(a)')''
write(io,'(a)')'   It is permissible to branch to an end-select-stmt only from within'
write(io,'(a)')'   its CASE construct.'
write(io,'(a)')''
write(io,'(a)')'  8.1.5.3     Examples of CASE constructs'
write(io,'(a)')''
write(io,'(a)')'       An integer signum function:'
write(io,'(a)')''
write(io,'(a)')'       integer function signum (n)'
write(io,'(a)')'       select case (n)'
write(io,'(a)')'       case (:-1)'
write(io,'(a)')'          signum = -1'
write(io,'(a)')'       case (0)'
write(io,'(a)')'          signum = 0'
write(io,'(a)')'       case (1:)'
write(io,'(a)')'          signum = 1'
write(io,'(a)')'       end select'
write(io,'(a)')'       end'
write(io,'(a)')''
write(io,'(a)')'       A code fragment to check for balanced parentheses:'
write(io,'(a)')''
write(io,'(a)')'       character (80) :: line'
write(io,'(a)')'          ...'
write(io,'(a)')'       level = 0'
write(io,'(a)')'       scan_line: do i = 1, 80'
write(io,'(a)')'          check_parens: select case (line (i:i))'
write(io,'(a)')'          case (''('')'
write(io,'(a)')'             level = level + 1'
write(io,'(a)')'          case ('')'')'
write(io,'(a)')'             level = level - 1'
write(io,'(a)')'             if (level < 0) then'
write(io,'(a)')'                print *, ''unexpected right parenthesis'''
write(io,'(a)')'                exit scan_line'
write(io,'(a)')'             end if'
write(io,'(a)')'          case default'
write(io,'(a)')'             ! ignore all other characters'
write(io,'(a)')'           end select check_parens'
write(io,'(a)')'        end do scan_line'
write(io,'(a)')'        if (level > 0) then'
write(io,'(a)')'           print *, ''missing right parenthesis'''
write(io,'(a)')'        end if'
write(io,'(a)')''
write(io,'(a)')'        the following three fragments are equivalent:'
write(io,'(a)')''
write(io,'(a)')'        if (silly == 1) then'
write(io,'(a)')'           call this'
write(io,'(a)')'        else'
write(io,'(a)')'           call that'
write(io,'(a)')'        end if'
write(io,'(a)')'        select case (silly == 1)'
write(io,'(a)')'        case (.true.)'
write(io,'(a)')'           call this'
write(io,'(a)')'        case (.false.)'
write(io,'(a)')'           call that'
write(io,'(a)')'        end select'
write(io,'(a)')'        select case (silly)'
write(io,'(a)')'        case default'
write(io,'(a)')'           call that'
write(io,'(a)')'        case (1)'
write(io,'(a)')'           call this'
write(io,'(a)')'        end select'
write(io,'(a)')''
write(io,'(a)')'        A code fragment showing several selections of one block:'
write(io,'(a)')''
write(io,'(a)')'        select case (n)'
write(io,'(a)')'        case (1, 3:5, 8)        ! selects 1, 3, 4, 5, 8'
write(io,'(a)')'           call sub'
write(io,'(a)')'        case default'
write(io,'(a)')'           call other'
write(io,'(a)')'        end select'
write(io,'(a)')'NAME'
write(io,'(a)')'   where(7f) - [FORTRAN:ASSIGNMENT] masked array assignment'
write(io,'(a)')'           (LICENSE:PD)'
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'  WHERE statement:'
write(io,'(a)')''
write(io,'(a)')'   WHERE ( mask-expr ) where-assignment-stmt'
write(io,'(a)')''
write(io,'(a)')'  WHERE construct without ELSEWHERE:'
write(io,'(a)')''
write(io,'(a)')'     [where-construct-name:] WHERE ( mask-expr )'
write(io,'(a)')'     ELSEWHERE (mask-expr ) [where-construct-name]'
write(io,'(a)')''
write(io,'(a)')'  WHERE construct with ELSEWHEREs:'
write(io,'(a)')''
write(io,'(a)')'     [where-construct-name:] WHERE ( mask-expr )'
write(io,'(a)')'     [ELSEWHERE (mask-expr )'
write(io,'(a)')'        elemental-statements]'
write(io,'(a)')'     [ELSEWHERE (mask-expr )'
write(io,'(a)')'        elemental-statements]'
write(io,'(a)')'           :'
write(io,'(a)')'     [ELSEWHERE'
write(io,'(a)')'        elemental-statements'
write(io,'(a)')'     ]'
write(io,'(a)')'     END WHERE [where-construct-name]'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   A masked array assignment is either a WHERE statement or a WHERE'
write(io,'(a)')'   construct. It is used to mask the evaluation of expressions and'
write(io,'(a)')'   assignment of values in array assignment statements, according to the'
write(io,'(a)')'   value of a logical array expression.'
write(io,'(a)')''
write(io,'(a)')'   where-assignment-stmt that is a defined assignment shall be elemental.'
write(io,'(a)')''
write(io,'(a)')'   A statement that is part of a where-body-construct shall not be a'
write(io,'(a)')'   branch target statement.'
write(io,'(a)')''
write(io,'(a)')'   If a where-construct contains a where-stmt, a masked-elsewhere-stmt, or'
write(io,'(a)')'   another where-construct then each mask-expr within the where-construct'
write(io,'(a)')'   shall have the same shape. In each where-assignment-stmt, the mask-expr'
write(io,'(a)')'   and the variable being defined shall be arrays of the same shape.'
write(io,'(a)')''
write(io,'(a)')'   Examples of a masked array assignment are:'
write(io,'(a)')''
write(io,'(a)')'            WHERE (TEMP > 100.0) TEMP = TEMP - REDUCE_TEMP'
write(io,'(a)')''
write(io,'(a)')'            where (PRESSURE <= 1.0)'
write(io,'(a)')'               PRESSURE = PRESSURE + INC_PRESSURE'
write(io,'(a)')'               TEMP = TEMP - 5.0'
write(io,'(a)')'            elsewhere'
write(io,'(a)')'               RAINING = .TRUE.'
write(io,'(a)')'            endwhere'
write(io,'(a)')''
write(io,'(a)')'   Interpretation of masked array assignments'
write(io,'(a)')''
write(io,'(a)')'   When a WHERE statement or a where-construct-stmt is executed, a control'
write(io,'(a)')'   mask is established. In addition,'
write(io,'(a)')'   when a WHERE construct statement is executed, a pending control'
write(io,'(a)')'   mask is established. If the statement does not appear as part of a'
write(io,'(a)')'   where-body-construct, the mask-expr of the statement is evaluated,'
write(io,'(a)')'   and the control mask is established to be the value of mask-expr . The'
write(io,'(a)')'   pending control mask is established to have the value .NOT. mask-expr'
write(io,'(a)')'   upon execution of a WHERE construct statement that does not appear as'
write(io,'(a)')'   part of a where-body-construct. The mask-expr is evaluated only once.'
write(io,'(a)')''
write(io,'(a)')'   Each statement in a WHERE construct is executed in sequence.'
write(io,'(a)')''
write(io,'(a)')'   Upon execution of a masked-elsewhere-stmt, the following actions take place in sequence.'
write(io,'(a)')''
write(io,'(a)')'   1. The control mask mc is established to have the value of the pending control mask.'
write(io,'(a)')'   2. The pending control mask is established to have the value mc .AND. (.NOT. mask-expr ).'
write(io,'(a)')'   3. The control mask mc is established to have the value mc .AND. mask-expr .'
write(io,'(a)')''
write(io,'(a)')'   The mask-expr is evaluated at most once.'
write(io,'(a)')''
write(io,'(a)')'   Upon execution of an ELSEWHERE statement, the control mask is'
write(io,'(a)')'   established to have the value of the pending'
write(io,'(a)')'   control mask. No new pending control mask value is established.'
write(io,'(a)')''
write(io,'(a)')'   Upon execution of an ENDWHERE statement, the control mask and pending'
write(io,'(a)')'   control mask are established to have the values they had prior to the'
write(io,'(a)')'   execution of the corresponding WHERE construct statement. Following the'
write(io,'(a)')'   execution of a WHERE statement that appears as a where-body-construct,'
write(io,'(a)')'   the control mask is established to have the value it had prior to the'
write(io,'(a)')'   execution of the WHERE statement.'
write(io,'(a)')''
write(io,'(a)')'   The establishment of control masks and the pending control mask'
write(io,'(a)')'   is illustrated with the following example:'
write(io,'(a)')''
write(io,'(a)')'            where(cond1)             ! Statement 1'
write(io,'(a)')'            . . .'
write(io,'(a)')'            elsewhere(cond2)         ! Statement 2'
write(io,'(a)')'            . . .'
write(io,'(a)')'            elsewhere                ! Statement 3'
write(io,'(a)')'            . . .'
write(io,'(a)')'            end where'
write(io,'(a)')''
write(io,'(a)')'   Following execution of statement 1, the control mask has the value'
write(io,'(a)')'   cond1 and the pending control mask has the value .NOT. cond1.'
write(io,'(a)')'   Following execution of statement 2, the control mask has the value'
write(io,'(a)')'   (.NOT. cond1) .AND. cond2 and the pending control mask has the'
write(io,'(a)')'   value (.NOT. cond1) .AND. (.NOT. cond2). Following execution'
write(io,'(a)')'   of statement 3, the control mask has the value (.NOT. cond1)'
write(io,'(a)')'   .AND. (.NOT. cond2). The false condition values are propagated'
write(io,'(a)')'   through the execution of the masked ELSEWHERE statement.'
write(io,'(a)')''
write(io,'(a)')'   Upon execution of a WHERE construct statement that is part of a'
write(io,'(a)')'   where-body-construct, the pending control mask is established to'
write(io,'(a)')'   have the value mc .AND. (.NOT. mask-expr ). The control mask is then'
write(io,'(a)')'   established to have the value mc .AND. mask-expr. The mask-expr is'
write(io,'(a)')'   evaluated at most once.'
write(io,'(a)')''
write(io,'(a)')'   Upon execution of a WHERE statement that is part of a'
write(io,'(a)')'   where-body-construct, the control mask is established to have the'
write(io,'(a)')'   value mc .AND. mask-expr. The pending control mask is not altered.'
write(io,'(a)')''
write(io,'(a)')'   If a nonelemental function reference occurs in the expr or variable'
write(io,'(a)')'   of a where-assignment-stmt or in a mask-expr ,'
write(io,'(a)')'   the function is evaluated without any masked control; that is, all of'
write(io,'(a)')'   its argument expressions are fully evaluated and the function is fully'
write(io,'(a)')'   evaluated. If the result is an array and the reference is not within'
write(io,'(a)')'   the argument list of a nonelemental function, elements corresponding'
write(io,'(a)')'   to true values in the control mask are selected for use in evaluating'
write(io,'(a)')'   the expr, variable or mask-expr.'
write(io,'(a)')''
write(io,'(a)')'   If an elemental operation or function reference occurs in the expr'
write(io,'(a)')'   or variable of a where-assignment-stmt or in a'
write(io,'(a)')'   mask-expr , and is not within the argument list of a nonelemental'
write(io,'(a)')'   function reference, the operation is performed or the function is'
write(io,'(a)')'   evaluated only for the elements corresponding to true values of the'
write(io,'(a)')'   control mask.'
write(io,'(a)')''
write(io,'(a)')'   If an array constructor appears in a where-assignment-stmt or in a'
write(io,'(a)')'   mask-expr , the array constructor is evaluated'
write(io,'(a)')'   without any masked control and then the where-assignment-stmt is'
write(io,'(a)')'   executed or the mask-expr is evaluated.'
write(io,'(a)')''
write(io,'(a)')'   When a where-assignment-stmt is executed, the values of expr that'
write(io,'(a)')'   correspond to true values of the control mask'
write(io,'(a)')'   are assigned to the corresponding elements of the variable.'
write(io,'(a)')''
write(io,'(a)')'   The value of the control mask is established by the execution of a'
write(io,'(a)')'   WHERE statement, a WHERE construct'
write(io,'(a)')'   statement, an ELSEWHERE statement, a masked ELSEWHERE statement, or'
write(io,'(a)')'   an ENDWHERE statement. Subsequent changes to the value of entities'
write(io,'(a)')'   in a mask-expr have no effect on the value of the control mask. The'
write(io,'(a)')'   execution of a function reference in the mask expression of a WHERE'
write(io,'(a)')'   statement is permitted to affect entities in the assignment statement.'
write(io,'(a)')''
write(io,'(a)')'   Examples of function references in masked array assignments are:'
write(io,'(a)')''
write(io,'(a)')'      where (A > 0.0)'
write(io,'(a)')'         A = LOG (A)           ! LOG is invoked only for positive elements.'
write(io,'(a)')'         A = A / SUM (LOG (A)) ! LOG is invoked for all elements'
write(io,'(a)')'                               ! because SUM is transformational.'
write(io,'(a)')'      end where'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample'
write(io,'(a)')''
write(io,'(a)')'   program demo_where'
write(io,'(a)')'   !  Example of WHERE, ELSE WHERE, END WHERE'
write(io,'(a)')'   parameter (nd=10, ndh=nd/2, nduh=nd-ndh-1)'
write(io,'(a)')'   real, dimension(nd):: a=[ (2*j,j=1,nd) ]'
write(io,'(a)')'   real, dimension(nd):: b ! =[ ndh*1.0, 0.0, nduh*2.0 ]'
write(io,'(a)')'   real, dimension(nd):: c ! =[ nd*-77.77 ]'
write(io,'(a)')'   integer iflag(nd)'
write(io,'(a)')'   data b/ndh*1,0.0,nduh*2./,c/nd*-77.77/'
write(io,'(a)')''
write(io,'(a)')'   where (b.ne.0) c=a/b'
write(io,'(a)')'   write (*,2000) c(1:nd)'
write(io,'(a)')'   !'
write(io,'(a)')'   !  The above protects against divide by zero, but doesn''t actually assign'
write(io,'(a)')'   !  values to elements in c when the corresponding element in b is zero'
write(io,'(a)')'   !  The following covers that, and sets a flag when a divide by zero is'
write(io,'(a)')'   !  present'
write(io,'(a)')'   !'
write(io,'(a)')'   where (b(1:nd).ne.0.0)'
write(io,'(a)')'      c=a/b'
write(io,'(a)')'      iflag=0'
write(io,'(a)')'   else where'
write(io,'(a)')'      c=0.0'
write(io,'(a)')'      iflag=1'
write(io,'(a)')'   end where'
write(io,'(a)')''
write(io,'(a)')'   write (*,2000) c(1:nd)'
write(io,'(a)')'   write (*,1000) iflag(1:nd)'
write(io,'(a)')'   1000 format (''iflag= '',/,(10i7))'
write(io,'(a)')'   2000 format (''a/b = '',/,(10f7.2))'
write(io,'(a)')'   end program demo_where'
write(io,'(a)')''
write(io,'(a)')'.so do.7'
write(io,'(a)')'NAME'
write(io,'(a)')'   sign(7f) - [FORTRAN:IO] option to force optional plus sign on output values'
write(io,'(a)')'   (LICENSE:PD)'
write(io,'(a)')''
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'   Program showing control of plus sign on positive numeric output'
write(io,'(a)')''
write(io,'(a)')'      implicit none'
write(io,'(a)')'      complex :: x=(123.456,987.654)'
write(io,'(a)')'      integer :: i=789'
write(io,'(a)')'      real    :: a=12.3456'
write(io,'(a)')'      integer :: j'
write(io,'(a)')'      namelist /nlist/ i,a,x'
write(io,'(a)')'      open(unit=6,sign=''plus'')'
write(io,'(a)')'      write(*,*)''PASS WHERE FILE HAS SIGN="PLUS"'''
write(io,'(a)')'      do j=1,2'
write(io,'(a)')'         write(*,*) ''LIST DIRECTED '',a,i,x'
write(io,'(a)')'         write(*,''(*(g0:,1x))'') ''GENERAL FORMATTED'',a,i,x'
write(io,'(a)')'         write(*,''(*(ss,g0:,1x))'') ''GENERAL FORMATTED EXPLICIT SUPPRESS'',a,i,x'
write(io,'(a)')'         write(*,''(*(sp,g0:,1x))'') ''GENERAL FORMATTED EXPLICIT PLUS'',a,i,x'
write(io,'(a)')'         write(*,''(a,1x,f8.4,1x,i4,1x,f9.4,1x,f9.4)'') ''FORMATTED'',a,i,x'
write(io,'(a)')'         write(*,''(a,1x,f8.4,1x,i4,1x,f9.4,1x,f9.4)'') ''FORMATTED'',a,i,x'
write(io,'(a)')'         write(*,nlist)'
write(io,'(a)')'         if(j.eq.2)exit'
write(io,'(a)')'         write(*,*)'
write(io,'(a)')'         open(unit=6,sign=''suppress'')'
write(io,'(a)')'         write(*,*)''PASS WHERE FILE HAS SIGN="SUPPRESS"'''
write(io,'(a)')'      enddo'
write(io,'(a)')'      end'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'    REWIND(7f) - [FORTRAN:FILE_POSITIONING] rewind specified sequential access I/O unit'
write(io,'(a)')'    (LICENSE:PD)'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'   REWIND file-unit-number'
write(io,'(a)')''
write(io,'(a)')'    REWIND ( [UNIT=]file-unit-number][,IOMSG=iomsg-variable][,IOSTAT=scalar-int-variable][,ERR=label] )'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   Execution of a REWIND statement causes the file connected to the'
write(io,'(a)')'   specified unit to be positioned at the beginning of the file (its'
write(io,'(a)')'   initial point).'
write(io,'(a)')''
write(io,'(a)')'   If the file is already positioned at its initial point, execution of'
write(io,'(a)')'   this statement has no effect on the position of the file.'
write(io,'(a)')''
write(io,'(a)')'   Execution of a REWIND statement for a file that is connected but does'
write(io,'(a)')'   not exist is permitted and has no effect on any file.'
write(io,'(a)')''
write(io,'(a)')'OPTIONS'
write(io,'(a)')'   UNIT     unit number of file to rewound.'
write(io,'(a)')'            A unit open for direct access or unformatted access cannot'
write(io,'(a)')'            be referenced by a REWIND.'
write(io,'(a)')'   IOSTAT   a compiler-specific number that indicates an error occurred'
write(io,'(a)')'            if non-zero.'
write(io,'(a)')'   IOMSG    a message describing error IOSTAT if IOSTAT is not zero.'
write(io,'(a)')'   ERR      a label number to jump to if an error occurs'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  An example of a REWIND statement is:'
write(io,'(a)')''
write(io,'(a)')'   program demo_rewind'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   character(len=256) :: line'
write(io,'(a)')'   character(len=256) :: mssge'
write(io,'(a)')'   integer            :: i'
write(io,'(a)')'   integer            :: ios'
write(io,'(a)')'      open(10,file=''demo_rewind.txt'') ! open a file'
write(io,'(a)')'      do i=1,100                      ! write lines to it'
write(io,'(a)')'         write(10,''(a,i0)'') ''line '',i'
write(io,'(a)')'      enddo'
write(io,'(a)')'      rewind(10, iostat=ios,iomsg=mssge)'
write(io,'(a)')'      if(ios.ne.0)then'
write(io,'(a)')'         write(*,*)''*error* '',trim(mssge)'
write(io,'(a)')'         stop'
write(io,'(a)')'      endif'
write(io,'(a)')'      write(*,*)''wrote 100 lines, but now at line ...'''
write(io,'(a)')'      read(10,''(a)'')line'
write(io,'(a)')'      write(*,''(a)'')line'
write(io,'(a)')'      read(10)'
write(io,'(a)')'      read(10)'
write(io,'(a)')'      read(10)'
write(io,'(a)')'      write(*,*)''skipped a few lines, now at ...'''
write(io,'(a)')'      read(10,''(a)'')line'
write(io,'(a)')'      write(*,''(a)'')line'
write(io,'(a)')'      close(10,status=''delete'')'
write(io,'(a)')'   end program demo_rewind'
write(io,'(a)')'NAME'
write(io,'(a)')'   BACKSPACE(7f) - [FORTRAN:FILE_POSITIONING] - backspace one record on specified I/O unit'
write(io,'(a)')'   (LICENSE:PD)'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'   BACKSPACE file-unit-number'
write(io,'(a)')'   BACKSPACE ([UNIT=]file-unit-number][,IOMSG=iomsg-variable][,IOSTAT=scalar-int-variable][,ERR=label])'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   Execution of a BACKSPACE statement causes the file connected to the'
write(io,'(a)')'   specified unit to be positioned before the current record if there is a'
write(io,'(a)')'   current record, or before the preceding record if there is no current'
write(io,'(a)')'   record. If the file is at its initial point, the position of the file is'
write(io,'(a)')'   not changed.'
write(io,'(a)')''
write(io,'(a)')'   It is usually used when a program has partially read a line and then wants'
write(io,'(a)')'   to go back and reread the line using the information from the first read.'
write(io,'(a)')'   Backspacing can be very inefficient (Note that positioning to specific'
write(io,'(a)')'   records in direct access files is typically much faster). It is usually'
write(io,'(a)')'   better to read the line into a CHARACTER variable and then read from the'
write(io,'(a)')'   variable multiple times using an internal READ, or parsing the string.'
write(io,'(a)')''
write(io,'(a)')'   Backspacing over records written using list-directed or namelist formatting'
write(io,'(a)')'   is prohibited. It will usually work, but since the compiler is free to'
write(io,'(a)')'   write list-directed or namelist output on a varying number of lines it is'
write(io,'(a)')'   not supported, as it is not certain what data is on which line.'
write(io,'(a)')''
write(io,'(a)')'   Backspacing a file that is connected but does not exist is prohibited.'
write(io,'(a)')''
write(io,'(a)')'   If a BACKSPACE statement causes the implicit writing of an endfile record,'
write(io,'(a)')'   the file is positioned before the record that precedes the endfile record.'
write(io,'(a)')''
write(io,'(a)')'   If the preceding record is an endfile record, the file is positioned before'
write(io,'(a)')'   the endfile record.'
write(io,'(a)')''
write(io,'(a)')'OPTIONS'
write(io,'(a)')'   UNIT     unit number of file to backspace one line on.'
write(io,'(a)')'            A unit open for direct access or unformatted access cannot'
write(io,'(a)')'            be referenced by a BACKSPACE.'
write(io,'(a)')'   IOSTAT   a compiler-specific number that indicates an error occurred'
write(io,'(a)')'            if non-zero.'
write(io,'(a)')'   IOMSG    a message describing error IOSTAT if IOSTAT is not zero.'
write(io,'(a)')'   ERR      a label number to jump to if an error occurs'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  An example of a BACKSPACE statement is:'
write(io,'(a)')''
write(io,'(a)')'   program demo_backspace'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   character(len=256) :: line'
write(io,'(a)')'   character(len=256) :: mssge'
write(io,'(a)')'   integer            :: i'
write(io,'(a)')'   integer            :: ios'
write(io,'(a)')'      open(10,file=''demo_backspace.txt'') ! open a file'
write(io,'(a)')'      do i=1,100                         ! write lines to it'
write(io,'(a)')'         write(10,''(a,i0)'') ''line '',i'
write(io,'(a)')'      enddo'
write(io,'(a)')'      do i=1,10                          ! back up several lines'
write(io,'(a)')'         backspace(10, iostat=ios,iomsg=mssge)'
write(io,'(a)')'         if(ios.ne.0)then'
write(io,'(a)')'                 write(*,''(*(a))'') ''*demo_backspace* ERROR:'',mssge'
write(io,'(a)')'         endif'
write(io,'(a)')'      enddo'
write(io,'(a)')'      read(10,''(a)'')line'
write(io,'(a)')'      write(*,*)''back at a previous record !'''
write(io,'(a)')'      write(*,''(1x,a)'')line'
write(io,'(a)')'      !! writing new line will truncate file to current record position'
write(io,'(a)')'      close(10,status=''delete'')'
write(io,'(a)')'   end program demo_backspace'
write(io,'(a)')''
write(io,'(a)')'  Expected Results:'
write(io,'(a)')''
write(io,'(a)')'    back at a previous record !'
write(io,'(a)')'    line 91'
write(io,'(a)')'.\" Specification of Fortran'
write(io,'(a)')'.TH DO "7" "January 2017" "Fortran" "Language Specification"'
write(io,'(a)')'.SH NAME'
write(io,'(a)')'   DO(7f) - [FORTRAN:EXECUTION CONTROL] construct (LICENSE:PD)'
write(io,'(a)')'.SH SYNOPSIS'
write(io,'(a)')'.nf'
write(io,'(a)')'!-----------------------------------------------------------------------'
write(io,'(a)')'   MYLOOP: do I_MYLOOP=1,10  ! DO loop'
write(io,'(a)')'      cycle MYLOOP           ! start next pass of loop'
write(io,'(a)')'      exit  MYLOOP           ! go to next statement after corresponding ENDDO'
write(io,'(a)')'   enddo MYLOOP'
write(io,'(a)')'!-----------------------------------------------------------------------'
write(io,'(a)')'   READ (IUN, ''(1X, G14.7)'', IOSTAT = IOS) X'
write(io,'(a)')'   DO WHILE (IOS == 0)'
write(io,'(a)')'      IF (X >= 0.) THEN'
write(io,'(a)')'         CALL SUBA (X)'
write(io,'(a)')'         CALL SUBB (X)'
write(io,'(a)')'              ...'
write(io,'(a)')'         CALL SUBZ (X)'
write(io,'(a)')'      ENDIF'
write(io,'(a)')'      READ (IUN, ''(1X, G14.7)'', IOSTAT = IOS) X'
write(io,'(a)')'   END DO'
write(io,'(a)')'!-----------------------------------------------------------------------'
write(io,'(a)')'.fi'
write(io,'(a)')''
write(io,'(a)')'.SH DESCRIPTION'
write(io,'(a)')'.nf'
write(io,'(a)')'  8.1.7     DO construct'
write(io,'(a)')'  8.1.7.1    Purpose and form of the DO construct'
write(io,'(a)')''
write(io,'(a)')'1 The DO construct specifies the repeated execution of a sequence of'
write(io,'(a)')'  executable constructs. Such a repeated sequence is called a loop.'
write(io,'(a)')''
write(io,'(a)')'2 The number of iterations of a loop may be determined at the beginning'
write(io,'(a)')'  of execution of the DO construct, or'
write(io,'(a)')'  may be left indefinite ("DO forever" or DO WHILE). Except in the case'
write(io,'(a)')'  of a DO CONCURRENT construct, the loop can be terminated immediately'
write(io,'(a)')'  (8.1.7.6.4). The current iteration of the loop may be curtailed by'
write(io,'(a)')'  executing a CYCLE statement (8.1.7.6.3).'
write(io,'(a)')''
write(io,'(a)')'3 There are three phases in the execution of a DO construct: initiation'
write(io,'(a)')'  of the loop, execution of the loop range,'
write(io,'(a)')'  and termination of the loop.'
write(io,'(a)')''
write(io,'(a)')'4 The DO CONCURRENT construct is a DO construct whose DO statement'
write(io,'(a)')'  contains the CONCURRENT keyword.'
write(io,'(a)')''
write(io,'(a)')'5 The DO construct may be written in either a block form or a nonblock form.'
write(io,'(a)')''
write(io,'(a)')'  R821      do-construct                     is block-do-construct'
write(io,'(a)')'                                             or nonblock-do-construct'
write(io,'(a)')''
write(io,'(a)')'  8.1.7.2    Form of the block DO construct'
write(io,'(a)')''
write(io,'(a)')'  R822      block-do-construct               is   do-stmt'
write(io,'(a)')'                                                      do-block'
write(io,'(a)')'                                                      end-do'
write(io,'(a)')''
write(io,'(a)')'  R823      do-stmt                          is label-do-stmt'
write(io,'(a)')'                                             or nonlabel-do-stmt'
write(io,'(a)')''
write(io,'(a)')'  R824      label-do-stmt                    is   [ do-construct-name : ] DO label [ loop-control ]'
write(io,'(a)')''
write(io,'(a)')'  R825      nonlabel-do-stmt                 is   [ do-construct-name : ] DO [ loop-control ]'
write(io,'(a)')''
write(io,'(a)')'  R826      loop-control                     is [ , ] do-variable = scalar-int-expr , scalar-int-expr'
write(io,'(a)')'                                                   [ , scalar-int-expr ]'
write(io,'(a)')'                                             or [ , ] WHILE ( scalar-logical-expr )'
write(io,'(a)')'                                             or [ , ] CONCURRENT forall-header'
write(io,'(a)')''
write(io,'(a)')'  R827      do-variable                      is   scalar-int-variable-name'
write(io,'(a)')''
write(io,'(a)')'  C816      (R827) The do-variable shall be a variable of type integer.'
write(io,'(a)')''
write(io,'(a)')'  R828      do-block                         is   block'
write(io,'(a)')''
write(io,'(a)')'  R829      end-do                           is end-do-stmt'
write(io,'(a)')'                                             or continue-stmt'
write(io,'(a)')''
write(io,'(a)')'  R830      end-do-stmt                      is   END DO [ do-construct-name ]'
write(io,'(a)')''
write(io,'(a)')'  C817      (R822) If the do-stmt of a block-do-construct specifies a'
write(io,'(a)')'            do-construct-name, the corresponding end-do'
write(io,'(a)')'            shall be an end-do-stmt specifying the same'
write(io,'(a)')'            do-construct-name. If the do-stmt of a block-do-construct'
write(io,'(a)')'            does not specify a do-construct-name, the corresponding'
write(io,'(a)')'            end-do shall not specify a do-construct-name.'
write(io,'(a)')''
write(io,'(a)')'  C818      (R822) If the do-stmt is a nonlabel-do-stmt, the corresponding'
write(io,'(a)')'            end-do shall be an end-do-stmt.'
write(io,'(a)')''
write(io,'(a)')'  C819      (R822) If the do-stmt is a label-do-stmt, the corresponding'
write(io,'(a)')'             end-do shall be identified with the same label .'
write(io,'(a)')''
write(io,'(a)')'  8.1.7.3    Form of the nonblock DO construct'
write(io,'(a)')'  R831      nonblock-do-construct            is   action-term-do-construct'
write(io,'(a)')'                                             or   outer-shared-do-construct'
write(io,'(a)')''
write(io,'(a)')'  R832      action-term-do-construct         is   label-do-stmt'
write(io,'(a)')'                                                        do-body'
write(io,'(a)')'                                                        do-term-action-stmt'
write(io,'(a)')''
write(io,'(a)')'  R833      do-body                          is   [ execution-part-construct ] ...'
write(io,'(a)')''
write(io,'(a)')'  R834      do-term-action-stmt              is   action-stmt'
write(io,'(a)')''
write(io,'(a)')'  C820      (R834) A do-term-action-stmt shall not be an allstop-stmt,'
write(io,'(a)')'             arithmetic-if-stmt,'
write(io,'(a)')'             continue-stmt, cycle-stmt, end-function-stmt,'
write(io,'(a)')'             end-mp-subprogram-stmt, end-program-stmt,'
write(io,'(a)')'             end-subroutine-stmt, exit-stmt, goto-stmt, return-stmt,'
write(io,'(a)')'             or stop-stmt.'
write(io,'(a)')''
write(io,'(a)')'    C821      (R831) The do-term-action-stmt shall be identified with'
write(io,'(a)')'              a label and the corresponding'
write(io,'(a)')'              label-do-stmt shall refer to the same label.'
write(io,'(a)')''
write(io,'(a)')'    R835      outer-shared-do-construct          is   label-do-stmt'
write(io,'(a)')'                                                            do-body'
write(io,'(a)')'                                                            shared-term-do-construct'
write(io,'(a)')''
write(io,'(a)')'    R836      shared-term-do-construct           is   outer-shared-do-construct'
write(io,'(a)')'                                                 or   inner-shared-do-construct'
write(io,'(a)')''
write(io,'(a)')'    R837      inner-shared-do-construct          is   label-do-stmt'
write(io,'(a)')'                                                            do-body'
write(io,'(a)')'                                                            do-term-shared-stmt'
write(io,'(a)')''
write(io,'(a)')'    R838      do-term-shared-stmt                is   action-stmt'
write(io,'(a)')''
write(io,'(a)')'    C822      (R838) A do-term-shared-stmt shall not be an allstop-stmt,'
write(io,'(a)')'              arithmetic-if-stmt,'
write(io,'(a)')'              cycle-stmt, end-function-stmt, end-program-stmt,'
write(io,'(a)')'              end-mp-subprogram-stmt, end-subroutine-stmt, exit-stmt,'
write(io,'(a)')'              goto-stmt, return-stmt, or stop-stmt.'
write(io,'(a)')''
write(io,'(a)')'    C823      (R836) The do-term-shared-stmt shall be identified with'
write(io,'(a)')'              a label and all of the label-do-stmts'
write(io,'(a)')'              of the inner-shared-do-construct and'
write(io,'(a)')'              outer-shared-do-construct shall refer to the same label.'
write(io,'(a)')''
write(io,'(a)')'1 The do-term-action-stmt, do-term-shared-stmt, or'
write(io,'(a)')'  shared-term-do-construct following the do-body of a nonblock DO'
write(io,'(a)')'  construct is called the DO termination of that construct.'
write(io,'(a)')''
write(io,'(a)')'2 Within a scoping unit, all DO constructs whose DO statements refer to'
write(io,'(a)')'  the same label are nonblock DO constructs, and share the'
write(io,'(a)')'  statement identified by that label.'
write(io,'(a)')''
write(io,'(a)')'    8.1.7.4      Range of the DO construct'
write(io,'(a)')''
write(io,'(a)')'1 The range of a block DO construct is the do-block , which shall satisfy'
write(io,'(a)')'  the rules for blocks (8.1.2). In particular,'
write(io,'(a)')'  transfer of control to the interior of such a block from outside the'
write(io,'(a)')'  block is prohibited. It is permitted to branch to the end-do of a'
write(io,'(a)')'  block DO construct only from within the range of that DO construct.'
write(io,'(a)')''
write(io,'(a)')'2 The range of a nonblock DO construct consists of the do-body and the'
write(io,'(a)')'  following DO termination. The end of such a range is not'
write(io,'(a)')'  bounded by a particular statement as for the other executable'
write(io,'(a)')'  constructs (e.g., END IF); nevertheless, the range satisfies the rules'
write(io,'(a)')'  for blocks (8.1.2). Transfer of control into the do-body or to the'
write(io,'(a)')'  DO termination from outside the range is prohibited; in particular,'
write(io,'(a)')'  it is permitted to branch to a do-term-shared-stmt only from within'
write(io,'(a)')'  the range of the corresponding inner-shared-do-construct.'
write(io,'(a)')''
write(io,'(a)')'    8.1.7.5      Active and inactive DO constructs'
write(io,'(a)')''
write(io,'(a)')'1 A DO construct is either active or inactive. Initially inactive,'
write(io,'(a)')'  a DO construct becomes active only when its'
write(io,'(a)')'  DO statement is executed.'
write(io,'(a)')''
write(io,'(a)')'2 Once active, the DO construct becomes inactive only when it terminates'
write(io,'(a)')'  (8.1.7.6.4).'
write(io,'(a)')''
write(io,'(a)')'    8.1.7.6      Execution of a DO construct'
write(io,'(a)')''
write(io,'(a)')'    8.1.7.6.1     Loop initiation'
write(io,'(a)')''
write(io,'(a)')'1 When the DO statement is executed, the DO construct becomes active. If loop-control is'
write(io,'(a)')''
write(io,'(a)')'2       [ , ] do-variable = scalar-int-expr 1 , scalar-int-expr 2 [ , scalar-int-expr 3 ]'
write(io,'(a)')''
write(io,'(a)')'3 the following steps are performed in sequence.'
write(io,'(a)')'          1.    The initial parameter m1 , the terminal parameter m2 ,'
write(io,'(a)')'                and the incrementation parameter m3 are'
write(io,'(a)')'                of type integer with the same kind type parameter'
write(io,'(a)')'                as the do-variable. Their values are established by'
write(io,'(a)')'                evaluating scalar-int-expr 1 , scalar-int-expr 2 , and'
write(io,'(a)')'                scalar-int-expr 3 , respectively, including, if necessary,'
write(io,'(a)')'                conversion to the kind type parameter of the'
write(io,'(a)')'                do-variable according to the rules for numeric conversion'
write(io,'(a)')'                (Table 7.11). If scalar-int-expr 3 does not appear,'
write(io,'(a)')'                m3 has the value 1. The value of m3'
write(io,'(a)')'                shall not be zero.'
write(io,'(a)')'          2.    The DO variable becomes defined with the value of the initial parameter m1 .'
write(io,'(a)')'          3.    The iteration count is established and is the value of'
write(io,'(a)')'                the expression (m2 - m1 + m3 )/m3 , unless that value is negative,'
write(io,'(a)')'                in which case the iteration count is 0.'
write(io,'(a)')''
write(io,'(a)')'        NOTE 8.11'
write(io,'(a)')'        The iteration count is zero whenever:'
write(io,'(a)')''
write(io,'(a)')'              m1 > m2 and m3 > 0, or'
write(io,'(a)')'              m1 < m2 and m3 < 0.'
write(io,'(a)')''
write(io,'(a)')'4 If loop-control is omitted, no iteration count is calculated. The'
write(io,'(a)')'  effect is as if a large positive iteration count,'
write(io,'(a)')'  impossible to decrement to zero, were established. If loop-control is'
write(io,'(a)')'  [ , ] WHILE (scalar-logical-expr ), the effect is as if loop-control'
write(io,'(a)')'  were omitted and the following statement inserted as the first statement'
write(io,'(a)')'  of the do-block :'
write(io,'(a)')''
write(io,'(a)')'5 IF (.NOT. (scalar-logical-expr )) EXIT'
write(io,'(a)')''
write(io,'(a)')'6 For a DO CONCURRENT construct, the values of the index variables for'
write(io,'(a)')'  the iterations of the construct are'
write(io,'(a)')'  determined by the rules for the index variables of the FORALL construct'
write(io,'(a)')'  (7.2.4.2.2 and 7.2.4.2.3).'
write(io,'(a)')''
write(io,'(a)')'7 An index-name in a DO CONCURRENT construct has a scope of the construct'
write(io,'(a)')'  (16.4). It is a scalar variable'
write(io,'(a)')'  that has the type and type parameters that it would have if it were'
write(io,'(a)')'  the name of a variable in the scoping unit that includes the construct,'
write(io,'(a)')'  and this type shall be integer type; it has no other attributes.'
write(io,'(a)')''
write(io,'(a)')'8 At the completion of the execution of the DO statement, the execution'
write(io,'(a)')'  cycle begins.'
write(io,'(a)')''
write(io,'(a)')'  8.1.7.6.2     The execution cycle'
write(io,'(a)')''
write(io,'(a)')'1 The execution cycle of a DO construct that is not a DO CONCURRENT'
write(io,'(a)')'  construct consists of the following steps performed in sequence'
write(io,'(a)')'  repeatedly until termination.'
write(io,'(a)')''
write(io,'(a)')'          1.    The iteration count, if any, is tested. If it is zero,'
write(io,'(a)')'                the loop terminates and the DO construct becomes'
write(io,'(a)')'                inactive. If loop-control is [ , ] WHILE'
write(io,'(a)')'                (scalar-logical-expr ), the scalar-logical-expr is'
write(io,'(a)')'                evaluated; if the value of this expression is false, the'
write(io,'(a)')'                loop terminates and the DO construct becomes inactive. If,'
write(io,'(a)')'                as a result, all of the DO constructs sharing the'
write(io,'(a)')'                do-term-shared-stmt are inactive, the execution of all'
write(io,'(a)')'                of these constructs is complete. However, if some of the'
write(io,'(a)')'                DO constructs sharing the do-term-shared-stmt are active,'
write(io,'(a)')'                execution continues with step (3) of the execution cycle'
write(io,'(a)')'                of the active DO construct whose DO statement was most'
write(io,'(a)')'                recently executed.'
write(io,'(a)')'          2.    The range of the loop is executed.'
write(io,'(a)')'          3.    The iteration count, if any, is decremented by one. The'
write(io,'(a)')'                DO variable, if any, is incremented by the'
write(io,'(a)')'                value of the incrementation parameter m3 .'
write(io,'(a)')''
write(io,'(a)')'  Except for the incrementation of the DO variable that occurs in step'
write(io,'(a)')'  (3), the DO variable shall neither be redefined'
write(io,'(a)')'  nor become undefined while the DO construct is active.'
write(io,'(a)')''
write(io,'(a)')'  The range of a DO CONCURRENT construct is executed for all of the'
write(io,'(a)')'  active combinations of the index-name'
write(io,'(a)')'  values. Each execution of the range is an iteration. The executions'
write(io,'(a)')'  may occur in any order.'
write(io,'(a)')''
write(io,'(a)')'  8.1.7.6.3     CYCLE statement'
write(io,'(a)')''
write(io,'(a)')'  Execution of the range of the loop may be curtailed by executing a'
write(io,'(a)')'  CYCLE statement from within the range of the loop.'
write(io,'(a)')''
write(io,'(a)')'  R839     cycle-stmt                         is   CYCLE [ do-construct-name ]'
write(io,'(a)')''
write(io,'(a)')'  C824     (R839) If a do-construct-name appears, the CYCLE statement'
write(io,'(a)')'           shall be within the range of that do-construct;'
write(io,'(a)')'           otherwise, it shall be within the range of at'
write(io,'(a)')'           least one do-construct.'
write(io,'(a)')''
write(io,'(a)')'  C825     (R839) A cycle-stmt shall not appear within the range of a'
write(io,'(a)')'           DO CONCURRENT construct if it belongs to an outer construct.'
write(io,'(a)')''
write(io,'(a)')'2 A CYCLE statement belongs to a particular DO construct. If the CYCLE'
write(io,'(a)')'  statement contains a DO construct name, it belongs to that DO construct;'
write(io,'(a)')'  otherwise, it belongs to the innermost DO construct in which it appears.'
write(io,'(a)')''
write(io,'(a)')'3 Execution of a CYCLE statement that belongs to a DO construct that is'
write(io,'(a)')'  not a DO CONCURRENT construct'
write(io,'(a)')'  causes immediate progression to step (3) of the current execution'
write(io,'(a)')'  cycle of the DO construct to which it belongs. If this construct is a'
write(io,'(a)')'  nonblock DO construct, the do-term-action-stmt or do-term-shared-stmt'
write(io,'(a)')'  is not executed.'
write(io,'(a)')''
write(io,'(a)')'4 Execution of a CYCLE statement that belongs to a DO CONCURRENT construct'
write(io,'(a)')'  completes execution of that iteration of the construct.'
write(io,'(a)')''
write(io,'(a)')'5 In a block DO construct, a transfer of control to the end-do has the'
write(io,'(a)')'  same effect as execution of a CYCLE statement'
write(io,'(a)')'  belonging to that construct. In a nonblock DO construct, transfer'
write(io,'(a)')'  of control to the do-term-action-stmt or do-term-shared-stmt causes'
write(io,'(a)')'  that statement to be executed. Unless a further transfer of control'
write(io,'(a)')'  results, step (3) of the current execution cycle of the DO construct'
write(io,'(a)')'  is then executed.'
write(io,'(a)')''
write(io,'(a)')'  8.1.7.6.4    Loop termination'
write(io,'(a)')''
write(io,'(a)')'1 For a DO construct that is not a DO CONCURRENT construct, the loop'
write(io,'(a)')'  terminates, and the DO construct becomes inactive, when any of the'
write(io,'(a)')'  following occurs.'
write(io,'(a)')''
write(io,'(a)')'        The iteration count is determined to be zero or the'
write(io,'(a)')'      scalar-logical-expr is false, when tested during step (1)'
write(io,'(a)')'        of the above execution cycle.'
write(io,'(a)')''
write(io,'(a)')'        An EXIT statement that belongs to the DO construct is executed.'
write(io,'(a)')''
write(io,'(a)')'        An EXIT or CYCLE statement that belongs to an outer construct'
write(io,'(a)')'      and is within the range of the DO'
write(io,'(a)')'        construct is executed.'
write(io,'(a)')''
write(io,'(a)')'        Control is transferred from a statement within the range of a'
write(io,'(a)')'        DO construct to a statement that is neither'
write(io,'(a)')'        the end-do nor within the range of the same DO construct.'
write(io,'(a)')''
write(io,'(a)')'        A RETURN statement within the range of the DO construct is executed.'
write(io,'(a)')''
write(io,'(a)')'2 For a DO CONCURRENT construct, the loop terminates, and the DO construct'
write(io,'(a)')'  becomes inactive when all of the iterations have completed execution.'
write(io,'(a)')''
write(io,'(a)')'3 When a DO construct becomes inactive, the DO variable, if any, of the'
write(io,'(a)')'  DO construct retains its last defined value.'
write(io,'(a)')''
write(io,'(a)')'  8.1.7.7     Restrictions on DO CONCURRENT constructs'
write(io,'(a)')''
write(io,'(a)')'  C826      A RETURN statement shall not appear within a DO CONCURRENT construct.'
write(io,'(a)')''
write(io,'(a)')'  C827      A branch (8.2) within a DO CONCURRENT construct shall not have a branch target that is outside'
write(io,'(a)')'            the construct.'
write(io,'(a)')''
write(io,'(a)')'  C828      A reference to a nonpure procedure shall not appear within a DO CONCURRENT construct.'
write(io,'(a)')''
write(io,'(a)')'  C829      A reference to the procedure IEEE GET FLAG, IEEE SET HALTING MODE, or IEEE GET HALT'
write(io,'(a)')'            ING MODE from the intrinsic module IEEE EXCEPTIONS, shall not appear within a DO CONCURRENT construct.'
write(io,'(a)')''
write(io,'(a)')'1 The following additional restrictions apply to DO CONCURRENT constructs.'
write(io,'(a)')''
write(io,'(a)')'      A variable that is referenced in an iteration shall either be'
write(io,'(a)')'      previously defined during that iteration, or shall not be defined'
write(io,'(a)')'      or become undefined during any other iteration of the current'
write(io,'(a)')'      execution of the construct. A variable that is defined or becomes'
write(io,'(a)')'      undefined by more than one iteration of the current execution of'
write(io,'(a)')'      the construct becomes undefined when the current execution of'
write(io,'(a)')'      the construct terminates. A pointer that is referenced in an'
write(io,'(a)')'      iteration either shall be previously pointer associated during'
write(io,'(a)')'      that iteration, or shall not have its pointer association changed'
write(io,'(a)')'      during any iteration. A pointer that has its pointer association'
write(io,'(a)')'      changed in more than one iteration has an association status of'
write(io,'(a)')'      undefined when the construct terminates.'
write(io,'(a)')''
write(io,'(a)')'     An allocatable object that is allocated in more than one iteration'
write(io,'(a)')'     shall be subsequently deallocated during the same iteration in which'
write(io,'(a)')'     it was allocated. An object that is allocated or deallocated in'
write(io,'(a)')'     only one iteration shall not be deallocated, allocated, referenced,'
write(io,'(a)')'     defined, or become undefined in a different iteration.'
write(io,'(a)')'     An input/output statement shall not write data to a file record or'
write(io,'(a)')'     position in one iteration and read from the same record or position'
write(io,'(a)')'     in a different iteration of the same execution of the construct.'
write(io,'(a)')'     Records written by output statements in the loop range to a'
write(io,'(a)')'     sequential access file appear in the file in an indeterminate order.'
write(io,'(a)')''
write(io,'(a)')'      NOTE 8.12'
write(io,'(a)')'      The restrictions on referencing variables defined in an iteration'
write(io,'(a)')'      of a DO CONCURRENT construct apply to any procedure invoked within'
write(io,'(a)')'      the loop.'
write(io,'(a)')''
write(io,'(a)')'      NOTE 8.13'
write(io,'(a)')'      The restrictions on the statements in the loop range of a DO'
write(io,'(a)')'      CONCURRENT construct are designed to ensure there are no data'
write(io,'(a)')'      dependencies between iterations of the loop. This permits code'
write(io,'(a)')'      optimizations that might otherwise be difficult or impossible'
write(io,'(a)')'      because they would depend on properties of the program not visible'
write(io,'(a)')'      to the compiler.'
write(io,'(a)')'.fi'
write(io,'(a)')'.SH EXAMPLES'
write(io,'(a)')'.nf'
write(io,'(a)')'8.1.7.8    Examples of DO constructs'
write(io,'(a)')''
write(io,'(a)')'      NOTE 8.14'
write(io,'(a)')'      The following program fragment computes a tensor product of two arrays:'
write(io,'(a)')''
write(io,'(a)')'      DO I = 1, M'
write(io,'(a)')'         DO J = 1, N'
write(io,'(a)')'            C (I, J) = DOT_PRODUCT (A (I, J, :), B(:, I, J))'
write(io,'(a)')'         END DO'
write(io,'(a)')'      END DO'
write(io,'(a)')''
write(io,'(a)')'      NOTE 8.15'
write(io,'(a)')'      The following program fragment contains a DO construct that uses the'
write(io,'(a)')'      WHILE form of loop-control . The loop will continue to execute until'
write(io,'(a)')'      an end-of-file or input/output error is encountered, at which point'
write(io,'(a)')'      the DO statement terminates the loop. When a negative value of X'
write(io,'(a)')'      is read, the program skips immediately to the next READ statement,'
write(io,'(a)')'      bypassing most of the range of the loop.'
write(io,'(a)')''
write(io,'(a)')'      READ (IUN, ''(1X, G14.7)'', IOSTAT = IOS) X'
write(io,'(a)')'      DO WHILE (IOS == 0)'
write(io,'(a)')'         IF (X >= 0.) THEN'
write(io,'(a)')'            CALL SUBA (X)'
write(io,'(a)')'            CALL SUBB (X)'
write(io,'(a)')'                 ...'
write(io,'(a)')'            CALL SUBZ (X)'
write(io,'(a)')'         ENDIF'
write(io,'(a)')'         READ (IUN, ''(1X, G14.7)'', IOSTAT = IOS) X'
write(io,'(a)')'      END DO'
write(io,'(a)')''
write(io,'(a)')'      NOTE 8.16'
write(io,'(a)')'      The following example behaves exactly the same as the one in Note'
write(io,'(a)')'      8.15. However, the READ statement has been moved to the interior'
write(io,'(a)')'      of the range, so that only one READ statement is needed. Also, a'
write(io,'(a)')'      CYCLE statement has been used to avoid an extra level of IF nesting.'
write(io,'(a)')''
write(io,'(a)')'      DO      ! A "DO WHILE + 1/2" loop'
write(io,'(a)')'          READ (IUN, ''(1X, G14.7)'', IOSTAT = IOS) X'
write(io,'(a)')'          IF (IOS /= 0) EXIT'
write(io,'(a)')'          IF (X < 0.) CYCLE'
write(io,'(a)')'          CALL SUBA (X)'
write(io,'(a)')'          CALL SUBB (X)'
write(io,'(a)')'             . . .'
write(io,'(a)')'          CALL SUBZ (X)'
write(io,'(a)')'       END DO'
write(io,'(a)')''
write(io,'(a)')'       NOTE 8.17'
write(io,'(a)')'       The following example represents a case in which the user knows'
write(io,'(a)')'       that there are no repeated values in the index array IND. The DO'
write(io,'(a)')'       CONCURRENT construct makes it easier for the processor to generate'
write(io,'(a)')'       vector gather/scatter code, unroll the loop, or parallelize the'
write(io,'(a)')'       code for this loop, potentially improving performance.'
write(io,'(a)')''
write(io,'(a)')'       INTEGER :: A(N),IND(N)'
write(io,'(a)')''
write(io,'(a)')'       DO CONCURRENT (I=1:M)'
write(io,'(a)')'          A(IND(I)) = I'
write(io,'(a)')'       END DO'
write(io,'(a)')''
write(io,'(a)')'       NOTE 8.18'
write(io,'(a)')'       Additional examples of DO constructs are in C.5.3.'
write(io,'(a)')'.fi'
write(io,'(a)')'NAME'
write(io,'(a)')'   complex(7f) - [FORTRAN] complex variables'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'   complex(kind=NN) :: name'
write(io,'(a)')'   complex(kind=NN) :: name=(r,i)'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   In mathematics, a complex number has a real and an imaginary'
write(io,'(a)')'   component. In Fortran, complex numbers are stored as a pair of REAL'
write(io,'(a)')'   numbers (the first representing the real part, the following the'
write(io,'(a)')'   imaginary part). Using the correct KIND allows for DOUBLEPRECISION'
write(io,'(a)')'   COMPLEX values.'
write(io,'(a)')''
write(io,'(a)')'   Any expression involving COMPLEX numbers and other numbers is promoted'
write(io,'(a)')'   to COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'   All of the arithmetic operators can take a COMPLEX number on either'
write(io,'(a)')'   side (left hand side or right hand side) of an expression such'
write(io,'(a)')'   as LHS=RHS.'
write(io,'(a)')''
write(io,'(a)')'   DECLARATION'
write(io,'(a)')'   The standard way to declare a complex variable is simply to use the COMPLEX'
write(io,'(a)')'   statement:'
write(io,'(a)')''
write(io,'(a)')'      COMPLEX myVariable, anotherVariable, anArray(2,3)'
write(io,'(a)')''
write(io,'(a)')'   Examples of complex declarations are'
write(io,'(a)')''
write(io,'(a)')'      COMPLEX (KIND = KIND(0.0D0)) :: C'
write(io,'(a)')'      COMPLEX :: CUBE_ROOT = (-0.5, 0.866)'
write(io,'(a)')''
write(io,'(a)')'   CONSTANTS AND EXPRESSIONS'
write(io,'(a)')'   Complex constants are specified as "(",a real value, a comma, another real'
write(io,'(a)')'   value and ")". Some examples are 1 as (1.0,0.0), i as (0.0,1.0), 2-3i as'
write(io,'(a)')'   (2.0,-3.0), and 1000000000i as (0.0,1.0E+09). The same constants can'
write(io,'(a)')'   be coded as double-precision complex constants by the simple expedient'
write(io,'(a)')'   of using a D in the exponent. Thus, the same constants can be coded'
write(io,'(a)')'   in double-precision using (1.0D+00,0.0D+00), (0.0D+00,1.0D+00),'
write(io,'(a)')'   (2.0D+00,-3.0D+00), and (0.0D+00,1.0D+09), respectively. Note: This'
write(io,'(a)')'   notation cannot be used with variables. For example, (a, b) is invalid.'
write(io,'(a)')''
write(io,'(a)')'   Examples of complex constants are'
write(io,'(a)')''
write(io,'(a)')'      (1.0, -1.0)'
write(io,'(a)')'      (3, 3.1E6)'
write(io,'(a)')'      (4.0_4, 3.6E7_8)'
write(io,'(a)')'      ( 0.0, PI)  ! where PI is a previously declared named'
write(io,'(a)')'                  ! scalar numeric CONSTANT, not a variable.'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'   CMPLX AND DOUBLE PRECISION'
write(io,'(a)')''
write(io,'(a)')'   To convert real variables to complex, use the CMPLX function.'
write(io,'(a)')''
write(io,'(a)')'   The Fortran 90 language defines CMPLX() as always returning a result'
write(io,'(a)')'   that is type COMPLEX(KIND=KIND(0.0)).'
write(io,'(a)')''
write(io,'(a)')'   This means `CMPLX(D1,D2)'', where `D1'' and `D2'' are DOUBLEPRECISION,'
write(io,'(a)')'   is treated as:'
write(io,'(a)')''
write(io,'(a)')'      CMPLX(SNGL(D1), SNGL(D2))'
write(io,'(a)')''
write(io,'(a)')'   If you want double-precision complex numbers, you''re pretty much'
write(io,'(a)')'   stuck with specifying a precision.'
write(io,'(a)')''
write(io,'(a)')'   It was necessary for Fortran 90 to specify this behavior for'
write(io,'(a)')'   DOUBLEPRECISION arguments, since that is the behavior mandated by'
write(io,'(a)')'   FORTRAN 77.'
write(io,'(a)')''
write(io,'(a)')'   So Fortran 90 extends the CMPLX() intrinsic by adding an extra argument'
write(io,'(a)')'   used to specify the desired kind of complex result.'
write(io,'(a)')''
write(io,'(a)')'      integer,parameter :: dp=kind(0.0d0)'
write(io,'(a)')'      complex(kind=dp) :: z8'
write(io,'(a)')'      !'
write(io,'(a)')'      ! NO: result is just real because KIND parameter is not specified'
write(io,'(a)')'      !'
write(io,'(a)')'      z8 = cmplx(1.2345678901234567d0, 1.2345678901234567d0)       ! note this was stored with default real precisi&
   &on'
write(io,'(a)')'      print *, ''NO, Z8='',z8,real(z8),aimag(z8)                     ! notice components are just truncated to real'
write(io,'(a)')'      z8 = cmplx(1.2345678901234567e0_dp, 1.2345678901234567e0_dp) ! note works with e0, not d0'
write(io,'(a)')'      print *, ''NO, Z8='',z8,real(z8),aimag(z8)                     ! note components are just real'
write(io,'(a)')'      !'
write(io,'(a)')'      ! YES'
write(io,'(a)')'      !'
write(io,'(a)')'      z8 = cmplx(1.2345678901234567d0, 1.2345678901234567d0,kind=dp) ! kind= makes it work'
write(io,'(a)')'      print *, ''YES, Z8='',z8,real(z8),aimag(z8)'
write(io,'(a)')''
write(io,'(a)')'   F2018 COMPONENT SYNTAX'
write(io,'(a)')'   The real and imaginary parts of a complex entity can be accessed'
write(io,'(a)')'   independently with a component-like syntax in f2018:'
write(io,'(a)')''
write(io,'(a)')'   A complex-part-designator is'
write(io,'(a)')''
write(io,'(a)')'      designator % RE'
write(io,'(a)')'      or'
write(io,'(a)')'      designator % IM.'
write(io,'(a)')''
write(io,'(a)')'   The designator shall be of complex type.'
write(io,'(a)')''
write(io,'(a)')'   So designator%RE designates the real part of a complex value,'
write(io,'(a)')'   designator%IM designates the imaginary part of complex value. The'
write(io,'(a)')'   type of a complex-part-designator is real, and its kind and shape'
write(io,'(a)')'   are those of the designator.'
write(io,'(a)')''
write(io,'(a)')'   The following are examples of complex part designators:'
write(io,'(a)')''
write(io,'(a)')'       impedance%re           !-- Same value as REAL(impedance)'
write(io,'(a)')'       fft%im                 !-- Same value as AIMAG(fft)'
write(io,'(a)')'       x%im = 0.0             !-- Sets the imaginary part of X to zero'
write(io,'(a)')''
write(io,'(a)')'      program components'
write(io,'(a)')'      integer,parameter :: dp=kind(0.0d0)'
write(io,'(a)')'      complex(kind=dp) ::  z8'
write(io,'(a)')'       z8 = cmplx(1.2345678901234567d0, 1.2345678901234567d0,kind=dp)'
write(io,'(a)')'       print *, ''Z8='',z8,z8%re,z8%im'
write(io,'(a)')'       print *, real(aimag(z8),kind=dp)'
write(io,'(a)')'       print *, real(z8)'
write(io,'(a)')'      end program components'
write(io,'(a)')''
write(io,'(a)')'   C'
write(io,'(a)')'   Your C-compiler can work with complex numbers if it supports the C99'
write(io,'(a)')'   standard. Link with -lm. The imaginary unit is represented by I.'
write(io,'(a)')''
write(io,'(a)')'        /* check that exp(i * pi) == -1 */'
write(io,'(a)')'        #include <math.h>       /* for atan */'
write(io,'(a)')'        #include <stdio.h>'
write(io,'(a)')'        #include <complex.h>'
write(io,'(a)')''
write(io,'(a)')'        int'
write(io,'(a)')'        main(void)'
write(io,'(a)')'        {'
write(io,'(a)')'           double pi = 4 * atan(1.0);'
write(io,'(a)')'           double complex z = cexp(I * pi);'
write(io,'(a)')'           printf("%f + %f * i\n", creal(z), cimag(z));'
write(io,'(a)')'        }'
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_aimag'
write(io,'(a)')'   integer,parameter :: dp=kind(0.0d0)'
write(io,'(a)')'   complex          :: z4'
write(io,'(a)')'   complex(kind=dp) :: z8'
write(io,'(a)')'   real(kind=dp)    :: d8'
write(io,'(a)')'      z4 = cmplx(1.2345678901234567d0, 1.2345678901234567d0) ! no kind so values on LHS are converted to default re&
   &al'
write(io,'(a)')'      z8 = cmplx(1.2345678901234567d0, 1.2345678901234567d0,kind=dp) ! kind= makes it work'
write(io,'(a)')'   end program demo_aimag'
write(io,'(a)')'SEE ALSO'
write(io,'(a)')'   o aimag(3f) -  Imaginary part of complex number'
write(io,'(a)')'   o cmplx(3f) -  Complex conversion function'
write(io,'(a)')'   o conjg(3f) -  Complex conjugate function'
write(io,'(a)')'   o real(3f)  -  Convert to real type'
write(io,'(a)')'WORKING ON'
write(io,'(a)')'  Sample using aimag'
write(io,'(a)')''
write(io,'(a)')'   program demo_aimag'
write(io,'(a)')'   integer,parameter :: dp=kind(0.0d0)'
write(io,'(a)')'   complex          :: z4'
write(io,'(a)')'   complex(kind=dp) :: z8'
write(io,'(a)')'   real(kind=dp)    :: d8'
write(io,'(a)')'   d8 = 1.2345678901234567     ! NO: might be truncated to default real'
write(io,'(a)')'   print *, ''NO, D8='',d8'
write(io,'(a)')'   d8 = 1.2345678901234567_dp  ! should work; note that only one value was specified'
write(io,'(a)')'   print *, ''D8='',d8'
write(io,'(a)')'   d8 = 1.2345678901234567d0   ! should work'
write(io,'(a)')'   print *, ''D8='',d8'
write(io,'(a)')'   ! intuitive and works without calling cmplx(3f) but does not work for variables'
write(io,'(a)')'   z8 = (1.2345678901234567d0 , 1.2345678901234567d0 )'
write(io,'(a)')'   print *, ''Z8='',z8'
write(io,'(a)')'   !========================================================================================='
write(io,'(a)')'   contains'
write(io,'(a)')'      function DCOMPLEX(real, imag)'
write(io,'(a)')'      end function DCOMPLEX'
write(io,'(a)')''
write(io,'(a)')'   end program demo_aimag'
write(io,'(a)')'>!'
write(io,'(a)')'>!  EXTENSION: COMPLEX function'
write(io,'(a)')'>!      A simple way to build a'
write(io,'(a)')'>!      complex value out of two numbers, with the precise type of the'
write(io,'(a)')'>!      value determined by the types of the two numbers (via the usual'
write(io,'(a)')'>!      type-promotion mechanism):'
write(io,'(a)')'>!'
write(io,'(a)')'>!'
write(io,'(a)')'>!      When real and imag are the same REAL types, COMPLEX() performs'
write(io,'(a)')'>!      no conversion other than to put them together to form a complex'
write(io,'(a)')'>! result of the same (complex version of real) type.'
write(io,'(a)')'>'
write(io,'(a)')'>'
write(io,'(a)')'>'
write(io,'(a)')'>       The text CMPLX (X [, Y, KIND]) indicates that Y and KIND are'
write(io,'(a)')'>       both optional arguments. Valid reference forms include CMPLX(x),'
write(io,'(a)')'>       CMPLX(x, y), CMPLX(x, KIND=kind ), CMPLX(x, y, kind ), and'
write(io,'(a)')'>       CMPLX(KIND=kind, X=x, Y=y).'
write(io,'(a)')'>'
write(io,'(a)')'>      The result values of the intrinsic functions CMPLX and DBLE'
write(io,'(a)')'>       are defined by references to the intrinsic function REAL with'
write(io,'(a)')'>       the same arguments. Therefore, the padding and truncation of'
write(io,'(a)')'>       boz-literal-constant arguments to those intrinsic functions is'
write(io,'(a)')'>       the same as for the intrinsic function REAL.'
write(io,'(a)')'>'
write(io,'(a)')'>   COMPLEX EXPONENTIATION'
write(io,'(a)')'>'
write(io,'(a)')'> 1 In the case of a complex value raised to a complex power, the value of the operation x1 ** x2 is the principal'
write(io,'(a)')'>   value of xx2 .'
write(io,'(a)')'>             1'
write(io,'(a)')'>'
write(io,'(a)')'>    8.2.4      Arithmetic IF statement'
write(io,'(a)')'>    R853      arithmetic-if-stmt                 is   IF ( scalar-numeric-expr ) label , label , label'
write(io,'(a)')'>'
write(io,'(a)')'>    C846      (R853) The scalar-numeric-expr shall not be of type complex.'
write(io,'(a)')'>'
write(io,'(a)')'> IO'
write(io,'(a)')'>   To each data edit descriptor interpreted in a format specification, there corresponds one effective item specif&
   &ied by'
write(io,'(a)')'>   the input/output list (9.6.3), except that an input/output list item of type complex requires the interpretatio&
   &n of'
write(io,'(a)')'>   two F, E, EN, ES, D, or G edit descriptors.'
write(io,'(a)')'>'
write(io,'(a)')'>   COMPLEX EDITING'
write(io,'(a)')'>'
write(io,'(a)')'> 1 A complex datum consists of a pair of separate real data. The editing of a scalar datum of complex type is'
write(io,'(a)')'>   specified by two edit descriptors each of which specifies the editing of real data. The first of the edit descr&
   &iptors'
write(io,'(a)')'>   specifies the real part; the second specifies the imaginary part. The two edit descriptors may be different. Co&
   &ntrol'
write(io,'(a)')'>   and character string edit descriptors may be processed between the edit descriptor for the real part and the ed&
   &it'
write(io,'(a)')'>   descriptor for the imaginary part.'
write(io,'(a)')'>'
write(io,'(a)')'>   LIST-DIRECTED INPUT'
write(io,'(a)')'> 5 When the next effective item is of type complex, the input form consists of a left parenthesis followed by an'
write(io,'(a)')'>   ordered pair of numeric input fields separated by a comma (if the decimal edit mode is POINT) or semicolon'
write(io,'(a)')'>   (if the decimal edit mode is COMMA), and followed by a right parenthesis. The first numeric input field is the'
write(io,'(a)')'>   real part of the complex constant and the second is the imaginary part. Each of the numeric input fields may be'
write(io,'(a)')'>   preceded or followed by any number of blanks and ends of records. The end of a record may occur after the real'
write(io,'(a)')'>   part or before the imaginary part.'
write(io,'(a)')'>      print *, ''Z4='',z4,real(z4),aimag(z4)'
write(io,'(a)')'>      print *, ''Z4='',z4,z4%re,z4%im'
write(io,'(a)')'>   NAMELIST'
write(io,'(a)')'.\" Specification of Fortran'
write(io,'(a)')'.TH EXIT "7" "January 2017" "Fortran" "Language Specification"'
write(io,'(a)')'.SH NAME'
write(io,'(a)')'   EXIT(7f) - [FORTRAN:EXECUTION CONTROL] statement (LICENSE:PD)'
write(io,'(a)')'.SH SYNOPSIS'
write(io,'(a)')'   EXIT [construct-name]'
write(io,'(a)')''
write(io,'(a)')'.SH DESCRIPTION'
write(io,'(a)')'.nf'
write(io,'(a)')'  The EXIT statement provides one way of terminating a loop, or completing'
write(io,'(a)')'  execution of another construct.'
write(io,'(a)')''
write(io,'(a)')'  If a construct-name appears, the EXIT statement shall be within that'
write(io,'(a)')'  construct; otherwise, it shall be within the range of at least one'
write(io,'(a)')'  do-construct.'
write(io,'(a)')''
write(io,'(a)')'  An EXIT statement belongs to a particular construct. If a construct'
write(io,'(a)')'  name appears, the EXIT statement belongs'
write(io,'(a)')'  to that construct; otherwise, it belongs to the innermost DO construct'
write(io,'(a)')'  in which it appears.'
write(io,'(a)')''
write(io,'(a)')'  An exit-stmt shall not belong to a DO CONCURRENT construct,'
write(io,'(a)')'  nor shall it appear within the range'
write(io,'(a)')'  of a DO CONCURRENT construct if it belongs to a construct'
write(io,'(a)')'  that contains that DO CONCURRENT construct.'
write(io,'(a)')''
write(io,'(a)')'  When an EXIT statement that belongs to a DO construct is executed,'
write(io,'(a)')'  it terminates the loop and'
write(io,'(a)')'  any active loops contained within the terminated loop. When an'
write(io,'(a)')'  EXIT statement that belongs to a non-DO construct is executed, it'
write(io,'(a)')'  terminates any active loops contained within that construct, and'
write(io,'(a)')'  completes execution of that construct.'
write(io,'(a)')'.fi'
write(io,'(a)')''
write(io,'(a)')'.SH EXAMPLES'
write(io,'(a)')''
write(io,'(a)')'.nf'
write(io,'(a)')'  Samples:'
write(io,'(a)')''
write(io,'(a)')'   do i=1,10'
write(io,'(a)')'      if(i.eq.4)exit ! exit loop'
write(io,'(a)')'   enddo'
write(io,'(a)')''
write(io,'(a)')'   do i=1,10'
write(io,'(a)')'      do j=100,200'
write(io,'(a)')'         if(j.eq.150)exit ! exit inner loop "j"'
write(io,'(a)')'      enddo'
write(io,'(a)')'   enddo'
write(io,'(a)')''
write(io,'(a)')'   OUTER: do i=1,10'
write(io,'(a)')'      INNER: do j=100,200'
write(io,'(a)')'         if(j.eq.150)exit OUTER ! exit named loop'
write(io,'(a)')'      enddo INNER'
write(io,'(a)')'   enddo OUTER'
write(io,'(a)')''
write(io,'(a)')'   MYBLOCK: block'
write(io,'(a)')'      big=.false.'
write(io,'(a)')'      do i=1,100'
write(io,'(a)')'        if(i=40)then'
write(io,'(a)')'          exit MYBLOCK'
write(io,'(a)')'        endif'
write(io,'(a)')'      enddo'
write(io,'(a)')'      big=.true.'
write(io,'(a)')'   endblock MYBLOCK'
write(io,'(a)')'.fi'
write(io,'(a)')''
write(io,'(a)')'.\" Specification of Fortran'
write(io,'(a)')'.TH BLOCK "7" "January 2017" "Fortran" "Language Specification"'
write(io,'(a)')'.SH NAME'
write(io,'(a)')'   BLOCK(7f) - [FORTRAN:EXECUTION CONTROL] construct (LICENSE:PD)'
write(io,'(a)')'.SH SYNOPSIS'
write(io,'(a)')'.nf'
write(io,'(a)')'  [ block-construct-name : ] BLOCK'
write(io,'(a)')'  [ specification-part ]'
write(io,'(a)')'  END[ ]BLOCK [ block-construct-name ]'
write(io,'(a)')'.fi'
write(io,'(a)')''
write(io,'(a)')'.SH DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'  The BLOCK construct is an executable construct which may contain'
write(io,'(a)')'  declarations, and may be exited using the EXIT statement.'
write(io,'(a)')''
write(io,'(a)')'  The specification-part of a BLOCK construct shall not contain a COMMON,'
write(io,'(a)')'  EQUIVALENCE, IMPLICIT, INTENT, NAMELIST, or OPTIONAL statement.'
write(io,'(a)')''
write(io,'(a)')'  A SAVE statement in a BLOCK construct shall not contain a'
write(io,'(a)')'  common-block-name.'
write(io,'(a)')''
write(io,'(a)')'  Except for the ASYNCHRONOUS and VOLATILE statements, specifications'
write(io,'(a)')'  in a BLOCK construct declare construct entities whose scope is that'
write(io,'(a)')'  of the BLOCK construct.'
write(io,'(a)')''
write(io,'(a)')'.SH EXAMPLES'
write(io,'(a)')''
write(io,'(a)')'  Sample programs:'
write(io,'(a)')''
write(io,'(a)')'.nf'
write(io,'(a)')'   program demo_block'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   integer,parameter :: arr1(*)=[1,2,3,4,5,6,7]'
write(io,'(a)')'   integer,parameter :: arr2(*)=[0,1,2,3,4,5,6,7]'
write(io,'(a)')''
write(io,'(a)')'   call showme(arr1)'
write(io,'(a)')'   call showme(arr2)'
write(io,'(a)')''
write(io,'(a)')'   contains'
write(io,'(a)')''
write(io,'(a)')'   subroutine showme(a)'
write(io,'(a)')'   integer,intent(in) :: a(:)'
write(io,'(a)')'   integer :: i=-100'
write(io,'(a)')''
write(io,'(a)')'   TESTFORZERO: block'
write(io,'(a)')'      integer :: I  ! local block variable'
write(io,'(a)')'      do i=1,size(a)'
write(io,'(a)')'         if(a(i).eq.0) EXIT TESTFORZERO'
write(io,'(a)')'      enddo'
write(io,'(a)')'      write(*,*)''Never found a zero, tried '',i-1,'' times'''
write(io,'(a)')'      return'
write(io,'(a)')'   endblock TESTFORZERO'
write(io,'(a)')''
write(io,'(a)')'   ! note the variable I in the block is local to the block'
write(io,'(a)')'   write(*,*)''found a zero'', '' I='',i'
write(io,'(a)')'   end subroutine showme'
write(io,'(a)')''
write(io,'(a)')'   end program demo_block'
write(io,'(a)')''
write(io,'(a)')'  Results:'
write(io,'(a)')''
write(io,'(a)')'    Never found a zero, tried 7 times'
write(io,'(a)')'    found a zero I= -100'
write(io,'(a)')''
write(io,'(a)')'.fi'
write(io,'(a)')'NAME'
write(io,'(a)')'   flush(7f) - [FORTRAN:IO] flush I/O buffers of specified files'
write(io,'(a)')'   (LICENSE:PD)'
write(io,'(a)')''
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'   flush file-unit-number'
write(io,'(a)')''
write(io,'(a)')'    or'
write(io,'(a)')''
write(io,'(a)')'   flush([UNIT=]file_unit_number,[iostat=i],[iomsg=string],[err=label_number])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'  Because the Fortran standard does not specify the mechanism of file'
write(io,'(a)')'  storage, the exact meaning of the flush operation is not precisely'
write(io,'(a)')'  defined. The intention is that the flush operation should make all data'
write(io,'(a)')'  written to an external file available to other processes or devices,'
write(io,'(a)')'  or causes data placed in an external file by means other than the'
write(io,'(a)')'  current Fortran process to be available to a subsequent READ statement.'
write(io,'(a)')'  This is commonly called "flushing I/O buffers".'
write(io,'(a)')'  These actions are processor dependent.'
write(io,'(a)')''
write(io,'(a)')'  Execution of a FLUSH statement performs a wait operation for all'
write(io,'(a)')'  pending asynchronous data transfer operations for the specified unit.'
write(io,'(a)')''
write(io,'(a)')'  Execution of a FLUSH statement for a file that is connected but does'
write(io,'(a)')'  not exist is permitted and has no effect on any file. A FLUSH statement'
write(io,'(a)')'  has no effect on file position.'
write(io,'(a)')''
write(io,'(a)')'  No specifier shall appear more than once in a given flush-spec-list.'
write(io,'(a)')''
write(io,'(a)')'OPTIONS'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'   [UNIT=]file-unit-number  Required. If the optional characters'
write(io,'(a)')'                            UNIT= are omitted from the unit specifier,'
write(io,'(a)')'                            the file-unit-number must be the first item.'
write(io,'(a)')''
write(io,'(a)')'   ERR=label                The label must branch to a target statement'
write(io,'(a)')'                            in the same scoping unit as the FLUSH'
write(io,'(a)')'                            statement.'
write(io,'(a)')'RETURNS'
write(io,'(a)')''
write(io,'(a)')'   IOSTAT=scalar-int-variable  variable is set to a processor-dependent'
write(io,'(a)')'                               positive value if an error occurs, to zero'
write(io,'(a)')'                               if the flush operation was successful, or'
write(io,'(a)')'                               to a processor-dependent negative value'
write(io,'(a)')'                               if the flush operation is not supported'
write(io,'(a)')'                               for the unit specified.'
write(io,'(a)')'   IOMSG=iomsg-variable    message describing any error that occurred'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'        flush (10, iostat = n)'
write(io,'(a)')'NAME'
write(io,'(a)')'   ASSOCIATE(7f) - [FORTRAN:EXECUTION CONTROL] associate construct'
write(io,'(a)')'           (LICENSE:PD)'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'  [ associate-construct-name : ] ASSOCIATE ( associate-name => expr|variable, ...)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'  Basically, ASSOCIATE allows you to'
write(io,'(a)')''
write(io,'(a)')'  1. create an alias for a variable'
write(io,'(a)')'  2. evaluate an expression at the top of the block and use a variable name'
write(io,'(a)')'     as a substitute for the constant, much like a parameter declaration.'
write(io,'(a)')''
write(io,'(a)')'  It is _NOT_ equivalent to a function macro.'
write(io,'(a)')''
write(io,'(a)')'  The ASSOCIATE construct associates named entities with expressions or'
write(io,'(a)')'  variables during the execution of its block. These "named construct'
write(io,'(a)')'  entities" (16.4) are "associating entities" (16.5.1.6). The names are'
write(io,'(a)')'  "associate names".'
write(io,'(a)')''
write(io,'(a)')'  o If selector is not a variable or is a variable that'
write(io,'(a)')'    has a vector subscript, associate-name shall not appear in'
write(io,'(a)')'    a variable definition context(16.6.7).'
write(io,'(a)')''
write(io,'(a)')'  o An associate-name shall not be the same as another'
write(io,'(a)')'    associate-name in the same associate-stmt.'
write(io,'(a)')''
write(io,'(a)')'  o variable shall not be a coindexed object.'
write(io,'(a)')''
write(io,'(a)')'  o expr shall not be a variable.'
write(io,'(a)')''
write(io,'(a)')'  o end-associate-stmt is END ASSOCIATE [ associate-construct-name ]'
write(io,'(a)')''
write(io,'(a)')'  o (R806) If the associate-stmt of an associate-construct'
write(io,'(a)')'    specifies an associate-construct-name, the'
write(io,'(a)')'    corresponding end-associate-stmt shall specify the'
write(io,'(a)')'    same associate-construct-name. If the associate-stmt'
write(io,'(a)')'    of an associate-construct does not specify an'
write(io,'(a)')'    associate-construct-name, the corresponding end-associate-stmt'
write(io,'(a)')'    shall not specify an associate-construct-name.'
write(io,'(a)')''
write(io,'(a)')'  EXECUTION OF THE ASSOCIATE CONSTRUCT'
write(io,'(a)')''
write(io,'(a)')'  Execution of an ASSOCIATE construct causes evaluation of every'
write(io,'(a)')'  expression within every selector that is a variable designator and'
write(io,'(a)')'  evaluation of every other selector , followed by execution of its'
write(io,'(a)')'  block. During execution of that block each associate name identifies an'
write(io,'(a)')'  entity which is associated (16.5.1.6) with the corresponding selector.'
write(io,'(a)')'  The associating entity assumes the declared type and type parameters'
write(io,'(a)')'  of the selector. If and only if the selector is polymorphic, the'
write(io,'(a)')'  associating entity is polymorphic.'
write(io,'(a)')''
write(io,'(a)')'  It is permissible to branch to an end-associate-stmt only from within'
write(io,'(a)')'  its ASSOCIATE construct.'
write(io,'(a)')''
write(io,'(a)')'  ATTRIBUTES OF ASSOCIATE NAMES'
write(io,'(a)')''
write(io,'(a)')'  Within an ASSOCIATE or SELECT TYPE construct, each associating entity'
write(io,'(a)')'  has the same rank and corank as its associated selector. The lower'
write(io,'(a)')'  bound of each dimension is the result of the intrinsic function LBOUND'
write(io,'(a)')'  (13.7.90) applied to the corresponding dimension of selector . The upper'
write(io,'(a)')'  bound of each dimension is one less than the sum of the lower bound'
write(io,'(a)')'  and the extent. The cobounds of each codimension of the associating'
write(io,'(a)')'  entity are the same as those of the selector. The associating entity'
write(io,'(a)')'  has the ASYNCHRONOUS or VOLATILE attribute if and only if the selector'
write(io,'(a)')'  is a variable and has the attribute. The associating entity has the'
write(io,'(a)')'  TARGET attribute if and only if the selector is a variable and has'
write(io,'(a)')'  either the TARGET or POINTER attribute. If the associating entity is'
write(io,'(a)')'  polymorphic, it assumes the dynamic type and type parameter values of'
write(io,'(a)')'  the selector. If the selector has the OPTIONAL attribute, it shall'
write(io,'(a)')'  be present. The associating entity is contiguous if and only if the'
write(io,'(a)')'  selector is contiguous.'
write(io,'(a)')''
write(io,'(a)')'  If the selector is not permitted to appear in a variable definition'
write(io,'(a)')'  context (16.6.7), the associate name shall not appear in a variable'
write(io,'(a)')'  definition context.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLES'
write(io,'(a)')''
write(io,'(a)')'  The following example illustrates an association with an expression.'
write(io,'(a)')''
write(io,'(a)')'       associate ( z => exp(-(x**2+y**2)) * cos(theta) )'
write(io,'(a)')'         print *, a+z, a-z'
write(io,'(a)')'       end associate'
write(io,'(a)')''
write(io,'(a)')'  The following example illustrates an association with a'
write(io,'(a)')'  derived-type variable.'
write(io,'(a)')''
write(io,'(a)')'       associate ( xc => ax%b(i,j)%c )'
write(io,'(a)')'         xc%dv = xc%dv + product(xc%ev(1:n))'
write(io,'(a)')'       end associate'
write(io,'(a)')''
write(io,'(a)')'  The following example illustrates association with an array section.'
write(io,'(a)')''
write(io,'(a)')'       associate ( array => ax%b(i,:)%c )'
write(io,'(a)')'         array(n)%ev = array(n-1)%ev'
write(io,'(a)')'       end associate'
write(io,'(a)')''
write(io,'(a)')'  The following example illustrates multiple associations.'
write(io,'(a)')''
write(io,'(a)')'       associate ( w => result(i,j)%w, zx => ax%b(i,j)%d, zy => ay%b(i,j)%d )'
write(io,'(a)')'         w = zx*x + zy*y'
write(io,'(a)')'       end associate'
write(io,'(a)')''
write(io,'(a)')'   The following example uses the ASSOCIATE construct as a shorthand for a'
write(io,'(a)')'   complex expression and renames an existing variable, MYREAL. After the'
write(io,'(a)')'   end of the ASSOCIATE construct, any change within the construct to the'
write(io,'(a)')'   value of the associating entity that associates with MYREAL is reflected.'
write(io,'(a)')''
write(io,'(a)')'      program demo_associate'
write(io,'(a)')'      real :: myreal, x, y, theta, a'
write(io,'(a)')'      x = 0.42'
write(io,'(a)')'      y = 0.35'
write(io,'(a)')'      myreal = 9.1'
write(io,'(a)')'      theta = 1.5'
write(io,'(a)')'      a = 0.4'
write(io,'(a)')'      associate ( z => exp(-(x**2+y**2)) * cos(theta), v => myreal)'
write(io,'(a)')'         print *, a+z, a-z, v'
write(io,'(a)')'         v = v * 4.6'
write(io,'(a)')'      end associate'
write(io,'(a)')'      print *, myreal'
write(io,'(a)')'      end program demo_associate'
write(io,'(a)')''
write(io,'(a)')'  See if you know what the following produces ...'
write(io,'(a)')''
write(io,'(a)')'      program dustycorner'
write(io,'(a)')'      implicit none'
write(io,'(a)')'      real :: a = 42'
write(io,'(a)')'      associate (a => a, b => 2 * a)'
write(io,'(a)')'         print *, a, b'
write(io,'(a)')'         a = 0'
write(io,'(a)')'         print *, a, b'
write(io,'(a)')'      end associate'
write(io,'(a)')'      print *, a'
write(io,'(a)')''
write(io,'(a)')'      a=42'
write(io,'(a)')'      associate (aa => a, b => 2 * a)'
write(io,'(a)')'         print *, a, aa, b'
write(io,'(a)')'         aa = 0'
write(io,'(a)')'         print *, a, aa, b'
write(io,'(a)')'         a=-1'
write(io,'(a)')'         print *, a, aa, b'
write(io,'(a)')'      end associate'
write(io,'(a)')'      print *, a'
write(io,'(a)')'      end program dustycorner'
write(io,'(a)')''
write(io,'(a)')'  Did you expect the following?'
write(io,'(a)')''
write(io,'(a)')'      42.0000000       84.0000000'
write(io,'(a)')'      0.00000000       84.0000000'
write(io,'(a)')'      0.00000000'
write(io,'(a)')'      42.0000000       42.0000000       84.0000000'
write(io,'(a)')'      0.00000000       0.00000000       84.0000000'
write(io,'(a)')'     -1.00000000      -1.00000000       84.0000000'
write(io,'(a)')'     -1.00000000'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   protected(7f) - [FORTRAN:SPECIFICATION ATTRIBUTE] protect use associated module objects from change outside of t&
   &he module'
write(io,'(a)')'   (LICENSE:PD)'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'   module ANY_MODULE'
write(io,'(a)')'   specification, PROTECTED :: variable_declaration'
write(io,'(a)')'   end module ANY_MODULE'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   The PROTECTED attribute imposes limitations on the usage of module'
write(io,'(a)')'   entities.'
write(io,'(a)')''
write(io,'(a)')'   The PROTECTED attribute shall be specified only in the specification'
write(io,'(a)')'   part of a module.'
write(io,'(a)')''
write(io,'(a)')'   An entity with the PROTECTED attribute shall be a procedure pointer'
write(io,'(a)')'   or variable.'
write(io,'(a)')''
write(io,'(a)')'   An entity with the PROTECTED attribute shall not be in a common block.'
write(io,'(a)')''
write(io,'(a)')'   A nonpointer object that has the PROTECTED attribute and is accessed'
write(io,'(a)')'   by use association shall not appear in a variable definition context'
write(io,'(a)')'   or as the data-target or proc-target in a pointer-assignment-stmt.'
write(io,'(a)')''
write(io,'(a)')'   A pointer that has the PROTECTED attribute and is accessed by use'
write(io,'(a)')'   association shall not appear in a pointer association context'
write(io,'(a)')''
write(io,'(a)')'   Other than within the module in which an entity is given the PROTECTED'
write(io,'(a)')'   attribute, or within any of its descendants,'
write(io,'(a)')''
write(io,'(a)')'   * if it is a nonpointer object, it is not definable, and'
write(io,'(a)')'   *  if it is a pointer, its association status shall not be changed'
write(io,'(a)')'     except that it may become undefined if its target'
write(io,'(a)')'     is deallocated other than through the pointer or if its'
write(io,'(a)')'     target becomes undefined by execution of a RETURN or END statement.'
write(io,'(a)')''
write(io,'(a)')'   If an object has the PROTECTED attribute, all of its subobjects have'
write(io,'(a)')'   the PROTECTED attribute.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  An example of the PROTECTED attribute:'
write(io,'(a)')''
write(io,'(a)')'   module temperature'
write(io,'(a)')'      real, protected :: temp_c, temp_f'
write(io,'(a)')'   contains'
write(io,'(a)')'      subroutine set_temperature_c(c)'
write(io,'(a)')'      real, intent(in) :: c'
write(io,'(a)')'         temp_c = c'
write(io,'(a)')'         temp_f = temp_c*(9.0/5.0) + 32'
write(io,'(a)')'      end subroutine'
write(io,'(a)')'   end module'
write(io,'(a)')''
write(io,'(a)')'   The PROTECTED attribute ensures that the variables temp_c and temp_f'
write(io,'(a)')'   cannot be modified other than via the set_temperature_c procedure,'
write(io,'(a)')'   thus keeping them consistent with each other.'
write(io,'(a)')'NAME'
write(io,'(a)')'     if(7f) - [FORTRAN:EXECUTION CONTROL] selects a block based on a sequence of logical expressions.'
write(io,'(a)')'     (LICENSE:PD)'
write(io,'(a)')''
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')''
write(io,'(a)')'     [if_construct_name:] IF (scalar-logical-expr) THEN'
write(io,'(a)')'        block'
write(io,'(a)')'     ELSEIF (scalar-logical-expr) THEN [if_construct_name]'
write(io,'(a)')'        block'
write(io,'(a)')'     ELSE [if_construct_name]'
write(io,'(a)')'        block'
write(io,'(a)')'     ENDIF [if_construct_name]'
write(io,'(a)')''
write(io,'(a)')'        or'
write(io,'(a)')''
write(io,'(a)')'     IF (scalar-logical-expression) action-statement'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   The IF construct selects for execution at most one of its constituent'
write(io,'(a)')'   blocks. The selection is based on a sequence of logical expressions.'
write(io,'(a)')''
write(io,'(a)')'   If an if-construct-name is specified, both the IF and ENDIF must use'
write(io,'(a)')'   that same name. If an ELSE or ELSEIF uses an if-construct-name it must'
write(io,'(a)')'   be the same as the one specified on the corresponding IF/ENDIF.'
write(io,'(a)')''
write(io,'(a)')'   Execution of an IF construct'
write(io,'(a)')''
write(io,'(a)')'   At most one of the blocks in the IF construct is executed. If there'
write(io,'(a)')'   is an ELSE statement in the construct, exactly one of the blocks'
write(io,'(a)')'   in the construct is executed. The scalar logical expressions are'
write(io,'(a)')'   evaluated in the order of their appearance in the construct until'
write(io,'(a)')'   a true value is found or an ELSE statement or ENDIF statement is'
write(io,'(a)')'   encountered. If a true value or an ELSE statement is found, the block'
write(io,'(a)')'   immediately following is executed and this completes the execution'
write(io,'(a)')'   of the construct. The scalar logical expressions in any remaining'
write(io,'(a)')'   ELSEIF statements of the IF construct are not evaluated. If none'
write(io,'(a)')'   of the evaluated expressions is true and there is no ELSE statement,'
write(io,'(a)')'   the execution of the construct is completed without the execution of'
write(io,'(a)')'   any block within the construct.'
write(io,'(a)')''
write(io,'(a)')'   It is permissible to branch to an ENDIF statement only from within'
write(io,'(a)')'   its IF construct. Execution of an ENDIF statement has no effect.'
write(io,'(a)')''
write(io,'(a)')'   Execution of an IF statement'
write(io,'(a)')''
write(io,'(a)')'   The IF statement controls the execution of a single action statement'
write(io,'(a)')'   based on a single logical expression.'
write(io,'(a)')''
write(io,'(a)')'   The action-stmt in the if-stmt shall not be an end-function-stmt,'
write(io,'(a)')'   end-mp-subprogram-stmt, end-program-stmt, end-subroutine-stmt,'
write(io,'(a)')'   or if-stmt.'
write(io,'(a)')''
write(io,'(a)')'   Execution of an IF statement causes evaluation of the scalar logical'
write(io,'(a)')'   expression. If the value of the expression is true, the action statement'
write(io,'(a)')'   is executed. If the value is false, the action statement is not executed'
write(io,'(a)')'   and execution continues.'
write(io,'(a)')''
write(io,'(a)')'   The execution of a function reference in the scalar logical expression'
write(io,'(a)')'   may affect entities in the action statement.'
write(io,'(a)')''
write(io,'(a)')'   An example of an IF statement is:'
write(io,'(a)')''
write(io,'(a)')'       IF (A > 0.0) A = LOG (A)'
write(io,'(a)')''
write(io,'(a)')'EXAMPLES'
write(io,'(a)')''
write(io,'(a)')'  Sample IF constructs:'
write(io,'(a)')''
write(io,'(a)')'     if (cvar == ''RESET'') then'
write(io,'(a)')'        i = 0; j = 0; k = 0'
write(io,'(a)')''
write(io,'(a)')'endif'
write(io,'(a)')''
write(io,'(a)')'     OUTER: if (case.eq.0)then'
write(io,'(a)')'        PROOF_DONE: if (PROP) then'
write(io,'(a)')'           write (3, ''(''''QED'''')'')'
write(io,'(a)')'           exit OUTER'
write(io,'(a)')'        else'
write(io,'(a)')'           PROP = nextprop'
write(io,'(a)')'        endif PROOF_DONE'
write(io,'(a)')'        write(*,*)''END OF PROOF_DONE'''
write(io,'(a)')'     else OUTER'
write(io,'(a)')'             write(*,*)''else outer'''
write(io,'(a)')'     endif OUTER'
write(io,'(a)')''
write(io,'(a)')'     if (a > 0) then'
write(io,'(a)')'        b = c/a'
write(io,'(a)')'        if (b > 0) then'
write(io,'(a)')'           d = 1.0'
write(io,'(a)')'        end if'
write(io,'(a)')'     elseif (c > 0) then'
write(io,'(a)')'        b = a/c'
write(io,'(a)')'        d = -1.0'
write(io,'(a)')'     else'
write(io,'(a)')'        b = abs (max (a, c))'
write(io,'(a)')'        d = 0'
write(io,'(a)')'     endif'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   SAVE(7f) - [FORTRAN:STATEMENT:ATTRIBUTE] specifies that a local variable retains its status and value after a RE&
   &TURN'
write(io,'(a)')'   (LICENSE:PD)'
write(io,'(a)')''
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'   SAVE [ [ :: ] saved-entity-list ]'
write(io,'(a)')''
write(io,'(a)')'      saved-entity                 is object-name'
write(io,'(a)')'                                   or proc-pointer-name'
write(io,'(a)')'                                   or / common-block-name /'
write(io,'(a)')''
write(io,'(a)')'      proc-pointer-name            is   name'
write(io,'(a)')''
write(io,'(a)')'   or as an attribute of a data entity declaration. For example,'
write(io,'(a)')''
write(io,'(a)')'      INTEGER,SAVE :: II'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'1 The SAVE attribute specifies that a local variable of a program unit or subprogram retains its association status&
   &,'
write(io,'(a)')'  allocation status, definition status, and value after execution of a RETURN or END statement unless it is a'
write(io,'(a)')'  pointer and its target becomes undefined. If it is a local variable of a subprogram it is shared by all'
write(io,'(a)')'  instances of the subprogram.'
write(io,'(a)')''
write(io,'(a)')'  An entity with the SAVE attribute shall be a common block, variable, or procedure pointer.'
write(io,'(a)')''
write(io,'(a)')'  The SAVE attribute shall not be specified for a dummy argument, a function result, an automatic data'
write(io,'(a)')'  object, or an object that is in a common block.'
write(io,'(a)')''
write(io,'(a)')'  If a SAVE statement with an omitted saved entity list appears in a scoping unit, no other'
write(io,'(a)')'  appearance of the SAVE attr-spec or SAVE statement is permitted in that scoping unit.'
write(io,'(a)')''
write(io,'(a)')'  A local variable of a pure subprogram, or of a BLOCK construct within'
write(io,'(a)')'  a pure subprogram, shall not have the SAVE attribute. Variable'
write(io,'(a)')'  initialization in a type-declaration-stmt or a data-stmt implies the'
write(io,'(a)')'  SAVE attribute; therefore, such initialization is also disallowed in'
write(io,'(a)')'  a pure subprogram.'
write(io,'(a)')''
write(io,'(a)')'2 The SAVE attribute specifies that a local variable of a BLOCK construct retains its association status, allocatio&
   &n'
write(io,'(a)')'  status, definition status, and value after termination of the construct unless it is a pointer and its target bec&
   &omes'
write(io,'(a)')'  undefined (16.5.2.5(6)). If the BLOCK construct is within a subprogram the variable is shared by all instances'
write(io,'(a)')'  (12.6.2.4) of the subprogram.'
write(io,'(a)')''
write(io,'(a)')'3 Giving a common block the SAVE attribute confers the attribute on all entities in the common block.'
write(io,'(a)')''
write(io,'(a)')'4 A variable, common block, or procedure pointer declared in the scoping unit of a main program, module, or'
write(io,'(a)')'  submodule implicitly has the SAVE attribute, which may be confirmed by explicit specification. If a common'
write(io,'(a)')'  block has the SAVE attribute in any other kind of scoping unit, it shall have the SAVE attribute in every scoping'
write(io,'(a)')'  unit that is not a main program, module, or submodule.'
write(io,'(a)')''
write(io,'(a)')'SAVE ATTRIBUTE'
write(io,'(a)')''
write(io,'(a)')'1 A blank common block has the same properties as a named common block, except for the following.'
write(io,'(a)')''
write(io,'(a)')'      Execution of a RETURN or END statement might cause data objects'
write(io,'(a)')'      in a named common block to become'
write(io,'(a)')'      undefined unless the common block has the SAVE attribute, but'
write(io,'(a)')'      never causes data objects in blank common to become undefined.'
write(io,'(a)')''
write(io,'(a)')' 2 When the execution of a procedure is terminated by execution of a RETURN or END statement, an unsaved'
write(io,'(a)')'   allocatable local variable of the procedure retains its allocation and definition status if it is a function res&
   &ult'
write(io,'(a)')'   variable or a subobject thereof; otherwise, it is deallocated.'
write(io,'(a)')''
write(io,'(a)')' 3 When a BLOCK construct terminates, an unsaved allocatable local variable of the construct is deallocated.'
write(io,'(a)')''
write(io,'(a)')'1 A SAVE statement with a saved entity list specifies the SAVE attribute (5.3.16) for a list of entities. A SAVE'
write(io,'(a)')'  statement without a saved entity list is treated as though it contained the names of all allowed items in the sam&
   &e'
write(io,'(a)')'  scoping unit.'
write(io,'(a)')''
write(io,'(a)')'3 Explicit initialization of a variable that is not in a common block implies the SAVE attribute, which may be'
write(io,'(a)')'   confirmed by explicit specification.'
write(io,'(a)')'3 The BIND attribute for a variable or common block implies the SAVE attribute, which may be confirmed by'
write(io,'(a)')'  explicit specification.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'   To assign the SAVE attribute to all local variables in a subprogram'
write(io,'(a)')''
write(io,'(a)')'    SAVE'
write(io,'(a)')''
write(io,'(a)')'   An example of a typical SAVE statement is:'
write(io,'(a)')''
write(io,'(a)')'    SAVE A, B, C, / BLOCKA /, D'
write(io,'(a)')''
write(io,'(a)')'   Example with an allocatable variable'
write(io,'(a)')''
write(io,'(a)')'    subroutine process'
write(io,'(a)')'      real, allocatable :: temp(:)'
write(io,'(a)')'      real, allocatable, save :: x(:)'
write(io,'(a)')'      ...'
write(io,'(a)')'    end subroutine process'
write(io,'(a)')''
write(io,'(a)')'   on return from subroutine PROCESS, the allocation status of X is'
write(io,'(a)')'   preserved because X has the SAVE attribute. TEMP does not have the'
write(io,'(a)')'   SAVE attribute, so it will be deallocated if it was allocated. On'
write(io,'(a)')'   the next invocation of PROCESS, TEMP will have an allocation status'
write(io,'(a)')'   of unallocated.'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   NULLIFY(7f) - [FORTRAN:STATEMENT] causes pointers to be disassociated'
write(io,'(a)')'   (LICENSE:PD)'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'  NULLIFY ( pointer-object-list )'
write(io,'(a)')''
write(io,'(a)')'   pointer-object               is variable-name'
write(io,'(a)')'                                or structure-component'
write(io,'(a)')'                                or proc-pointer-name'
write(io,'(a)')''
write(io,'(a)')'   Each pointer-object shall have the POINTER attribute.'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'  A pointer-object shall not depend on the value, bounds, or association status of another pointer-object in the'
write(io,'(a)')'  same NULLIFY statement.'
write(io,'(a)')''
write(io,'(a)')'  When a NULLIFY statement is applied to a polymorphic pointer, its dynamic type becomes the declared type.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'NAME'
write(io,'(a)')'   IMPLICIT(7f) - [FORTRAN:STATEMENT]  specify default type (if any) associated to a starting letter'
write(io,'(a)')'   (LICENSE:PD)'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'    IMPLICIT [NONE]|[declaration-type-spec (letter-spec-list)]'
write(io,'(a)')'    determine default mapping between between the first letter of a data entity and a type.'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Every data entity has a type. If a type is not explicitly assigned to'
write(io,'(a)')'   a variable or function it will (by default) be assigned one according'
write(io,'(a)')'   to the following rule -- the type is INTEGER if the name starts with'
write(io,'(a)')'   the letters from I to N (the first two letters of the word "integer");'
write(io,'(a)')'   otherwise it defaults to REAL.'
write(io,'(a)')''
write(io,'(a)')'   The IMPLICIT statement allows the default rule to be changed or set'
write(io,'(a)')'   to null. To turn off implicit typing enter one and only one IMPLICIT'
write(io,'(a)')'   statement in the scoping unit'
write(io,'(a)')''
write(io,'(a)')'      implicit none ! Disable all implicit typing'
write(io,'(a)')''
write(io,'(a)')'   Each data entity will now require explicitly having a type declared'
write(io,'(a)')'   (INTEGER, REAL, DOUBLE, COMPLEX, ...).'
write(io,'(a)')''
write(io,'(a)')'   This must appear after any USE statements and before any type'
write(io,'(a)')'   declarations, including PARAMETER statements (which must know the'
write(io,'(a)')'   rules to determine what type names are that have not been explicitly'
write(io,'(a)')'   declared).'
write(io,'(a)')''
write(io,'(a)')'   In most new code implicit typing is turned off either with an "IMPLICIT'
write(io,'(a)')'   NONE" or sometimes by a compiler switch. On the other hand, the majority'
write(io,'(a)')'   of pre-fortran90 code depends on implicit defaults.'
write(io,'(a)')''
write(io,'(a)')'   Each prefix letter may have the type assigned to it declared only'
write(io,'(a)')'   once in a unit.'
write(io,'(a)')''
write(io,'(a)')'   The default rule, expressed as an IMPLICIT statement is'
write(io,'(a)')''
write(io,'(a)')'      implicit real(a-h,o-z),integer(i-k)'
write(io,'(a)')''
write(io,'(a)')'   To make the default for all names be a DOUBLEPRECISION type one could enter'
write(io,'(a)')''
write(io,'(a)')'      implicit doubleprecision (a-h,o-z)'
write(io,'(a)')''
write(io,'(a)')'   In another unit one might specify (multiple statements and compound'
write(io,'(a)')'   statements are allowed, as illustrated):'
write(io,'(a)')''
write(io,'(a)')'      implicit complex (c), doubleprecision (d)'
write(io,'(a)')'      implicit integer (i)'
write(io,'(a)')'      implicit logical (l)'
write(io,'(a)')'      implicit real (r)'
write(io,'(a)')'      implicit character(len=8) (a,b,e-h,j,k,m-q,s-z)'
write(io,'(a)')''
write(io,'(a)')'   There is no way to make some letters default to no type and others'
write(io,'(a)')'   have a default. Either nothing has a default type or everything does:'
write(io,'(a)')''
write(io,'(a)')'      implicit (a-h)  ! NOT ALLOWED. A TYPE MUST BE SPECIFIED'
write(io,'(a)')''
write(io,'(a)')'  The default for an internal or module procedure is the mapping in the'
write(io,'(a)')'  host scoping unit.'
write(io,'(a)')''
write(io,'(a)')'  Any data entity that is not explicitly declared by a type declaration'
write(io,'(a)')'  statement, is not an intrinsic function, and is not accessed by use or'
write(io,'(a)')'  host association is declared implicitly to be of the type (and type'
write(io,'(a)')'  parameters) mapped from the first letter of its name, provided the'
write(io,'(a)')'  mapping is not null.'
write(io,'(a)')''
write(io,'(a)')'  The mapping may be to a derived type that is inaccessible in the local'
write(io,'(a)')'  scope if the derived type is accessible in the host scoping unit. The'
write(io,'(a)')'  data entity is treated as if it were declared in an explicit type'
write(io,'(a)')'  declaration in the outermost scoping unit in which it appears. An'
write(io,'(a)')'  explicit type specification in a FUNCTION statement overrides'
write(io,'(a)')'  an IMPLICIT statement for the name of the result variable of that'
write(io,'(a)')'  function subprogram.'
write(io,'(a)')''
write(io,'(a)')'OPTIONS'
write(io,'(a)')'    NONE            If IMPLICIT NONE is specified in a scoping unit, it shall precede any PARAMETER statements'
write(io,'(a)')'                    that appear in the scoping unit and there shall be no other IMPLICIT statements in the scoping &
   &unit.'
write(io,'(a)')'      or'
write(io,'(a)')'    declaration-type-spec'
write(io,'(a)')''
write(io,'(a)')'    letter-spec      is (letter-or-range[,letter-or-range] [,letter-or-range] )'
write(io,'(a)')'                     If the minus and second letter appear, the second'
write(io,'(a)')'                     letter shall follow the first letter alphabetically.'
write(io,'(a)')'                     A letter-spec consisting of two letter s separated by'
write(io,'(a)')'                     a minus is equivalent to writing a list containing'
write(io,'(a)')'                     all of the letters in alphabetical order in the'
write(io,'(a)')'                     alphabetic sequence from the first letter through'
write(io,'(a)')'                     the second letter. For example, A-C is equivalent'
write(io,'(a)')'                     to A, B, C. The same letter shall not appear as a'
write(io,'(a)')'                     single letter, or be included in a range of letters,'
write(io,'(a)')'                     more than once in all of the IMPLICIT statements'
write(io,'(a)')'                     in a scoping unit.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  The following are examples of the use of IMPLICIT statements:'
write(io,'(a)')''
write(io,'(a)')'        module example_module'
write(io,'(a)')'           implicit none'
write(io,'(a)')'           ...'
write(io,'(a)')'           interface'
write(io,'(a)')'              function fun (i)    ! not all data entities need to'
write(io,'(a)')'                 integer fun      ! be declared explicitly'
write(io,'(a)')'              end function fun'
write(io,'(a)')'           end interface'
write(io,'(a)')'        contains'
write(io,'(a)')'           function jfun (j)      ! all data entities need to'
write(io,'(a)')'              integer jfun, j     ! be declared explicitly.'
write(io,'(a)')'              ...'
write(io,'(a)')'           end function jfun'
write(io,'(a)')'        end module example_module'
write(io,'(a)')''
write(io,'(a)')'        subroutine sub'
write(io,'(a)')'           implicit complex (c)'
write(io,'(a)')'           CM = (3.0, 2.0)      ! CM is implicitly declared COMPLEX'
write(io,'(a)')'           ...'
write(io,'(a)')'        contains'
write(io,'(a)')'           subroutine sub1'
write(io,'(a)')'              IMPLICIT INTEGER (A, C)'
write(io,'(a)')'              C = (0.0, 0.0) ! C is host associated and of'
write(io,'(a)')'                             ! type complex'
write(io,'(a)')'              Z = 1.0        ! Z is implicitly declared REAL'
write(io,'(a)')'              A = 2          ! A is implicitly declared INTEGER'
write(io,'(a)')'              CC = 1         ! CC is implicitly declared INTEGER'
write(io,'(a)')'              ...'
write(io,'(a)')'           end subroutine sub1'
write(io,'(a)')'           subroutine sub2'
write(io,'(a)')'              Z = 2.0         ! Z is implicitly declared REAL and'
write(io,'(a)')'                              ! is different from the variable of'
write(io,'(a)')'                              ! the same name in SUB1'
write(io,'(a)')'              ...'
write(io,'(a)')'           end subroutine sub2'
write(io,'(a)')'           subroutine sub3'
write(io,'(a)')'              USE EXAMPLE_MODULE ! Accesses integer function FUN'
write(io,'(a)')'                                  ! by use association'
write(io,'(a)')'              Q = FUN (K)         ! Q is implicitly declared REAL and'
write(io,'(a)')'              ...                 ! K is implicitly declared INTEGER'
write(io,'(a)')'           end subroutine sub3'
write(io,'(a)')'        end subroutine sub'
write(io,'(a)')''
write(io,'(a)')'        The following is an example of a mapping to a derived type that is inaccessible in the local scope:'
write(io,'(a)')''
write(io,'(a)')'              program main'
write(io,'(a)')'                implicit type(blob) (a)'
write(io,'(a)')'                type blob'
write(io,'(a)')'                  integer :: i'
write(io,'(a)')'                end type blob'
write(io,'(a)')'                type(blob) :: b'
write(io,'(a)')'                call steve'
write(io,'(a)')'              contains'
write(io,'(a)')'                subroutine steve'
write(io,'(a)')'                  integer :: blob'
write(io,'(a)')'                  ..'
write(io,'(a)')'                  aa = b'
write(io,'(a)')'                  ..'
write(io,'(a)')'                end subroutine steve'
write(io,'(a)')'              end program main'
write(io,'(a)')''
write(io,'(a)')'        In the subroutine STEVE, it is not possible to explicitly declare a variable to be of type BLOB because'
write(io,'(a)')'        BLOB has been given a different meaning, but implicit mapping for the letter A still maps to type BLOB,'
write(io,'(a)')'        so AA is of type BLOB.'
write(io,'(a)')'NAME'
write(io,'(a)')'   allocate(3f) - [FORTRAN:STATEMENT] The ALLOCATE statement dynamically creates pointer targets and allocatable va&
   &riables.'
write(io,'(a)')'   (LICENSE:PD)'
write(io,'(a)')''
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')''
write(io,'(a)')'   general form:'
write(io,'(a)')''
write(io,'(a)')'    ALLOCATE ([type-spec ::] allocation-list [, alloc-opt-list])'
write(io,'(a)')''
write(io,'(a)')'       o      alloc-opt       is   ERRMSG = scalar_default_char_variable'
write(io,'(a)')'                               or  MOLD = source-expr'
write(io,'(a)')'                               or  SOURCE = source-expr'
write(io,'(a)')'                               or  STAT = scalar_int_variable'
write(io,'(a)')''
write(io,'(a)')'USE OF DATA OBJECTS'
write(io,'(a)')''
write(io,'(a)')'   o   allocation                    is   allocate-object [ ( allocate-shape-spec-list ) ]'
write(io,'(a)')'                                             [ lbracket allocate-coarray-spec rbracket ]'
write(io,'(a)')''
write(io,'(a)')'   o   allocate-object               is variable-name'
write(io,'(a)')'                                     or structure-component'
write(io,'(a)')''
write(io,'(a)')'   o   allocate-shape-spec           is   [ lower-bound-expr : ] upper-bound-expr'
write(io,'(a)')''
write(io,'(a)')'   o   lower-bound-expr              is   scalar-int-expr'
write(io,'(a)')''
write(io,'(a)')'   o   upper-bound-expr              is   scalar-int-expr'
write(io,'(a)')''
write(io,'(a)')'   o   allocate-coarray-spec         is   [ allocate-coshape-spec-list , ] [ lower-bound-expr : ] *'
write(io,'(a)')''
write(io,'(a)')'   o   allocate-coshape-spec         is   [ lower-bound-expr : ] upper-bound-expr'
write(io,'(a)')''
write(io,'(a)')'   o   Each allocate-object shall be a nonprocedure pointer or an allocatable variable.'
write(io,'(a)')''
write(io,'(a)')'   o   If any allocate-object has a deferred type parameter, is unlimited polymorphic, or is of abstract'
write(io,'(a)')'       type, either type-spec or source-expr shall appear.'
write(io,'(a)')''
write(io,'(a)')'   o   If type-spec appears, it shall specify a type with which each allocate-object is type compatible.'
write(io,'(a)')''
write(io,'(a)')'   o   A type-param-value in a type-spec shall be an asterisk if and only if each allocate-object is a'
write(io,'(a)')'       dummy argument for which the corresponding type parameter is assumed.'
write(io,'(a)')''
write(io,'(a)')'   o   If type-spec appears, the kind type parameter values of each allocate-object shall be the same as'
write(io,'(a)')'       the corresponding type parameter values of the type-spec.'
write(io,'(a)')''
write(io,'(a)')'   o   If allocate-object is an array either allocate-shape-spec-list shall appear or source-expr shall appear'
write(io,'(a)')'       and have the same rank as allocate-object. If allocate-object is scalar, allocate-shape-spec-list shall not'
write(io,'(a)')'       appear.'
write(io,'(a)')''
write(io,'(a)')'   o   An allocate-coarray-spec shall appear if and only if the allocate-object is a coarray.'
write(io,'(a)')''
write(io,'(a)')'   o   The number of allocate-shape-specs in an allocate-shape-spec-list shall be the same as the rank'
write(io,'(a)')'       of the allocate-object. The number of allocate-coshape-specs in an allocate-coarray-spec shall be one less'
write(io,'(a)')'       than the corank of the allocate-object.'
write(io,'(a)')''
write(io,'(a)')'   o   No alloc-opt shall appear more than once in a given alloc-opt-list.'
write(io,'(a)')''
write(io,'(a)')'   o   At most one of source-expr and type-spec shall appear.'
write(io,'(a)')''
write(io,'(a)')'   o   Each allocate-object shall be type compatible (4.3.1.3) with source-expr . If SOURCE= appears,'
write(io,'(a)')'       source-expr shall be a scalar or have the same rank as each allocate-object.'
write(io,'(a)')''
write(io,'(a)')'   o   Corresponding kind type parameters of allocate-object and source-expr shall have the same values.'
write(io,'(a)')''
write(io,'(a)')'   o   type-spec shall not specify a type that has a coarray ultimate component.'
write(io,'(a)')''
write(io,'(a)')'   o   type-spec shall not specify the type C PTR or C FUNPTR if an allocate-object is a coarray.'
write(io,'(a)')''
write(io,'(a)')'   o   The declared type of source-expr shall not be C PTR or C FUNPTR if an allocate-object is a'
write(io,'(a)')'       coarray.'
write(io,'(a)')''
write(io,'(a)')'   o   The declared type of source-expr shall not have a coarray ultimate component.'
write(io,'(a)')''
write(io,'(a)')'   o   An allocate-object shall not be a coindexed object.'
write(io,'(a)')''
write(io,'(a)')'        NOTE:'
write(io,'(a)')'        If a coarray is of a derived type that has an allocatable component, the component shall be allocated by it&
   &s'
write(io,'(a)')'        own image:'
write(io,'(a)')''
write(io,'(a)')'        TYPE(SOMETHING), ALLOCATABLE :: T[:]'
write(io,'(a)')'        ...'
write(io,'(a)')'        ALLOCATE(T[*])          ! Allowed - implies synchronization'
write(io,'(a)')'        ALLOCATE(T%AAC(N))      ! Allowed - allocated by its own image'
write(io,'(a)')'        ALLOCATE(T[Q]%AAC(N))   ! Not allowed, because it is not'
write(io,'(a)')'                                ! necessarily executed on image Q.'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'  An allocate-object or a bound or type parameter of an allocate-object'
write(io,'(a)')'  shall not depend on the value of stat-variable, the value of'
write(io,'(a)')'  errmsg-variable, or on the value, bounds, length type parameters,'
write(io,'(a)')'  allocation status, or association status of any allocate-object in'
write(io,'(a)')'  the same ALLOCATE statement.'
write(io,'(a)')''
write(io,'(a)')'  source-expr shall not be allocated within the ALLOCATE statement in'
write(io,'(a)')'  which it appears; nor shall it depend on the value, bounds, deferred'
write(io,'(a)')'  type parameters, allocation status, or association status of any'
write(io,'(a)')'  allocate-object in that statement.'
write(io,'(a)')''
write(io,'(a)')'  If type-spec is specified, each allocate-object is allocated with the'
write(io,'(a)')'  specified dynamic type and type parameter values; if source-expr is'
write(io,'(a)')'  specified, each allocate-object is allocated with the dynamic type and'
write(io,'(a)')'  type parameter values of source-expr ; otherwise, each allocate-object'
write(io,'(a)')'  is allocated with its dynamic type the same as its declared type.'
write(io,'(a)')''
write(io,'(a)')'  If type-spec appears and the value of a type parameter it specifies'
write(io,'(a)')'  differs from the value of the corresponding nondeferred type parameter'
write(io,'(a)')'  specified in the declaration of any allocate-object, an error condition'
write(io,'(a)')'  occurs. If the value of a nondeferred length type parameter of an'
write(io,'(a)')'  allocate-object differs from the value of the corresponding type'
write(io,'(a)')'  parameter of source-expr , an error condition occurs.'
write(io,'(a)')''
write(io,'(a)')'  If a type-param-value in a type-spec in an ALLOCATE statement is'
write(io,'(a)')'  an asterisk, it denotes the current value of that assumed type'
write(io,'(a)')'  parameter. If it is an expression, subsequent redefinition or'
write(io,'(a)')'  undefinition of any entity in the expression does not affect the type'
write(io,'(a)')'  parameter value.'
write(io,'(a)')''
write(io,'(a)')'        NOTE:'
write(io,'(a)')'        An example of an ALLOCATE statement is:'
write(io,'(a)')''
write(io,'(a)')'        ALLOCATE (X (N), B (-3 : M, 0:9), STAT = IERR_ALLOC)'
write(io,'(a)')''
write(io,'(a)')'EXECUTION OF AN ALLOCATE STATEMENT'
write(io,'(a)')''
write(io,'(a)')'  When an ALLOCATE statement is executed for an array for which'
write(io,'(a)')'  allocate-shape-spec-list is specified, the values of the lower bound and'
write(io,'(a)')'  upper bound expressions determine the bounds of the array. Subsequent'
write(io,'(a)')'  redefinition or undefinition of any entities in the bound expressions'
write(io,'(a)')'  do not affect the array bounds. If the lower bound is omitted, the'
write(io,'(a)')'  default value is 1. If the upper bound is less than the lower bound,'
write(io,'(a)')'  the extent in that dimension is zero and the array has zero size.'
write(io,'(a)')''
write(io,'(a)')'  When an ALLOCATE statement is executed for a coarray, the values of the'
write(io,'(a)')'  lower cobound and upper cobound expressions determine the cobounds of'
write(io,'(a)')'  the coarray. Subsequent redefinition or undefinition of any entities'
write(io,'(a)')'  in the cobound expressions do not affect the cobounds. If the lower'
write(io,'(a)')'  cobound is omitted, the default value is 1. The upper cobound shall'
write(io,'(a)')'  not be less than the lower cobound.'
write(io,'(a)')''
write(io,'(a)')'  If an allocation specifies a coarray, its dynamic type and the values'
write(io,'(a)')'  of corresponding type parameters shall be the same on each image. The'
write(io,'(a)')'  values of corresponding bounds and corresponding cobounds shall be the'
write(io,'(a)')'  same on each image. If the coarray is a dummy argument, its ultimate'
write(io,'(a)')'  argument (12.5.2.3) shall be the same coarray on every image.'
write(io,'(a)')''
write(io,'(a)')'  There is implicit synchronization of all images in association with'
write(io,'(a)')'  each ALLOCATE statement that allocates one or more coarrays. On each'
write(io,'(a)')'  image, execution of the segment (8.5.1) following the statement is'
write(io,'(a)')'  delayed until all other images have executed the same statement the'
write(io,'(a)')'  same number of times.'
write(io,'(a)')''
write(io,'(a)')'         NOTE:'
write(io,'(a)')''
write(io,'(a)')'         When an image executes an ALLOCATE statement, communication'
write(io,'(a)')'         is not necessarily involved apart from any required for'
write(io,'(a)')'         synchronization. The image allocates its coarray and records'
write(io,'(a)')'         how the corresponding coarrays on other images are to be'
write(io,'(a)')'         addressed. The processor is not required to detect violations'
write(io,'(a)')'         of the rule that the bounds are the same on all images, nor'
write(io,'(a)')'         is it responsible for detecting or resolving deadlock problems'
write(io,'(a)')'         (such as two images waiting on different ALLOCATE statements).'
write(io,'(a)')''
write(io,'(a)')'  If source-expr is a pointer, it shall be associated with a target. If'
write(io,'(a)')'  source-expr is allocatable, it shall be allocated.'
write(io,'(a)')''
write(io,'(a)')'  When an ALLOCATE statement is executed for an array with no'
write(io,'(a)')'  allocate-shape-spec-list, the bounds of source-expr determine the'
write(io,'(a)')'  bounds of the array. Subsequent changes to the bounds of source-expr'
write(io,'(a)')'  do not affect the array bounds.'
write(io,'(a)')''
write(io,'(a)')'  If SOURCE= appears, source-expr shall be conformable (2.5.6) with'
write(io,'(a)')'  allocation. If the value of a nondeferred length type parameter of'
write(io,'(a)')'  allocate-object is different from the value of the corresponding type'
write(io,'(a)')'  parameter of source-expr , an error condition occurs. On successful'
write(io,'(a)')'  allocation, if allocate-object and source-expr have the same rank the'
write(io,'(a)')'  value of allocate-object becomes that of source-expr , otherwise the'
write(io,'(a)')'  value of each element of allocate-object becomes that of source-expr .'
write(io,'(a)')''
write(io,'(a)')'  If MOLD= appears and source-expr is a variable, its value need not be defined.'
write(io,'(a)')''
write(io,'(a)')'  The STAT= specifier is described in 6.6.4.'
write(io,'(a)')''
write(io,'(a)')'  If an error condition occurs during execution of an ALLOCATE statement'
write(io,'(a)')'  that does not contain the STAT= specifier, error termination is'
write(io,'(a)')'  initiated.'
write(io,'(a)')''
write(io,'(a)')'  The ERRMSG= specifier is described in 6.6.5.'
write(io,'(a)')''
write(io,'(a)')'ALLOCATION OF ALLOCATABLE VARIABLES'
write(io,'(a)')''
write(io,'(a)')'  The allocation status of an allocatable entity is one of the following'
write(io,'(a)')'  at any time. The status of an allocatable variable becomes allocated'
write(io,'(a)')'  if it is allocated by an ALLOCATE statement, if it is allocated during'
write(io,'(a)')'  assignment, or if it is given that status by the intrinsic subroutine'
write(io,'(a)')'  MOVE ALLOC(13.7.117). An allocatable variable with this status may be'
write(io,'(a)')'  referenced, defined, or deallocated; allocating it causes an error'
write(io,'(a)')'  condition in the ALLOCATE statement. The intrinsic function ALLOCATED'
write(io,'(a)')'  (13.7.11) returns true for such a variable.'
write(io,'(a)')''
write(io,'(a)')'   An allocatable variable has a status of unallocated if it is not'
write(io,'(a)')'  allocated. The status of an allocatable variable becomes unallocated'
write(io,'(a)')'  if it is deallocated (6.6.3) or if it is given that status by the'
write(io,'(a)')'  allocation transfer procedure. An allocatable variable with this'
write(io,'(a)')'  status shall not be referenced or defined. It shall not be supplied as'
write(io,'(a)')'  an actual argument corresponding to a nonallocatable dummy argument,'
write(io,'(a)')'  except to certain intrinsic inquiry functions. It may be allocated with'
write(io,'(a)')'  the ALLOCATE statement. Deallocating it causes an error condition in'
write(io,'(a)')'  the DEALLOCATE statement. The intrinsic function ALLOCATED (13.7.11)'
write(io,'(a)')'  returns false for such a variable.'
write(io,'(a)')''
write(io,'(a)')'  At the beginning of execution of a program, allocatable variables'
write(io,'(a)')'  are unallocated.'
write(io,'(a)')''
write(io,'(a)')'  When the allocation status of an allocatable variable changes, the'
write(io,'(a)')'  allocation status of any associated allocatable variable changes'
write(io,'(a)')'  accordingly. Allocation of an allocatable variable establishes'
write(io,'(a)')'  values for the deferred type parameters of all associated allocatable'
write(io,'(a)')'  variables.'
write(io,'(a)')''
write(io,'(a)')'  An unsaved allocatable local variable of a procedure has a status of'
write(io,'(a)')'  unallocated at the beginning of each invocation of the procedure. An'
write(io,'(a)')'  unsaved local variable of a construct has a status of unallocated at'
write(io,'(a)')'  the beginning of each execution of the construct.'
write(io,'(a)')''
write(io,'(a)')'  When an object of derived type is created by an ALLOCATE statement,'
write(io,'(a)')'  any allocatable ultimate components have an allocation status of'
write(io,'(a)')'  unallocated.'
write(io,'(a)')''
write(io,'(a)')'ALLOCATION OF POINTER TARGETS'
write(io,'(a)')''
write(io,'(a)')'  Allocation of a pointer creates an object that implicitly has the TARGET'
write(io,'(a)')'  attribute. Following successful execution of an ALLOCATE statement for'
write(io,'(a)')'  a pointer, the pointer is associated with the target and may be used'
write(io,'(a)')'  to reference or define the target. Additional pointers may become'
write(io,'(a)')'  associated with the pointer target or a part of the pointer target'
write(io,'(a)')'  by pointer assignment. It is not an error to allocate a pointer that'
write(io,'(a)')'  is already associated with a target. In this case, a new pointer'
write(io,'(a)')'  target is created as required by the attributes of the pointer and'
write(io,'(a)')'  any array bounds, type, and type parameters specified by the ALLOCATE'
write(io,'(a)')'  statement. The pointer is then associated with this new target. Any'
write(io,'(a)')'  previous association of the pointer with a target is broken. If the'
write(io,'(a)')'  previous target had been created by allocation, it becomes inaccessible'
write(io,'(a)')'  unless other pointers are associated with it. The intrinsic function'
write(io,'(a)')'  ASSOCIATED (13.7.16) may be used to determine whether a pointer that'
write(io,'(a)')'  does not have undefined association status is associated.'
write(io,'(a)')''
write(io,'(a)')'  At the beginning of execution of a function whose result is a pointer,'
write(io,'(a)')'  the association status of the result pointer is undefined. Before such'
write(io,'(a)')'  a function returns, it shall either associate a target with this pointer'
write(io,'(a)')'  or cause the association status of this pointer to become disassociated.'
write(io,'(a)')'.\" Specification of Fortran'
write(io,'(a)')'.TH CONTINUE "7" "January 2017" "Fortran" "Language Specification"'
write(io,'(a)')'.SH NAME'
write(io,'(a)')'   CONTINUE(7f) - [FORTRAN:EXECUTION CONTROL] construct (LICENSE:PD)'
write(io,'(a)')'.SH SYNOPSIS'
write(io,'(a)')'   continue'
write(io,'(a)')'.SH DESCRIPTION'
write(io,'(a)')'.nf'
write(io,'(a)')'  Execution of a CONTINUE statement has no effect. A CONTINUE statement'
write(io,'(a)')'  is most often used as a labeled line that is used in transfer control'
write(io,'(a)')'  statements to numerically labeled lines such as GOTO. It is often'
write(io,'(a)')'  very confusing to have executable statements on labeled lines; a'
write(io,'(a)')'  CONTINUE statement eliminates the ambiguities that arise in jumping'
write(io,'(a)')'  to an executable line. Preferably no target of a transfer should be an'
write(io,'(a)')'  executable statement, but should be a statement like ENDDO or CONTINUE.'
write(io,'(a)')''
write(io,'(a)')'  CONTINUE was very frequently used as the end of a DO loop; ENDDO'
write(io,'(a)')'  is now the proper way to end a DO loop.'
write(io,'(a)')'.fi'
write(io,'(a)')'.SH EXAMPLE'
write(io,'(a)')'.nf'
write(io,'(a)')'   program demo_continue'
write(io,'(a)')'         I=10'
write(io,'(a)')'         J=5'
write(io,'(a)')'         if(I.lt.5)goto 100'
write(io,'(a)')'         J=3'
write(io,'(a)')'   100   continue'
write(io,'(a)')'         write(*,*)''J='',J'
write(io,'(a)')''
write(io,'(a)')'   end program demo_continue'
write(io,'(a)')'.fi'
end program intrinsics_man_pages
